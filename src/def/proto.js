/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.alliance = (function() {

    /**
     * Namespace alliance.
     * @exports alliance
     * @namespace
     */
    var alliance = {};

    alliance.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof alliance
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof alliance
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {alliance.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.Ic2s_load=} [properties] Properties to set
         * @returns {alliance.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link alliance.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link alliance.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof alliance.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {alliance.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.alliance.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof alliance.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {alliance.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof alliance.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof alliance.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {alliance.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.alliance.c2s_load)
                return object;
            return new $root.alliance.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof alliance.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof alliance.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/alliance.c2s_load";
        };

        return c2s_load;
    })();

    alliance.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof alliance
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {number|null} [aid] s2c_load aid
         */

        /**
         * Constructs a new s2c_load.
         * @memberof alliance
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {alliance.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof alliance.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load aid.
         * @member {number} aid
         * @memberof alliance.s2c_load
         * @instance
         */
        s2c_load.prototype.aid = 0;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.Is2c_load=} [properties] Properties to set
         * @returns {alliance.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link alliance.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.aid);
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link alliance.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof alliance.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {alliance.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.alliance.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.aid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof alliance.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {alliance.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof alliance.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof alliance.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {alliance.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.alliance.s2c_load)
                return object;
            var message = new $root.alliance.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.aid = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof alliance.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof alliance.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/alliance.s2c_load";
        };

        return s2c_load;
    })();

    return alliance;
})();

$root.bag = (function() {

    /**
     * Namespace bag.
     * @exports bag
     * @namespace
     */
    var bag = {};

    bag.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof bag
         * @interface IItem
         * @property {number|null} [id] Item id
         * @property {number|null} [uid] Item uid
         * @property {number|null} [num] Item num
         * @property {number|null} [expireTs] Item expireTs
         */

        /**
         * Constructs a new Item.
         * @memberof bag
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {bag.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item id.
         * @member {number} id
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.id = 0;

        /**
         * Item uid.
         * @member {number} uid
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.uid = 0;

        /**
         * Item num.
         * @member {number} num
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.num = 0;

        /**
         * Item expireTs.
         * @member {number} expireTs
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.expireTs = 0;

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof bag.Item
         * @static
         * @param {bag.IItem=} [properties] Properties to set
         * @returns {bag.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link bag.Item.verify|verify} messages.
         * @function encode
         * @memberof bag.Item
         * @static
         * @param {bag.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.uid);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num);
            if (message.expireTs != null && Object.hasOwnProperty.call(message, "expireTs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expireTs);
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link bag.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.Item
         * @static
         * @param {bag.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.Item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.uid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.num = reader.uint32();
                        break;
                    }
                case 4: {
                        message.expireTs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof bag.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.expireTs != null && message.hasOwnProperty("expireTs"))
                if (!$util.isInteger(message.expireTs))
                    return "expireTs: integer expected";
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.Item)
                return object;
            var message = new $root.bag.Item();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.expireTs != null)
                message.expireTs = object.expireTs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.Item
         * @static
         * @param {bag.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.uid = 0;
                object.num = 0;
                object.expireTs = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.expireTs != null && message.hasOwnProperty("expireTs"))
                object.expireTs = message.expireTs;
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof bag.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Item
         * @function getTypeUrl
         * @memberof bag.Item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.Item";
        };

        return Item;
    })();

    bag.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof bag
         * @interface Ic2s_load
         * @property {number|null} [bagId] c2s_load bagId
         */

        /**
         * Constructs a new c2s_load.
         * @memberof bag
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {bag.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load bagId.
         * @member {number} bagId
         * @memberof bag.c2s_load
         * @instance
         */
        c2s_load.prototype.bagId = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof bag.c2s_load
         * @static
         * @param {bag.Ic2s_load=} [properties] Properties to set
         * @returns {bag.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link bag.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_load
         * @static
         * @param {bag.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bagId != null && Object.hasOwnProperty.call(message, "bagId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bagId);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link bag.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_load
         * @static
         * @param {bag.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bagId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof bag.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bagId != null && message.hasOwnProperty("bagId"))
                if (!$util.isInteger(message.bagId))
                    return "bagId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_load)
                return object;
            var message = new $root.bag.c2s_load();
            if (object.bagId != null)
                message.bagId = object.bagId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_load
         * @static
         * @param {bag.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bagId = 0;
            if (message.bagId != null && message.hasOwnProperty("bagId"))
                object.bagId = message.bagId;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof bag.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof bag.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_load";
        };

        return c2s_load;
    })();

    bag.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof bag
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<bag.IItem>|null} [items] s2c_load items
         */

        /**
         * Constructs a new s2c_load.
         * @memberof bag
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {bag.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof bag.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load items.
         * @member {Array.<bag.IItem>} items
         * @memberof bag.s2c_load
         * @instance
         */
        s2c_load.prototype.items = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof bag.s2c_load
         * @static
         * @param {bag.Is2c_load=} [properties] Properties to set
         * @returns {bag.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link bag.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_load
         * @static
         * @param {bag.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.bag.Item.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link bag.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_load
         * @static
         * @param {bag.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof bag.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.bag.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_load)
                return object;
            var message = new $root.bag.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".bag.s2c_load.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".bag.s2c_load.items: object expected");
                    message.items[i] = $root.bag.Item.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_load
         * @static
         * @param {bag.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.bag.Item.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof bag.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof bag.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_load";
        };

        return s2c_load;
    })();

    bag.c2s_use_item = (function() {

        /**
         * Properties of a c2s_use_item.
         * @memberof bag
         * @interface Ic2s_use_item
         * @property {number|null} [itemId] c2s_use_item itemId
         * @property {number|null} [num] c2s_use_item num
         */

        /**
         * Constructs a new c2s_use_item.
         * @memberof bag
         * @classdesc Represents a c2s_use_item.
         * @implements Ic2s_use_item
         * @constructor
         * @param {bag.Ic2s_use_item=} [properties] Properties to set
         */
        function c2s_use_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_use_item itemId.
         * @member {number} itemId
         * @memberof bag.c2s_use_item
         * @instance
         */
        c2s_use_item.prototype.itemId = 0;

        /**
         * c2s_use_item num.
         * @member {number} num
         * @memberof bag.c2s_use_item
         * @instance
         */
        c2s_use_item.prototype.num = 0;

        /**
         * Creates a new c2s_use_item instance using the specified properties.
         * @function create
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.Ic2s_use_item=} [properties] Properties to set
         * @returns {bag.c2s_use_item} c2s_use_item instance
         */
        c2s_use_item.create = function create(properties) {
            return new c2s_use_item(properties);
        };

        /**
         * Encodes the specified c2s_use_item message. Does not implicitly {@link bag.c2s_use_item.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.Ic2s_use_item} message c2s_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_use_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified c2s_use_item message, length delimited. Does not implicitly {@link bag.c2s_use_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.Ic2s_use_item} message c2s_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_use_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_use_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_use_item} c2s_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_use_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_use_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_use_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_use_item} c2s_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_use_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_use_item message.
         * @function verify
         * @memberof bag.c2s_use_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_use_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a c2s_use_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_use_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_use_item} c2s_use_item
         */
        c2s_use_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_use_item)
                return object;
            var message = new $root.bag.c2s_use_item();
            if (object.itemId != null)
                message.itemId = object.itemId >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_use_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.c2s_use_item} message c2s_use_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_use_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.num = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this c2s_use_item to JSON.
         * @function toJSON
         * @memberof bag.c2s_use_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_use_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_use_item
         * @function getTypeUrl
         * @memberof bag.c2s_use_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_use_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_use_item";
        };

        return c2s_use_item;
    })();

    bag.s2c_use_item = (function() {

        /**
         * Properties of a s2c_use_item.
         * @memberof bag
         * @interface Is2c_use_item
         * @property {number|null} [err] s2c_use_item err
         */

        /**
         * Constructs a new s2c_use_item.
         * @memberof bag
         * @classdesc Represents a s2c_use_item.
         * @implements Is2c_use_item
         * @constructor
         * @param {bag.Is2c_use_item=} [properties] Properties to set
         */
        function s2c_use_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_use_item err.
         * @member {number} err
         * @memberof bag.s2c_use_item
         * @instance
         */
        s2c_use_item.prototype.err = 0;

        /**
         * Creates a new s2c_use_item instance using the specified properties.
         * @function create
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.Is2c_use_item=} [properties] Properties to set
         * @returns {bag.s2c_use_item} s2c_use_item instance
         */
        s2c_use_item.create = function create(properties) {
            return new s2c_use_item(properties);
        };

        /**
         * Encodes the specified s2c_use_item message. Does not implicitly {@link bag.s2c_use_item.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.Is2c_use_item} message s2c_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_use_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_use_item message, length delimited. Does not implicitly {@link bag.s2c_use_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.Is2c_use_item} message s2c_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_use_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_use_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_use_item} s2c_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_use_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_use_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_use_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_use_item} s2c_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_use_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_use_item message.
         * @function verify
         * @memberof bag.s2c_use_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_use_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_use_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_use_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_use_item} s2c_use_item
         */
        s2c_use_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_use_item)
                return object;
            var message = new $root.bag.s2c_use_item();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_use_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.s2c_use_item} message s2c_use_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_use_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_use_item to JSON.
         * @function toJSON
         * @memberof bag.s2c_use_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_use_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_use_item
         * @function getTypeUrl
         * @memberof bag.s2c_use_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_use_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_use_item";
        };

        return s2c_use_item;
    })();

    bag.c2s_composite_item = (function() {

        /**
         * Properties of a c2s_composite_item.
         * @memberof bag
         * @interface Ic2s_composite_item
         * @property {number|null} [itemId] c2s_composite_item itemId
         * @property {number|null} [num] c2s_composite_item num
         */

        /**
         * Constructs a new c2s_composite_item.
         * @memberof bag
         * @classdesc Represents a c2s_composite_item.
         * @implements Ic2s_composite_item
         * @constructor
         * @param {bag.Ic2s_composite_item=} [properties] Properties to set
         */
        function c2s_composite_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_composite_item itemId.
         * @member {number} itemId
         * @memberof bag.c2s_composite_item
         * @instance
         */
        c2s_composite_item.prototype.itemId = 0;

        /**
         * c2s_composite_item num.
         * @member {number} num
         * @memberof bag.c2s_composite_item
         * @instance
         */
        c2s_composite_item.prototype.num = 0;

        /**
         * Creates a new c2s_composite_item instance using the specified properties.
         * @function create
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.Ic2s_composite_item=} [properties] Properties to set
         * @returns {bag.c2s_composite_item} c2s_composite_item instance
         */
        c2s_composite_item.create = function create(properties) {
            return new c2s_composite_item(properties);
        };

        /**
         * Encodes the specified c2s_composite_item message. Does not implicitly {@link bag.c2s_composite_item.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.Ic2s_composite_item} message c2s_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_composite_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified c2s_composite_item message, length delimited. Does not implicitly {@link bag.c2s_composite_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.Ic2s_composite_item} message c2s_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_composite_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_composite_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_composite_item} c2s_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_composite_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_composite_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_composite_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_composite_item} c2s_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_composite_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_composite_item message.
         * @function verify
         * @memberof bag.c2s_composite_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_composite_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a c2s_composite_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_composite_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_composite_item} c2s_composite_item
         */
        c2s_composite_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_composite_item)
                return object;
            var message = new $root.bag.c2s_composite_item();
            if (object.itemId != null)
                message.itemId = object.itemId >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_composite_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.c2s_composite_item} message c2s_composite_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_composite_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.num = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this c2s_composite_item to JSON.
         * @function toJSON
         * @memberof bag.c2s_composite_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_composite_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_composite_item
         * @function getTypeUrl
         * @memberof bag.c2s_composite_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_composite_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_composite_item";
        };

        return c2s_composite_item;
    })();

    bag.s2c_composite_item = (function() {

        /**
         * Properties of a s2c_composite_item.
         * @memberof bag
         * @interface Is2c_composite_item
         * @property {number|null} [err] s2c_composite_item err
         */

        /**
         * Constructs a new s2c_composite_item.
         * @memberof bag
         * @classdesc Represents a s2c_composite_item.
         * @implements Is2c_composite_item
         * @constructor
         * @param {bag.Is2c_composite_item=} [properties] Properties to set
         */
        function s2c_composite_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_composite_item err.
         * @member {number} err
         * @memberof bag.s2c_composite_item
         * @instance
         */
        s2c_composite_item.prototype.err = 0;

        /**
         * Creates a new s2c_composite_item instance using the specified properties.
         * @function create
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.Is2c_composite_item=} [properties] Properties to set
         * @returns {bag.s2c_composite_item} s2c_composite_item instance
         */
        s2c_composite_item.create = function create(properties) {
            return new s2c_composite_item(properties);
        };

        /**
         * Encodes the specified s2c_composite_item message. Does not implicitly {@link bag.s2c_composite_item.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.Is2c_composite_item} message s2c_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_composite_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_composite_item message, length delimited. Does not implicitly {@link bag.s2c_composite_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.Is2c_composite_item} message s2c_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_composite_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_composite_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_composite_item} s2c_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_composite_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_composite_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_composite_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_composite_item} s2c_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_composite_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_composite_item message.
         * @function verify
         * @memberof bag.s2c_composite_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_composite_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_composite_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_composite_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_composite_item} s2c_composite_item
         */
        s2c_composite_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_composite_item)
                return object;
            var message = new $root.bag.s2c_composite_item();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_composite_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.s2c_composite_item} message s2c_composite_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_composite_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_composite_item to JSON.
         * @function toJSON
         * @memberof bag.s2c_composite_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_composite_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_composite_item
         * @function getTypeUrl
         * @memberof bag.s2c_composite_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_composite_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_composite_item";
        };

        return s2c_composite_item;
    })();

    bag.c2s_discard_item = (function() {

        /**
         * Properties of a c2s_discard_item.
         * @memberof bag
         * @interface Ic2s_discard_item
         * @property {number|null} [itemId] c2s_discard_item itemId
         * @property {number|null} [itemUid] c2s_discard_item itemUid
         */

        /**
         * Constructs a new c2s_discard_item.
         * @memberof bag
         * @classdesc Represents a c2s_discard_item.
         * @implements Ic2s_discard_item
         * @constructor
         * @param {bag.Ic2s_discard_item=} [properties] Properties to set
         */
        function c2s_discard_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_discard_item itemId.
         * @member {number} itemId
         * @memberof bag.c2s_discard_item
         * @instance
         */
        c2s_discard_item.prototype.itemId = 0;

        /**
         * c2s_discard_item itemUid.
         * @member {number} itemUid
         * @memberof bag.c2s_discard_item
         * @instance
         */
        c2s_discard_item.prototype.itemUid = 0;

        /**
         * Creates a new c2s_discard_item instance using the specified properties.
         * @function create
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.Ic2s_discard_item=} [properties] Properties to set
         * @returns {bag.c2s_discard_item} c2s_discard_item instance
         */
        c2s_discard_item.create = function create(properties) {
            return new c2s_discard_item(properties);
        };

        /**
         * Encodes the specified c2s_discard_item message. Does not implicitly {@link bag.c2s_discard_item.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.Ic2s_discard_item} message c2s_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_discard_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemId);
            if (message.itemUid != null && Object.hasOwnProperty.call(message, "itemUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.itemUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_discard_item message, length delimited. Does not implicitly {@link bag.c2s_discard_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.Ic2s_discard_item} message c2s_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_discard_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_discard_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_discard_item} c2s_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_discard_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_discard_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.itemUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_discard_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_discard_item} c2s_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_discard_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_discard_item message.
         * @function verify
         * @memberof bag.c2s_discard_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_discard_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.itemUid != null && message.hasOwnProperty("itemUid"))
                if (!$util.isInteger(message.itemUid))
                    return "itemUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_discard_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_discard_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_discard_item} c2s_discard_item
         */
        c2s_discard_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_discard_item)
                return object;
            var message = new $root.bag.c2s_discard_item();
            if (object.itemId != null)
                message.itemId = object.itemId >>> 0;
            if (object.itemUid != null)
                message.itemUid = object.itemUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_discard_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.c2s_discard_item} message c2s_discard_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_discard_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.itemUid = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.itemUid != null && message.hasOwnProperty("itemUid"))
                object.itemUid = message.itemUid;
            return object;
        };

        /**
         * Converts this c2s_discard_item to JSON.
         * @function toJSON
         * @memberof bag.c2s_discard_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_discard_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_discard_item
         * @function getTypeUrl
         * @memberof bag.c2s_discard_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_discard_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_discard_item";
        };

        return c2s_discard_item;
    })();

    bag.s2c_discard_item = (function() {

        /**
         * Properties of a s2c_discard_item.
         * @memberof bag
         * @interface Is2c_discard_item
         * @property {number|null} [err] s2c_discard_item err
         */

        /**
         * Constructs a new s2c_discard_item.
         * @memberof bag
         * @classdesc Represents a s2c_discard_item.
         * @implements Is2c_discard_item
         * @constructor
         * @param {bag.Is2c_discard_item=} [properties] Properties to set
         */
        function s2c_discard_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_discard_item err.
         * @member {number} err
         * @memberof bag.s2c_discard_item
         * @instance
         */
        s2c_discard_item.prototype.err = 0;

        /**
         * Creates a new s2c_discard_item instance using the specified properties.
         * @function create
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.Is2c_discard_item=} [properties] Properties to set
         * @returns {bag.s2c_discard_item} s2c_discard_item instance
         */
        s2c_discard_item.create = function create(properties) {
            return new s2c_discard_item(properties);
        };

        /**
         * Encodes the specified s2c_discard_item message. Does not implicitly {@link bag.s2c_discard_item.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.Is2c_discard_item} message s2c_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_discard_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_discard_item message, length delimited. Does not implicitly {@link bag.s2c_discard_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.Is2c_discard_item} message s2c_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_discard_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_discard_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_discard_item} s2c_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_discard_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_discard_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_discard_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_discard_item} s2c_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_discard_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_discard_item message.
         * @function verify
         * @memberof bag.s2c_discard_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_discard_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_discard_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_discard_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_discard_item} s2c_discard_item
         */
        s2c_discard_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_discard_item)
                return object;
            var message = new $root.bag.s2c_discard_item();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_discard_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.s2c_discard_item} message s2c_discard_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_discard_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_discard_item to JSON.
         * @function toJSON
         * @memberof bag.s2c_discard_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_discard_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_discard_item
         * @function getTypeUrl
         * @memberof bag.s2c_discard_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_discard_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_discard_item";
        };

        return s2c_discard_item;
    })();

    bag.notify_items = (function() {

        /**
         * Properties of a notify_items.
         * @memberof bag
         * @interface Inotify_items
         * @property {Array.<bag.IItem>|null} [items] notify_items items
         */

        /**
         * Constructs a new notify_items.
         * @memberof bag
         * @classdesc Represents a notify_items.
         * @implements Inotify_items
         * @constructor
         * @param {bag.Inotify_items=} [properties] Properties to set
         */
        function notify_items(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_items items.
         * @member {Array.<bag.IItem>} items
         * @memberof bag.notify_items
         * @instance
         */
        notify_items.prototype.items = $util.emptyArray;

        /**
         * Creates a new notify_items instance using the specified properties.
         * @function create
         * @memberof bag.notify_items
         * @static
         * @param {bag.Inotify_items=} [properties] Properties to set
         * @returns {bag.notify_items} notify_items instance
         */
        notify_items.create = function create(properties) {
            return new notify_items(properties);
        };

        /**
         * Encodes the specified notify_items message. Does not implicitly {@link bag.notify_items.verify|verify} messages.
         * @function encode
         * @memberof bag.notify_items
         * @static
         * @param {bag.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.bag.Item.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_items message, length delimited. Does not implicitly {@link bag.notify_items.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.notify_items
         * @static
         * @param {bag.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer.
         * @function decode
         * @memberof bag.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.notify_items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_items message.
         * @function verify
         * @memberof bag.notify_items
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.bag.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_items message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.notify_items
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.notify_items} notify_items
         */
        notify_items.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.notify_items)
                return object;
            var message = new $root.bag.notify_items();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".bag.notify_items.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".bag.notify_items.items: object expected");
                    message.items[i] = $root.bag.Item.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_items message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.notify_items
         * @static
         * @param {bag.notify_items} message notify_items
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.bag.Item.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_items to JSON.
         * @function toJSON
         * @memberof bag.notify_items
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_items
         * @function getTypeUrl
         * @memberof bag.notify_items
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.notify_items";
        };

        return notify_items;
    })();

    return bag;
})();

$root.battle = (function() {

    /**
     * Namespace battle.
     * @exports battle
     * @namespace
     */
    var battle = {};

    battle.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof battle
         * @interface IPosition
         * @property {number|null} [x] Position x
         * @property {number|null} [y] Position y
         */

        /**
         * Constructs a new Position.
         * @memberof battle
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {battle.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position x.
         * @member {number} x
         * @memberof battle.Position
         * @instance
         */
        Position.prototype.x = 0;

        /**
         * Position y.
         * @member {number} y
         * @memberof battle.Position
         * @instance
         */
        Position.prototype.y = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof battle.Position
         * @static
         * @param {battle.IPosition=} [properties] Properties to set
         * @returns {battle.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link battle.Position.verify|verify} messages.
         * @function encode
         * @memberof battle.Position
         * @static
         * @param {battle.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link battle.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.Position
         * @static
         * @param {battle.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof battle.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.Position();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof battle.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.Position)
                return object;
            var message = new $root.battle.Position();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.Position
         * @static
         * @param {battle.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof battle.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof battle.Position
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.Position";
        };

        return Position;
    })();

    battle.BattleHero = (function() {

        /**
         * Properties of a BattleHero.
         * @memberof battle
         * @interface IBattleHero
         * @property {number|null} [heroId] BattleHero heroId
         * @property {number|null} [eid] BattleHero eid
         */

        /**
         * Constructs a new BattleHero.
         * @memberof battle
         * @classdesc Represents a BattleHero.
         * @implements IBattleHero
         * @constructor
         * @param {battle.IBattleHero=} [properties] Properties to set
         */
        function BattleHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleHero heroId.
         * @member {number} heroId
         * @memberof battle.BattleHero
         * @instance
         */
        BattleHero.prototype.heroId = 0;

        /**
         * BattleHero eid.
         * @member {number} eid
         * @memberof battle.BattleHero
         * @instance
         */
        BattleHero.prototype.eid = 0;

        /**
         * Creates a new BattleHero instance using the specified properties.
         * @function create
         * @memberof battle.BattleHero
         * @static
         * @param {battle.IBattleHero=} [properties] Properties to set
         * @returns {battle.BattleHero} BattleHero instance
         */
        BattleHero.create = function create(properties) {
            return new BattleHero(properties);
        };

        /**
         * Encodes the specified BattleHero message. Does not implicitly {@link battle.BattleHero.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleHero
         * @static
         * @param {battle.IBattleHero} message BattleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.heroId);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified BattleHero message, length delimited. Does not implicitly {@link battle.BattleHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleHero
         * @static
         * @param {battle.IBattleHero} message BattleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleHero message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleHero} BattleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.heroId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleHero} BattleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleHero message.
         * @function verify
         * @memberof battle.BattleHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a BattleHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleHero} BattleHero
         */
        BattleHero.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleHero)
                return object;
            var message = new $root.battle.BattleHero();
            if (object.heroId != null)
                message.heroId = object.heroId >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BattleHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleHero
         * @static
         * @param {battle.BattleHero} message BattleHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleHero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroId = 0;
                object.eid = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this BattleHero to JSON.
         * @function toJSON
         * @memberof battle.BattleHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleHero
         * @function getTypeUrl
         * @memberof battle.BattleHero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleHero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleHero";
        };

        return BattleHero;
    })();

    battle.BattleRole = (function() {

        /**
         * Properties of a BattleRole.
         * @memberof battle
         * @interface IBattleRole
         * @property {number|Long|null} [rid] BattleRole rid
         * @property {string|null} [name] BattleRole name
         * @property {Array.<battle.IBattleHero>|null} [heros] BattleRole heros
         */

        /**
         * Constructs a new BattleRole.
         * @memberof battle
         * @classdesc Represents a BattleRole.
         * @implements IBattleRole
         * @constructor
         * @param {battle.IBattleRole=} [properties] Properties to set
         */
        function BattleRole(properties) {
            this.heros = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleRole rid.
         * @member {number|Long} rid
         * @memberof battle.BattleRole
         * @instance
         */
        BattleRole.prototype.rid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BattleRole name.
         * @member {string} name
         * @memberof battle.BattleRole
         * @instance
         */
        BattleRole.prototype.name = "";

        /**
         * BattleRole heros.
         * @member {Array.<battle.IBattleHero>} heros
         * @memberof battle.BattleRole
         * @instance
         */
        BattleRole.prototype.heros = $util.emptyArray;

        /**
         * Creates a new BattleRole instance using the specified properties.
         * @function create
         * @memberof battle.BattleRole
         * @static
         * @param {battle.IBattleRole=} [properties] Properties to set
         * @returns {battle.BattleRole} BattleRole instance
         */
        BattleRole.create = function create(properties) {
            return new BattleRole(properties);
        };

        /**
         * Encodes the specified BattleRole message. Does not implicitly {@link battle.BattleRole.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleRole
         * @static
         * @param {battle.IBattleRole} message BattleRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleRole.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.heros != null && message.heros.length)
                for (var i = 0; i < message.heros.length; ++i)
                    $root.battle.BattleHero.encode(message.heros[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BattleRole message, length delimited. Does not implicitly {@link battle.BattleRole.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleRole
         * @static
         * @param {battle.IBattleRole} message BattleRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleRole.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleRole message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleRole} BattleRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleRole.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleRole();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.int64();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.heros && message.heros.length))
                            message.heros = [];
                        message.heros.push($root.battle.BattleHero.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleRole message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleRole} BattleRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleRole.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleRole message.
         * @function verify
         * @memberof battle.BattleRole
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleRole.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid) && !(message.rid && $util.isInteger(message.rid.low) && $util.isInteger(message.rid.high)))
                    return "rid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.heros != null && message.hasOwnProperty("heros")) {
                if (!Array.isArray(message.heros))
                    return "heros: array expected";
                for (var i = 0; i < message.heros.length; ++i) {
                    var error = $root.battle.BattleHero.verify(message.heros[i]);
                    if (error)
                        return "heros." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BattleRole message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleRole
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleRole} BattleRole
         */
        BattleRole.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleRole)
                return object;
            var message = new $root.battle.BattleRole();
            if (object.rid != null)
                if ($util.Long)
                    (message.rid = $util.Long.fromValue(object.rid)).unsigned = false;
                else if (typeof object.rid === "string")
                    message.rid = parseInt(object.rid, 10);
                else if (typeof object.rid === "number")
                    message.rid = object.rid;
                else if (typeof object.rid === "object")
                    message.rid = new $util.LongBits(object.rid.low >>> 0, object.rid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.heros) {
                if (!Array.isArray(object.heros))
                    throw TypeError(".battle.BattleRole.heros: array expected");
                message.heros = [];
                for (var i = 0; i < object.heros.length; ++i) {
                    if (typeof object.heros[i] !== "object")
                        throw TypeError(".battle.BattleRole.heros: object expected");
                    message.heros[i] = $root.battle.BattleHero.fromObject(object.heros[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BattleRole message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleRole
         * @static
         * @param {battle.BattleRole} message BattleRole
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleRole.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heros = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rid = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (typeof message.rid === "number")
                    object.rid = options.longs === String ? String(message.rid) : message.rid;
                else
                    object.rid = options.longs === String ? $util.Long.prototype.toString.call(message.rid) : options.longs === Number ? new $util.LongBits(message.rid.low >>> 0, message.rid.high >>> 0).toNumber() : message.rid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.heros && message.heros.length) {
                object.heros = [];
                for (var j = 0; j < message.heros.length; ++j)
                    object.heros[j] = $root.battle.BattleHero.toObject(message.heros[j], options);
            }
            return object;
        };

        /**
         * Converts this BattleRole to JSON.
         * @function toJSON
         * @memberof battle.BattleRole
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleRole.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleRole
         * @function getTypeUrl
         * @memberof battle.BattleRole
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleRole.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleRole";
        };

        return BattleRole;
    })();

    battle.cmd_add_entity = (function() {

        /**
         * Properties of a cmd_add_entity.
         * @memberof battle
         * @interface Icmd_add_entity
         * @property {number|null} [eid] cmd_add_entity eid
         * @property {number|Long|null} [rid] cmd_add_entity rid
         * @property {number|null} [entityId] cmd_add_entity entityId
         * @property {number|null} [maxHp] cmd_add_entity maxHp
         * @property {number|null} [hp] cmd_add_entity hp
         * @property {number|null} [face] cmd_add_entity face
         * @property {battle.IPosition|null} [pos] cmd_add_entity pos
         * @property {number|null} [maxMp] cmd_add_entity maxMp
         * @property {number|null} [mp] cmd_add_entity mp
         */

        /**
         * Constructs a new cmd_add_entity.
         * @memberof battle
         * @classdesc Represents a cmd_add_entity.
         * @implements Icmd_add_entity
         * @constructor
         * @param {battle.Icmd_add_entity=} [properties] Properties to set
         */
        function cmd_add_entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_add_entity eid.
         * @member {number} eid
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.eid = 0;

        /**
         * cmd_add_entity rid.
         * @member {number|Long} rid
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.rid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * cmd_add_entity entityId.
         * @member {number} entityId
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.entityId = 0;

        /**
         * cmd_add_entity maxHp.
         * @member {number} maxHp
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.maxHp = 0;

        /**
         * cmd_add_entity hp.
         * @member {number} hp
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.hp = 0;

        /**
         * cmd_add_entity face.
         * @member {number} face
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.face = 0;

        /**
         * cmd_add_entity pos.
         * @member {battle.IPosition|null|undefined} pos
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.pos = null;

        /**
         * cmd_add_entity maxMp.
         * @member {number} maxMp
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.maxMp = 0;

        /**
         * cmd_add_entity mp.
         * @member {number} mp
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.mp = 0;

        /**
         * Creates a new cmd_add_entity instance using the specified properties.
         * @function create
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.Icmd_add_entity=} [properties] Properties to set
         * @returns {battle.cmd_add_entity} cmd_add_entity instance
         */
        cmd_add_entity.create = function create(properties) {
            return new cmd_add_entity(properties);
        };

        /**
         * Encodes the specified cmd_add_entity message. Does not implicitly {@link battle.cmd_add_entity.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.Icmd_add_entity} message cmd_add_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.rid);
            if (message.entityId != null && Object.hasOwnProperty.call(message, "entityId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entityId);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxHp);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.hp);
            if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.face);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.battle.Position.encode(message.pos, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.maxMp != null && Object.hasOwnProperty.call(message, "maxMp"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.maxMp);
            if (message.mp != null && Object.hasOwnProperty.call(message, "mp"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.mp);
            return writer;
        };

        /**
         * Encodes the specified cmd_add_entity message, length delimited. Does not implicitly {@link battle.cmd_add_entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.Icmd_add_entity} message cmd_add_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_add_entity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_add_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_add_entity} cmd_add_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_add_entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.rid = reader.int64();
                        break;
                    }
                case 3: {
                        message.entityId = reader.uint32();
                        break;
                    }
                case 5: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 6: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 7: {
                        message.face = reader.int32();
                        break;
                    }
                case 8: {
                        message.pos = $root.battle.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.maxMp = reader.uint32();
                        break;
                    }
                case 14: {
                        message.mp = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_add_entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_add_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_add_entity} cmd_add_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_add_entity message.
         * @function verify
         * @memberof battle.cmd_add_entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_add_entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid) && !(message.rid && $util.isInteger(message.rid.low) && $util.isInteger(message.rid.high)))
                    return "rid: integer|Long expected";
            if (message.entityId != null && message.hasOwnProperty("entityId"))
                if (!$util.isInteger(message.entityId))
                    return "entityId: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.face != null && message.hasOwnProperty("face"))
                if (!$util.isInteger(message.face))
                    return "face: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.battle.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.maxMp != null && message.hasOwnProperty("maxMp"))
                if (!$util.isInteger(message.maxMp))
                    return "maxMp: integer expected";
            if (message.mp != null && message.hasOwnProperty("mp"))
                if (!$util.isInteger(message.mp))
                    return "mp: integer expected";
            return null;
        };

        /**
         * Creates a cmd_add_entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_add_entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_add_entity} cmd_add_entity
         */
        cmd_add_entity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_add_entity)
                return object;
            var message = new $root.battle.cmd_add_entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.rid != null)
                if ($util.Long)
                    (message.rid = $util.Long.fromValue(object.rid)).unsigned = false;
                else if (typeof object.rid === "string")
                    message.rid = parseInt(object.rid, 10);
                else if (typeof object.rid === "number")
                    message.rid = object.rid;
                else if (typeof object.rid === "object")
                    message.rid = new $util.LongBits(object.rid.low >>> 0, object.rid.high >>> 0).toNumber();
            if (object.entityId != null)
                message.entityId = object.entityId >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.face != null)
                message.face = object.face | 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".battle.cmd_add_entity.pos: object expected");
                message.pos = $root.battle.Position.fromObject(object.pos);
            }
            if (object.maxMp != null)
                message.maxMp = object.maxMp >>> 0;
            if (object.mp != null)
                message.mp = object.mp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_add_entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.cmd_add_entity} message cmd_add_entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_add_entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rid = options.longs === String ? "0" : 0;
                object.entityId = 0;
                object.maxHp = 0;
                object.hp = 0;
                object.face = 0;
                object.pos = null;
                object.maxMp = 0;
                object.mp = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (typeof message.rid === "number")
                    object.rid = options.longs === String ? String(message.rid) : message.rid;
                else
                    object.rid = options.longs === String ? $util.Long.prototype.toString.call(message.rid) : options.longs === Number ? new $util.LongBits(message.rid.low >>> 0, message.rid.high >>> 0).toNumber() : message.rid;
            if (message.entityId != null && message.hasOwnProperty("entityId"))
                object.entityId = message.entityId;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.face != null && message.hasOwnProperty("face"))
                object.face = message.face;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.battle.Position.toObject(message.pos, options);
            if (message.maxMp != null && message.hasOwnProperty("maxMp"))
                object.maxMp = message.maxMp;
            if (message.mp != null && message.hasOwnProperty("mp"))
                object.mp = message.mp;
            return object;
        };

        /**
         * Converts this cmd_add_entity to JSON.
         * @function toJSON
         * @memberof battle.cmd_add_entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_add_entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_add_entity
         * @function getTypeUrl
         * @memberof battle.cmd_add_entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_add_entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_add_entity";
        };

        return cmd_add_entity;
    })();

    battle.cmd_update_entity = (function() {

        /**
         * Properties of a cmd_update_entity.
         * @memberof battle
         * @interface Icmd_update_entity
         * @property {number|null} [eid] cmd_update_entity eid
         * @property {number|null} [maxHp] cmd_update_entity maxHp
         * @property {number|null} [hp] cmd_update_entity hp
         * @property {battle.IPosition|null} [pos] cmd_update_entity pos
         */

        /**
         * Constructs a new cmd_update_entity.
         * @memberof battle
         * @classdesc Represents a cmd_update_entity.
         * @implements Icmd_update_entity
         * @constructor
         * @param {battle.Icmd_update_entity=} [properties] Properties to set
         */
        function cmd_update_entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_update_entity eid.
         * @member {number} eid
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.eid = 0;

        /**
         * cmd_update_entity maxHp.
         * @member {number} maxHp
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.maxHp = 0;

        /**
         * cmd_update_entity hp.
         * @member {number} hp
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.hp = 0;

        /**
         * cmd_update_entity pos.
         * @member {battle.IPosition|null|undefined} pos
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.pos = null;

        /**
         * Creates a new cmd_update_entity instance using the specified properties.
         * @function create
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.Icmd_update_entity=} [properties] Properties to set
         * @returns {battle.cmd_update_entity} cmd_update_entity instance
         */
        cmd_update_entity.create = function create(properties) {
            return new cmd_update_entity(properties);
        };

        /**
         * Encodes the specified cmd_update_entity message. Does not implicitly {@link battle.cmd_update_entity.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.Icmd_update_entity} message cmd_update_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_update_entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxHp);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hp);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.battle.Position.encode(message.pos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified cmd_update_entity message, length delimited. Does not implicitly {@link battle.cmd_update_entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.Icmd_update_entity} message cmd_update_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_update_entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_update_entity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_update_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_update_entity} cmd_update_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_update_entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_update_entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 5: {
                        message.pos = $root.battle.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_update_entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_update_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_update_entity} cmd_update_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_update_entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_update_entity message.
         * @function verify
         * @memberof battle.cmd_update_entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_update_entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.battle.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a cmd_update_entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_update_entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_update_entity} cmd_update_entity
         */
        cmd_update_entity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_update_entity)
                return object;
            var message = new $root.battle.cmd_update_entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".battle.cmd_update_entity.pos: object expected");
                message.pos = $root.battle.Position.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a cmd_update_entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.cmd_update_entity} message cmd_update_entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_update_entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.maxHp = 0;
                object.hp = 0;
                object.pos = null;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.battle.Position.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this cmd_update_entity to JSON.
         * @function toJSON
         * @memberof battle.cmd_update_entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_update_entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_update_entity
         * @function getTypeUrl
         * @memberof battle.cmd_update_entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_update_entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_update_entity";
        };

        return cmd_update_entity;
    })();

    battle.cmd_del_entity = (function() {

        /**
         * Properties of a cmd_del_entity.
         * @memberof battle
         * @interface Icmd_del_entity
         * @property {number|null} [eid] cmd_del_entity eid
         */

        /**
         * Constructs a new cmd_del_entity.
         * @memberof battle
         * @classdesc Represents a cmd_del_entity.
         * @implements Icmd_del_entity
         * @constructor
         * @param {battle.Icmd_del_entity=} [properties] Properties to set
         */
        function cmd_del_entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_del_entity eid.
         * @member {number} eid
         * @memberof battle.cmd_del_entity
         * @instance
         */
        cmd_del_entity.prototype.eid = 0;

        /**
         * Creates a new cmd_del_entity instance using the specified properties.
         * @function create
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.Icmd_del_entity=} [properties] Properties to set
         * @returns {battle.cmd_del_entity} cmd_del_entity instance
         */
        cmd_del_entity.create = function create(properties) {
            return new cmd_del_entity(properties);
        };

        /**
         * Encodes the specified cmd_del_entity message. Does not implicitly {@link battle.cmd_del_entity.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.Icmd_del_entity} message cmd_del_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified cmd_del_entity message, length delimited. Does not implicitly {@link battle.cmd_del_entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.Icmd_del_entity} message cmd_del_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_del_entity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_del_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_del_entity} cmd_del_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_del_entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_del_entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_del_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_del_entity} cmd_del_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_del_entity message.
         * @function verify
         * @memberof battle.cmd_del_entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_del_entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a cmd_del_entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_del_entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_del_entity} cmd_del_entity
         */
        cmd_del_entity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_del_entity)
                return object;
            var message = new $root.battle.cmd_del_entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_del_entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.cmd_del_entity} message cmd_del_entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_del_entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this cmd_del_entity to JSON.
         * @function toJSON
         * @memberof battle.cmd_del_entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_del_entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_del_entity
         * @function getTypeUrl
         * @memberof battle.cmd_del_entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_del_entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_del_entity";
        };

        return cmd_del_entity;
    })();

    battle.cmd_move_to = (function() {

        /**
         * Properties of a cmd_move_to.
         * @memberof battle
         * @interface Icmd_move_to
         * @property {number|null} [eid] cmd_move_to eid
         * @property {number|null} [speed] cmd_move_to speed
         * @property {battle.IPosition|null} [targetPos] cmd_move_to targetPos
         */

        /**
         * Constructs a new cmd_move_to.
         * @memberof battle
         * @classdesc Represents a cmd_move_to.
         * @implements Icmd_move_to
         * @constructor
         * @param {battle.Icmd_move_to=} [properties] Properties to set
         */
        function cmd_move_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_move_to eid.
         * @member {number} eid
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.eid = 0;

        /**
         * cmd_move_to speed.
         * @member {number} speed
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.speed = 0;

        /**
         * cmd_move_to targetPos.
         * @member {battle.IPosition|null|undefined} targetPos
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.targetPos = null;

        /**
         * Creates a new cmd_move_to instance using the specified properties.
         * @function create
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.Icmd_move_to=} [properties] Properties to set
         * @returns {battle.cmd_move_to} cmd_move_to instance
         */
        cmd_move_to.create = function create(properties) {
            return new cmd_move_to(properties);
        };

        /**
         * Encodes the specified cmd_move_to message. Does not implicitly {@link battle.cmd_move_to.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.Icmd_move_to} message cmd_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.speed);
            if (message.targetPos != null && Object.hasOwnProperty.call(message, "targetPos"))
                $root.battle.Position.encode(message.targetPos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified cmd_move_to message, length delimited. Does not implicitly {@link battle.cmd_move_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.Icmd_move_to} message cmd_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_move_to message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_move_to} cmd_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_move_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 3: {
                        message.targetPos = $root.battle.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_move_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_move_to} cmd_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_move_to message.
         * @function verify
         * @memberof battle.cmd_move_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_move_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.targetPos != null && message.hasOwnProperty("targetPos")) {
                var error = $root.battle.Position.verify(message.targetPos);
                if (error)
                    return "targetPos." + error;
            }
            return null;
        };

        /**
         * Creates a cmd_move_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_move_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_move_to} cmd_move_to
         */
        cmd_move_to.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_move_to)
                return object;
            var message = new $root.battle.cmd_move_to();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.targetPos != null) {
                if (typeof object.targetPos !== "object")
                    throw TypeError(".battle.cmd_move_to.targetPos: object expected");
                message.targetPos = $root.battle.Position.fromObject(object.targetPos);
            }
            return message;
        };

        /**
         * Creates a plain object from a cmd_move_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.cmd_move_to} message cmd_move_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_move_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.targetPos = null;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.targetPos != null && message.hasOwnProperty("targetPos"))
                object.targetPos = $root.battle.Position.toObject(message.targetPos, options);
            return object;
        };

        /**
         * Converts this cmd_move_to to JSON.
         * @function toJSON
         * @memberof battle.cmd_move_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_move_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_move_to
         * @function getTypeUrl
         * @memberof battle.cmd_move_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_move_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_move_to";
        };

        return cmd_move_to;
    })();

    battle.cmd_force_to = (function() {

        /**
         * Properties of a cmd_force_to.
         * @memberof battle
         * @interface Icmd_force_to
         * @property {number|null} [eid] cmd_force_to eid
         * @property {number|null} [speed] cmd_force_to speed
         * @property {battle.IPosition|null} [targetPos] cmd_force_to targetPos
         */

        /**
         * Constructs a new cmd_force_to.
         * @memberof battle
         * @classdesc Represents a cmd_force_to.
         * @implements Icmd_force_to
         * @constructor
         * @param {battle.Icmd_force_to=} [properties] Properties to set
         */
        function cmd_force_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_force_to eid.
         * @member {number} eid
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.eid = 0;

        /**
         * cmd_force_to speed.
         * @member {number} speed
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.speed = 0;

        /**
         * cmd_force_to targetPos.
         * @member {battle.IPosition|null|undefined} targetPos
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.targetPos = null;

        /**
         * Creates a new cmd_force_to instance using the specified properties.
         * @function create
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.Icmd_force_to=} [properties] Properties to set
         * @returns {battle.cmd_force_to} cmd_force_to instance
         */
        cmd_force_to.create = function create(properties) {
            return new cmd_force_to(properties);
        };

        /**
         * Encodes the specified cmd_force_to message. Does not implicitly {@link battle.cmd_force_to.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.Icmd_force_to} message cmd_force_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_force_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.speed);
            if (message.targetPos != null && Object.hasOwnProperty.call(message, "targetPos"))
                $root.battle.Position.encode(message.targetPos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified cmd_force_to message, length delimited. Does not implicitly {@link battle.cmd_force_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.Icmd_force_to} message cmd_force_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_force_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_force_to message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_force_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_force_to} cmd_force_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_force_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_force_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 3: {
                        message.targetPos = $root.battle.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_force_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_force_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_force_to} cmd_force_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_force_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_force_to message.
         * @function verify
         * @memberof battle.cmd_force_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_force_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.targetPos != null && message.hasOwnProperty("targetPos")) {
                var error = $root.battle.Position.verify(message.targetPos);
                if (error)
                    return "targetPos." + error;
            }
            return null;
        };

        /**
         * Creates a cmd_force_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_force_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_force_to} cmd_force_to
         */
        cmd_force_to.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_force_to)
                return object;
            var message = new $root.battle.cmd_force_to();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.targetPos != null) {
                if (typeof object.targetPos !== "object")
                    throw TypeError(".battle.cmd_force_to.targetPos: object expected");
                message.targetPos = $root.battle.Position.fromObject(object.targetPos);
            }
            return message;
        };

        /**
         * Creates a plain object from a cmd_force_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.cmd_force_to} message cmd_force_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_force_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.targetPos = null;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.targetPos != null && message.hasOwnProperty("targetPos"))
                object.targetPos = $root.battle.Position.toObject(message.targetPos, options);
            return object;
        };

        /**
         * Converts this cmd_force_to to JSON.
         * @function toJSON
         * @memberof battle.cmd_force_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_force_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_force_to
         * @function getTypeUrl
         * @memberof battle.cmd_force_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_force_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_force_to";
        };

        return cmd_force_to;
    })();

    battle.cmd_move_start = (function() {

        /**
         * Properties of a cmd_move_start.
         * @memberof battle
         * @interface Icmd_move_start
         * @property {number|null} [eid] cmd_move_start eid
         * @property {number|null} [speed] cmd_move_start speed
         * @property {number|null} [dir] cmd_move_start dir
         */

        /**
         * Constructs a new cmd_move_start.
         * @memberof battle
         * @classdesc Represents a cmd_move_start.
         * @implements Icmd_move_start
         * @constructor
         * @param {battle.Icmd_move_start=} [properties] Properties to set
         */
        function cmd_move_start(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_move_start eid.
         * @member {number} eid
         * @memberof battle.cmd_move_start
         * @instance
         */
        cmd_move_start.prototype.eid = 0;

        /**
         * cmd_move_start speed.
         * @member {number} speed
         * @memberof battle.cmd_move_start
         * @instance
         */
        cmd_move_start.prototype.speed = 0;

        /**
         * cmd_move_start dir.
         * @member {number} dir
         * @memberof battle.cmd_move_start
         * @instance
         */
        cmd_move_start.prototype.dir = 0;

        /**
         * Creates a new cmd_move_start instance using the specified properties.
         * @function create
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.Icmd_move_start=} [properties] Properties to set
         * @returns {battle.cmd_move_start} cmd_move_start instance
         */
        cmd_move_start.create = function create(properties) {
            return new cmd_move_start(properties);
        };

        /**
         * Encodes the specified cmd_move_start message. Does not implicitly {@link battle.cmd_move_start.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.Icmd_move_start} message cmd_move_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_start.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.speed);
            if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dir);
            return writer;
        };

        /**
         * Encodes the specified cmd_move_start message, length delimited. Does not implicitly {@link battle.cmd_move_start.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.Icmd_move_start} message cmd_move_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_start.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_move_start message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_move_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_move_start} cmd_move_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_start.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_move_start();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 3: {
                        message.dir = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_move_start message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_move_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_move_start} cmd_move_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_start.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_move_start message.
         * @function verify
         * @memberof battle.cmd_move_start
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_move_start.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.dir != null && message.hasOwnProperty("dir"))
                if (!$util.isInteger(message.dir))
                    return "dir: integer expected";
            return null;
        };

        /**
         * Creates a cmd_move_start message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_move_start
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_move_start} cmd_move_start
         */
        cmd_move_start.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_move_start)
                return object;
            var message = new $root.battle.cmd_move_start();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.dir != null)
                message.dir = object.dir >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_move_start message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.cmd_move_start} message cmd_move_start
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_move_start.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.dir = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.dir != null && message.hasOwnProperty("dir"))
                object.dir = message.dir;
            return object;
        };

        /**
         * Converts this cmd_move_start to JSON.
         * @function toJSON
         * @memberof battle.cmd_move_start
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_move_start.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_move_start
         * @function getTypeUrl
         * @memberof battle.cmd_move_start
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_move_start.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_move_start";
        };

        return cmd_move_start;
    })();

    battle.cmd_move_stop = (function() {

        /**
         * Properties of a cmd_move_stop.
         * @memberof battle
         * @interface Icmd_move_stop
         * @property {number|null} [eid] cmd_move_stop eid
         * @property {battle.IPosition|null} [pos] cmd_move_stop pos
         */

        /**
         * Constructs a new cmd_move_stop.
         * @memberof battle
         * @classdesc Represents a cmd_move_stop.
         * @implements Icmd_move_stop
         * @constructor
         * @param {battle.Icmd_move_stop=} [properties] Properties to set
         */
        function cmd_move_stop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_move_stop eid.
         * @member {number} eid
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.eid = 0;

        /**
         * cmd_move_stop pos.
         * @member {battle.IPosition|null|undefined} pos
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.pos = null;

        /**
         * Creates a new cmd_move_stop instance using the specified properties.
         * @function create
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.Icmd_move_stop=} [properties] Properties to set
         * @returns {battle.cmd_move_stop} cmd_move_stop instance
         */
        cmd_move_stop.create = function create(properties) {
            return new cmd_move_stop(properties);
        };

        /**
         * Encodes the specified cmd_move_stop message. Does not implicitly {@link battle.cmd_move_stop.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.Icmd_move_stop} message cmd_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_stop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.battle.Position.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified cmd_move_stop message, length delimited. Does not implicitly {@link battle.cmd_move_stop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.Icmd_move_stop} message cmd_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_stop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_move_stop message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_move_stop} cmd_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_stop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_move_stop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.pos = $root.battle.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_move_stop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_move_stop} cmd_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_stop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_move_stop message.
         * @function verify
         * @memberof battle.cmd_move_stop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_move_stop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.battle.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a cmd_move_stop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_move_stop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_move_stop} cmd_move_stop
         */
        cmd_move_stop.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_move_stop)
                return object;
            var message = new $root.battle.cmd_move_stop();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".battle.cmd_move_stop.pos: object expected");
                message.pos = $root.battle.Position.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a cmd_move_stop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.cmd_move_stop} message cmd_move_stop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_move_stop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.pos = null;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.battle.Position.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this cmd_move_stop to JSON.
         * @function toJSON
         * @memberof battle.cmd_move_stop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_move_stop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_move_stop
         * @function getTypeUrl
         * @memberof battle.cmd_move_stop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_move_stop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_move_stop";
        };

        return cmd_move_stop;
    })();

    battle.cmd_add_buff = (function() {

        /**
         * Properties of a cmd_add_buff.
         * @memberof battle
         * @interface Icmd_add_buff
         * @property {number|null} [eid] cmd_add_buff eid
         * @property {number|null} [id] cmd_add_buff id
         * @property {number|null} [stack] cmd_add_buff stack
         * @property {number|null} [expired] cmd_add_buff expired
         */

        /**
         * Constructs a new cmd_add_buff.
         * @memberof battle
         * @classdesc Represents a cmd_add_buff.
         * @implements Icmd_add_buff
         * @constructor
         * @param {battle.Icmd_add_buff=} [properties] Properties to set
         */
        function cmd_add_buff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_add_buff eid.
         * @member {number} eid
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.eid = 0;

        /**
         * cmd_add_buff id.
         * @member {number} id
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.id = 0;

        /**
         * cmd_add_buff stack.
         * @member {number} stack
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.stack = 0;

        /**
         * cmd_add_buff expired.
         * @member {number} expired
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.expired = 0;

        /**
         * Creates a new cmd_add_buff instance using the specified properties.
         * @function create
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.Icmd_add_buff=} [properties] Properties to set
         * @returns {battle.cmd_add_buff} cmd_add_buff instance
         */
        cmd_add_buff.create = function create(properties) {
            return new cmd_add_buff(properties);
        };

        /**
         * Encodes the specified cmd_add_buff message. Does not implicitly {@link battle.cmd_add_buff.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.Icmd_add_buff} message cmd_add_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_buff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            if (message.stack != null && Object.hasOwnProperty.call(message, "stack"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stack);
            if (message.expired != null && Object.hasOwnProperty.call(message, "expired"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expired);
            return writer;
        };

        /**
         * Encodes the specified cmd_add_buff message, length delimited. Does not implicitly {@link battle.cmd_add_buff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.Icmd_add_buff} message cmd_add_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_buff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_add_buff message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_add_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_add_buff} cmd_add_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_buff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_add_buff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                case 3: {
                        message.stack = reader.uint32();
                        break;
                    }
                case 4: {
                        message.expired = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_add_buff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_add_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_add_buff} cmd_add_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_buff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_add_buff message.
         * @function verify
         * @memberof battle.cmd_add_buff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_add_buff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.stack != null && message.hasOwnProperty("stack"))
                if (!$util.isInteger(message.stack))
                    return "stack: integer expected";
            if (message.expired != null && message.hasOwnProperty("expired"))
                if (!$util.isInteger(message.expired))
                    return "expired: integer expected";
            return null;
        };

        /**
         * Creates a cmd_add_buff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_add_buff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_add_buff} cmd_add_buff
         */
        cmd_add_buff.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_add_buff)
                return object;
            var message = new $root.battle.cmd_add_buff();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.stack != null)
                message.stack = object.stack >>> 0;
            if (object.expired != null)
                message.expired = object.expired >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_add_buff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.cmd_add_buff} message cmd_add_buff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_add_buff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.id = 0;
                object.stack = 0;
                object.expired = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.stack != null && message.hasOwnProperty("stack"))
                object.stack = message.stack;
            if (message.expired != null && message.hasOwnProperty("expired"))
                object.expired = message.expired;
            return object;
        };

        /**
         * Converts this cmd_add_buff to JSON.
         * @function toJSON
         * @memberof battle.cmd_add_buff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_add_buff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_add_buff
         * @function getTypeUrl
         * @memberof battle.cmd_add_buff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_add_buff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_add_buff";
        };

        return cmd_add_buff;
    })();

    battle.cmd_del_buff = (function() {

        /**
         * Properties of a cmd_del_buff.
         * @memberof battle
         * @interface Icmd_del_buff
         * @property {number|null} [eid] cmd_del_buff eid
         * @property {number|null} [id] cmd_del_buff id
         */

        /**
         * Constructs a new cmd_del_buff.
         * @memberof battle
         * @classdesc Represents a cmd_del_buff.
         * @implements Icmd_del_buff
         * @constructor
         * @param {battle.Icmd_del_buff=} [properties] Properties to set
         */
        function cmd_del_buff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_del_buff eid.
         * @member {number} eid
         * @memberof battle.cmd_del_buff
         * @instance
         */
        cmd_del_buff.prototype.eid = 0;

        /**
         * cmd_del_buff id.
         * @member {number} id
         * @memberof battle.cmd_del_buff
         * @instance
         */
        cmd_del_buff.prototype.id = 0;

        /**
         * Creates a new cmd_del_buff instance using the specified properties.
         * @function create
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.Icmd_del_buff=} [properties] Properties to set
         * @returns {battle.cmd_del_buff} cmd_del_buff instance
         */
        cmd_del_buff.create = function create(properties) {
            return new cmd_del_buff(properties);
        };

        /**
         * Encodes the specified cmd_del_buff message. Does not implicitly {@link battle.cmd_del_buff.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.Icmd_del_buff} message cmd_del_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_buff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified cmd_del_buff message, length delimited. Does not implicitly {@link battle.cmd_del_buff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.Icmd_del_buff} message cmd_del_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_buff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_del_buff message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_del_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_del_buff} cmd_del_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_buff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_del_buff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_del_buff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_del_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_del_buff} cmd_del_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_buff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_del_buff message.
         * @function verify
         * @memberof battle.cmd_del_buff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_del_buff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a cmd_del_buff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_del_buff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_del_buff} cmd_del_buff
         */
        cmd_del_buff.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_del_buff)
                return object;
            var message = new $root.battle.cmd_del_buff();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_del_buff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.cmd_del_buff} message cmd_del_buff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_del_buff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.id = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this cmd_del_buff to JSON.
         * @function toJSON
         * @memberof battle.cmd_del_buff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_del_buff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_del_buff
         * @function getTypeUrl
         * @memberof battle.cmd_del_buff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_del_buff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_del_buff";
        };

        return cmd_del_buff;
    })();

    battle.cmd_attack = (function() {

        /**
         * Properties of a cmd_attack.
         * @memberof battle
         * @interface Icmd_attack
         * @property {number|null} [eid] cmd_attack eid
         * @property {number|null} [skillId] cmd_attack skillId
         * @property {number|null} [curMp] cmd_attack curMp
         */

        /**
         * Constructs a new cmd_attack.
         * @memberof battle
         * @classdesc Represents a cmd_attack.
         * @implements Icmd_attack
         * @constructor
         * @param {battle.Icmd_attack=} [properties] Properties to set
         */
        function cmd_attack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_attack eid.
         * @member {number} eid
         * @memberof battle.cmd_attack
         * @instance
         */
        cmd_attack.prototype.eid = 0;

        /**
         * cmd_attack skillId.
         * @member {number} skillId
         * @memberof battle.cmd_attack
         * @instance
         */
        cmd_attack.prototype.skillId = 0;

        /**
         * cmd_attack curMp.
         * @member {number} curMp
         * @memberof battle.cmd_attack
         * @instance
         */
        cmd_attack.prototype.curMp = 0;

        /**
         * Creates a new cmd_attack instance using the specified properties.
         * @function create
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.Icmd_attack=} [properties] Properties to set
         * @returns {battle.cmd_attack} cmd_attack instance
         */
        cmd_attack.create = function create(properties) {
            return new cmd_attack(properties);
        };

        /**
         * Encodes the specified cmd_attack message. Does not implicitly {@link battle.cmd_attack.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.Icmd_attack} message cmd_attack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_attack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.skillId != null && Object.hasOwnProperty.call(message, "skillId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.skillId);
            if (message.curMp != null && Object.hasOwnProperty.call(message, "curMp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.curMp);
            return writer;
        };

        /**
         * Encodes the specified cmd_attack message, length delimited. Does not implicitly {@link battle.cmd_attack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.Icmd_attack} message cmd_attack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_attack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_attack message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_attack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_attack} cmd_attack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_attack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_attack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.skillId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.curMp = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_attack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_attack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_attack} cmd_attack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_attack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_attack message.
         * @function verify
         * @memberof battle.cmd_attack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_attack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                if (!$util.isInteger(message.skillId))
                    return "skillId: integer expected";
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                if (!$util.isInteger(message.curMp))
                    return "curMp: integer expected";
            return null;
        };

        /**
         * Creates a cmd_attack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_attack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_attack} cmd_attack
         */
        cmd_attack.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_attack)
                return object;
            var message = new $root.battle.cmd_attack();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.skillId != null)
                message.skillId = object.skillId >>> 0;
            if (object.curMp != null)
                message.curMp = object.curMp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_attack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.cmd_attack} message cmd_attack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_attack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.skillId = 0;
                object.curMp = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                object.skillId = message.skillId;
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                object.curMp = message.curMp;
            return object;
        };

        /**
         * Converts this cmd_attack to JSON.
         * @function toJSON
         * @memberof battle.cmd_attack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_attack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_attack
         * @function getTypeUrl
         * @memberof battle.cmd_attack
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_attack.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_attack";
        };

        return cmd_attack;
    })();

    battle.cmd_under_atk = (function() {

        /**
         * Properties of a cmd_under_atk.
         * @memberof battle
         * @interface Icmd_under_atk
         * @property {number|null} [eid] cmd_under_atk eid
         * @property {number|null} [skillId] cmd_under_atk skillId
         * @property {number|null} [subHp] cmd_under_atk subHp
         * @property {number|null} [curMp] cmd_under_atk curMp
         * @property {boolean|null} [critical] cmd_under_atk critical
         * @property {boolean|null} [dodge] cmd_under_atk dodge
         */

        /**
         * Constructs a new cmd_under_atk.
         * @memberof battle
         * @classdesc Represents a cmd_under_atk.
         * @implements Icmd_under_atk
         * @constructor
         * @param {battle.Icmd_under_atk=} [properties] Properties to set
         */
        function cmd_under_atk(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_under_atk eid.
         * @member {number} eid
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.eid = 0;

        /**
         * cmd_under_atk skillId.
         * @member {number} skillId
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.skillId = 0;

        /**
         * cmd_under_atk subHp.
         * @member {number} subHp
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.subHp = 0;

        /**
         * cmd_under_atk curMp.
         * @member {number} curMp
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.curMp = 0;

        /**
         * cmd_under_atk critical.
         * @member {boolean} critical
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.critical = false;

        /**
         * cmd_under_atk dodge.
         * @member {boolean} dodge
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.dodge = false;

        /**
         * Creates a new cmd_under_atk instance using the specified properties.
         * @function create
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.Icmd_under_atk=} [properties] Properties to set
         * @returns {battle.cmd_under_atk} cmd_under_atk instance
         */
        cmd_under_atk.create = function create(properties) {
            return new cmd_under_atk(properties);
        };

        /**
         * Encodes the specified cmd_under_atk message. Does not implicitly {@link battle.cmd_under_atk.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.Icmd_under_atk} message cmd_under_atk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_under_atk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.skillId != null && Object.hasOwnProperty.call(message, "skillId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.skillId);
            if (message.subHp != null && Object.hasOwnProperty.call(message, "subHp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.subHp);
            if (message.curMp != null && Object.hasOwnProperty.call(message, "curMp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.curMp);
            if (message.critical != null && Object.hasOwnProperty.call(message, "critical"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.critical);
            if (message.dodge != null && Object.hasOwnProperty.call(message, "dodge"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.dodge);
            return writer;
        };

        /**
         * Encodes the specified cmd_under_atk message, length delimited. Does not implicitly {@link battle.cmd_under_atk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.Icmd_under_atk} message cmd_under_atk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_under_atk.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_under_atk message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_under_atk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_under_atk} cmd_under_atk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_under_atk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_under_atk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.skillId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.subHp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.curMp = reader.uint32();
                        break;
                    }
                case 5: {
                        message.critical = reader.bool();
                        break;
                    }
                case 6: {
                        message.dodge = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_under_atk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_under_atk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_under_atk} cmd_under_atk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_under_atk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_under_atk message.
         * @function verify
         * @memberof battle.cmd_under_atk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_under_atk.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                if (!$util.isInteger(message.skillId))
                    return "skillId: integer expected";
            if (message.subHp != null && message.hasOwnProperty("subHp"))
                if (!$util.isInteger(message.subHp))
                    return "subHp: integer expected";
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                if (!$util.isInteger(message.curMp))
                    return "curMp: integer expected";
            if (message.critical != null && message.hasOwnProperty("critical"))
                if (typeof message.critical !== "boolean")
                    return "critical: boolean expected";
            if (message.dodge != null && message.hasOwnProperty("dodge"))
                if (typeof message.dodge !== "boolean")
                    return "dodge: boolean expected";
            return null;
        };

        /**
         * Creates a cmd_under_atk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_under_atk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_under_atk} cmd_under_atk
         */
        cmd_under_atk.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_under_atk)
                return object;
            var message = new $root.battle.cmd_under_atk();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.skillId != null)
                message.skillId = object.skillId >>> 0;
            if (object.subHp != null)
                message.subHp = object.subHp >>> 0;
            if (object.curMp != null)
                message.curMp = object.curMp >>> 0;
            if (object.critical != null)
                message.critical = Boolean(object.critical);
            if (object.dodge != null)
                message.dodge = Boolean(object.dodge);
            return message;
        };

        /**
         * Creates a plain object from a cmd_under_atk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.cmd_under_atk} message cmd_under_atk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_under_atk.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.skillId = 0;
                object.subHp = 0;
                object.curMp = 0;
                object.critical = false;
                object.dodge = false;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                object.skillId = message.skillId;
            if (message.subHp != null && message.hasOwnProperty("subHp"))
                object.subHp = message.subHp;
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                object.curMp = message.curMp;
            if (message.critical != null && message.hasOwnProperty("critical"))
                object.critical = message.critical;
            if (message.dodge != null && message.hasOwnProperty("dodge"))
                object.dodge = message.dodge;
            return object;
        };

        /**
         * Converts this cmd_under_atk to JSON.
         * @function toJSON
         * @memberof battle.cmd_under_atk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_under_atk.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_under_atk
         * @function getTypeUrl
         * @memberof battle.cmd_under_atk
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_under_atk.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_under_atk";
        };

        return cmd_under_atk;
    })();

    battle.cmd_recover_hp = (function() {

        /**
         * Properties of a cmd_recover_hp.
         * @memberof battle
         * @interface Icmd_recover_hp
         * @property {number|null} [eid] cmd_recover_hp eid
         * @property {number|null} [addHp] cmd_recover_hp addHp
         */

        /**
         * Constructs a new cmd_recover_hp.
         * @memberof battle
         * @classdesc Represents a cmd_recover_hp.
         * @implements Icmd_recover_hp
         * @constructor
         * @param {battle.Icmd_recover_hp=} [properties] Properties to set
         */
        function cmd_recover_hp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_recover_hp eid.
         * @member {number} eid
         * @memberof battle.cmd_recover_hp
         * @instance
         */
        cmd_recover_hp.prototype.eid = 0;

        /**
         * cmd_recover_hp addHp.
         * @member {number} addHp
         * @memberof battle.cmd_recover_hp
         * @instance
         */
        cmd_recover_hp.prototype.addHp = 0;

        /**
         * Creates a new cmd_recover_hp instance using the specified properties.
         * @function create
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.Icmd_recover_hp=} [properties] Properties to set
         * @returns {battle.cmd_recover_hp} cmd_recover_hp instance
         */
        cmd_recover_hp.create = function create(properties) {
            return new cmd_recover_hp(properties);
        };

        /**
         * Encodes the specified cmd_recover_hp message. Does not implicitly {@link battle.cmd_recover_hp.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.Icmd_recover_hp} message cmd_recover_hp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_recover_hp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.addHp != null && Object.hasOwnProperty.call(message, "addHp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.addHp);
            return writer;
        };

        /**
         * Encodes the specified cmd_recover_hp message, length delimited. Does not implicitly {@link battle.cmd_recover_hp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.Icmd_recover_hp} message cmd_recover_hp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_recover_hp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_recover_hp message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_recover_hp} cmd_recover_hp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_recover_hp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_recover_hp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.addHp = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_recover_hp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_recover_hp} cmd_recover_hp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_recover_hp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_recover_hp message.
         * @function verify
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_recover_hp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.addHp != null && message.hasOwnProperty("addHp"))
                if (!$util.isInteger(message.addHp))
                    return "addHp: integer expected";
            return null;
        };

        /**
         * Creates a cmd_recover_hp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_recover_hp} cmd_recover_hp
         */
        cmd_recover_hp.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_recover_hp)
                return object;
            var message = new $root.battle.cmd_recover_hp();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.addHp != null)
                message.addHp = object.addHp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_recover_hp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.cmd_recover_hp} message cmd_recover_hp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_recover_hp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.addHp = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.addHp != null && message.hasOwnProperty("addHp"))
                object.addHp = message.addHp;
            return object;
        };

        /**
         * Converts this cmd_recover_hp to JSON.
         * @function toJSON
         * @memberof battle.cmd_recover_hp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_recover_hp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_recover_hp
         * @function getTypeUrl
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_recover_hp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_recover_hp";
        };

        return cmd_recover_hp;
    })();

    battle.cmd_retreat = (function() {

        /**
         * Properties of a cmd_retreat.
         * @memberof battle
         * @interface Icmd_retreat
         * @property {number|null} [eid] cmd_retreat eid
         */

        /**
         * Constructs a new cmd_retreat.
         * @memberof battle
         * @classdesc Represents a cmd_retreat.
         * @implements Icmd_retreat
         * @constructor
         * @param {battle.Icmd_retreat=} [properties] Properties to set
         */
        function cmd_retreat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_retreat eid.
         * @member {number} eid
         * @memberof battle.cmd_retreat
         * @instance
         */
        cmd_retreat.prototype.eid = 0;

        /**
         * Creates a new cmd_retreat instance using the specified properties.
         * @function create
         * @memberof battle.cmd_retreat
         * @static
         * @param {battle.Icmd_retreat=} [properties] Properties to set
         * @returns {battle.cmd_retreat} cmd_retreat instance
         */
        cmd_retreat.create = function create(properties) {
            return new cmd_retreat(properties);
        };

        /**
         * Encodes the specified cmd_retreat message. Does not implicitly {@link battle.cmd_retreat.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_retreat
         * @static
         * @param {battle.Icmd_retreat} message cmd_retreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_retreat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified cmd_retreat message, length delimited. Does not implicitly {@link battle.cmd_retreat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_retreat
         * @static
         * @param {battle.Icmd_retreat} message cmd_retreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_retreat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_retreat message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_retreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_retreat} cmd_retreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_retreat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_retreat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_retreat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_retreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_retreat} cmd_retreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_retreat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_retreat message.
         * @function verify
         * @memberof battle.cmd_retreat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_retreat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a cmd_retreat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_retreat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_retreat} cmd_retreat
         */
        cmd_retreat.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_retreat)
                return object;
            var message = new $root.battle.cmd_retreat();
            if (object.eid != null)
                message.eid = object.eid | 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_retreat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_retreat
         * @static
         * @param {battle.cmd_retreat} message cmd_retreat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_retreat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this cmd_retreat to JSON.
         * @function toJSON
         * @memberof battle.cmd_retreat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_retreat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_retreat
         * @function getTypeUrl
         * @memberof battle.cmd_retreat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_retreat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_retreat";
        };

        return cmd_retreat;
    })();

    battle.cmd_forward = (function() {

        /**
         * Properties of a cmd_forward.
         * @memberof battle
         * @interface Icmd_forward
         * @property {number|null} [eid] cmd_forward eid
         */

        /**
         * Constructs a new cmd_forward.
         * @memberof battle
         * @classdesc Represents a cmd_forward.
         * @implements Icmd_forward
         * @constructor
         * @param {battle.Icmd_forward=} [properties] Properties to set
         */
        function cmd_forward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_forward eid.
         * @member {number} eid
         * @memberof battle.cmd_forward
         * @instance
         */
        cmd_forward.prototype.eid = 0;

        /**
         * Creates a new cmd_forward instance using the specified properties.
         * @function create
         * @memberof battle.cmd_forward
         * @static
         * @param {battle.Icmd_forward=} [properties] Properties to set
         * @returns {battle.cmd_forward} cmd_forward instance
         */
        cmd_forward.create = function create(properties) {
            return new cmd_forward(properties);
        };

        /**
         * Encodes the specified cmd_forward message. Does not implicitly {@link battle.cmd_forward.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_forward
         * @static
         * @param {battle.Icmd_forward} message cmd_forward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_forward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified cmd_forward message, length delimited. Does not implicitly {@link battle.cmd_forward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_forward
         * @static
         * @param {battle.Icmd_forward} message cmd_forward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_forward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_forward message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_forward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_forward} cmd_forward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_forward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_forward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_forward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_forward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_forward} cmd_forward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_forward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_forward message.
         * @function verify
         * @memberof battle.cmd_forward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_forward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a cmd_forward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_forward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_forward} cmd_forward
         */
        cmd_forward.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_forward)
                return object;
            var message = new $root.battle.cmd_forward();
            if (object.eid != null)
                message.eid = object.eid | 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_forward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_forward
         * @static
         * @param {battle.cmd_forward} message cmd_forward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_forward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this cmd_forward to JSON.
         * @function toJSON
         * @memberof battle.cmd_forward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_forward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_forward
         * @function getTypeUrl
         * @memberof battle.cmd_forward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_forward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_forward";
        };

        return cmd_forward;
    })();

    battle.BattleCmd = (function() {

        /**
         * Properties of a BattleCmd.
         * @memberof battle
         * @interface IBattleCmd
         * @property {number|null} [cmdType] BattleCmd cmdType
         * @property {battle.Icmd_add_entity|null} [addEntity] BattleCmd addEntity
         * @property {battle.Icmd_update_entity|null} [updateEntity] BattleCmd updateEntity
         * @property {battle.Icmd_del_entity|null} [delEntity] BattleCmd delEntity
         * @property {battle.Icmd_move_start|null} [moveStart] BattleCmd moveStart
         * @property {battle.Icmd_move_stop|null} [moveStop] BattleCmd moveStop
         * @property {battle.Icmd_add_buff|null} [addBuff] BattleCmd addBuff
         * @property {battle.Icmd_del_buff|null} [delBuff] BattleCmd delBuff
         * @property {battle.Icmd_attack|null} [attack] BattleCmd attack
         * @property {battle.Icmd_under_atk|null} [underAtk] BattleCmd underAtk
         * @property {battle.Icmd_force_to|null} [forceTo] BattleCmd forceTo
         * @property {battle.Icmd_move_to|null} [moveTo] BattleCmd moveTo
         * @property {battle.Icmd_retreat|null} [retreat] BattleCmd retreat
         * @property {battle.Icmd_forward|null} [forward] BattleCmd forward
         * @property {battle.Icmd_recover_hp|null} [recoverHp] BattleCmd recoverHp
         */

        /**
         * Constructs a new BattleCmd.
         * @memberof battle
         * @classdesc Represents a BattleCmd.
         * @implements IBattleCmd
         * @constructor
         * @param {battle.IBattleCmd=} [properties] Properties to set
         */
        function BattleCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleCmd cmdType.
         * @member {number} cmdType
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.cmdType = 0;

        /**
         * BattleCmd addEntity.
         * @member {battle.Icmd_add_entity|null|undefined} addEntity
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.addEntity = null;

        /**
         * BattleCmd updateEntity.
         * @member {battle.Icmd_update_entity|null|undefined} updateEntity
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.updateEntity = null;

        /**
         * BattleCmd delEntity.
         * @member {battle.Icmd_del_entity|null|undefined} delEntity
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.delEntity = null;

        /**
         * BattleCmd moveStart.
         * @member {battle.Icmd_move_start|null|undefined} moveStart
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.moveStart = null;

        /**
         * BattleCmd moveStop.
         * @member {battle.Icmd_move_stop|null|undefined} moveStop
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.moveStop = null;

        /**
         * BattleCmd addBuff.
         * @member {battle.Icmd_add_buff|null|undefined} addBuff
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.addBuff = null;

        /**
         * BattleCmd delBuff.
         * @member {battle.Icmd_del_buff|null|undefined} delBuff
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.delBuff = null;

        /**
         * BattleCmd attack.
         * @member {battle.Icmd_attack|null|undefined} attack
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.attack = null;

        /**
         * BattleCmd underAtk.
         * @member {battle.Icmd_under_atk|null|undefined} underAtk
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.underAtk = null;

        /**
         * BattleCmd forceTo.
         * @member {battle.Icmd_force_to|null|undefined} forceTo
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.forceTo = null;

        /**
         * BattleCmd moveTo.
         * @member {battle.Icmd_move_to|null|undefined} moveTo
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.moveTo = null;

        /**
         * BattleCmd retreat.
         * @member {battle.Icmd_retreat|null|undefined} retreat
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.retreat = null;

        /**
         * BattleCmd forward.
         * @member {battle.Icmd_forward|null|undefined} forward
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.forward = null;

        /**
         * BattleCmd recoverHp.
         * @member {battle.Icmd_recover_hp|null|undefined} recoverHp
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.recoverHp = null;

        /**
         * Creates a new BattleCmd instance using the specified properties.
         * @function create
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.IBattleCmd=} [properties] Properties to set
         * @returns {battle.BattleCmd} BattleCmd instance
         */
        BattleCmd.create = function create(properties) {
            return new BattleCmd(properties);
        };

        /**
         * Encodes the specified BattleCmd message. Does not implicitly {@link battle.BattleCmd.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.IBattleCmd} message BattleCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmdType != null && Object.hasOwnProperty.call(message, "cmdType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cmdType);
            if (message.addEntity != null && Object.hasOwnProperty.call(message, "addEntity"))
                $root.battle.cmd_add_entity.encode(message.addEntity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.updateEntity != null && Object.hasOwnProperty.call(message, "updateEntity"))
                $root.battle.cmd_update_entity.encode(message.updateEntity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.delEntity != null && Object.hasOwnProperty.call(message, "delEntity"))
                $root.battle.cmd_del_entity.encode(message.delEntity, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.moveStart != null && Object.hasOwnProperty.call(message, "moveStart"))
                $root.battle.cmd_move_start.encode(message.moveStart, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.moveStop != null && Object.hasOwnProperty.call(message, "moveStop"))
                $root.battle.cmd_move_stop.encode(message.moveStop, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.addBuff != null && Object.hasOwnProperty.call(message, "addBuff"))
                $root.battle.cmd_add_buff.encode(message.addBuff, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.delBuff != null && Object.hasOwnProperty.call(message, "delBuff"))
                $root.battle.cmd_del_buff.encode(message.delBuff, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.attack != null && Object.hasOwnProperty.call(message, "attack"))
                $root.battle.cmd_attack.encode(message.attack, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.underAtk != null && Object.hasOwnProperty.call(message, "underAtk"))
                $root.battle.cmd_under_atk.encode(message.underAtk, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.forceTo != null && Object.hasOwnProperty.call(message, "forceTo"))
                $root.battle.cmd_force_to.encode(message.forceTo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.moveTo != null && Object.hasOwnProperty.call(message, "moveTo"))
                $root.battle.cmd_move_to.encode(message.moveTo, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.retreat != null && Object.hasOwnProperty.call(message, "retreat"))
                $root.battle.cmd_retreat.encode(message.retreat, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                $root.battle.cmd_forward.encode(message.forward, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.recoverHp != null && Object.hasOwnProperty.call(message, "recoverHp"))
                $root.battle.cmd_recover_hp.encode(message.recoverHp, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BattleCmd message, length delimited. Does not implicitly {@link battle.BattleCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.IBattleCmd} message BattleCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleCmd message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleCmd} BattleCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmdType = reader.uint32();
                        break;
                    }
                case 2: {
                        message.addEntity = $root.battle.cmd_add_entity.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.updateEntity = $root.battle.cmd_update_entity.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.delEntity = $root.battle.cmd_del_entity.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.moveStart = $root.battle.cmd_move_start.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.moveStop = $root.battle.cmd_move_stop.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.addBuff = $root.battle.cmd_add_buff.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.delBuff = $root.battle.cmd_del_buff.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.attack = $root.battle.cmd_attack.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.underAtk = $root.battle.cmd_under_atk.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.forceTo = $root.battle.cmd_force_to.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.moveTo = $root.battle.cmd_move_to.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.retreat = $root.battle.cmd_retreat.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.forward = $root.battle.cmd_forward.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.recoverHp = $root.battle.cmd_recover_hp.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleCmd} BattleCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleCmd message.
         * @function verify
         * @memberof battle.BattleCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmdType != null && message.hasOwnProperty("cmdType"))
                if (!$util.isInteger(message.cmdType))
                    return "cmdType: integer expected";
            if (message.addEntity != null && message.hasOwnProperty("addEntity")) {
                var error = $root.battle.cmd_add_entity.verify(message.addEntity);
                if (error)
                    return "addEntity." + error;
            }
            if (message.updateEntity != null && message.hasOwnProperty("updateEntity")) {
                var error = $root.battle.cmd_update_entity.verify(message.updateEntity);
                if (error)
                    return "updateEntity." + error;
            }
            if (message.delEntity != null && message.hasOwnProperty("delEntity")) {
                var error = $root.battle.cmd_del_entity.verify(message.delEntity);
                if (error)
                    return "delEntity." + error;
            }
            if (message.moveStart != null && message.hasOwnProperty("moveStart")) {
                var error = $root.battle.cmd_move_start.verify(message.moveStart);
                if (error)
                    return "moveStart." + error;
            }
            if (message.moveStop != null && message.hasOwnProperty("moveStop")) {
                var error = $root.battle.cmd_move_stop.verify(message.moveStop);
                if (error)
                    return "moveStop." + error;
            }
            if (message.addBuff != null && message.hasOwnProperty("addBuff")) {
                var error = $root.battle.cmd_add_buff.verify(message.addBuff);
                if (error)
                    return "addBuff." + error;
            }
            if (message.delBuff != null && message.hasOwnProperty("delBuff")) {
                var error = $root.battle.cmd_del_buff.verify(message.delBuff);
                if (error)
                    return "delBuff." + error;
            }
            if (message.attack != null && message.hasOwnProperty("attack")) {
                var error = $root.battle.cmd_attack.verify(message.attack);
                if (error)
                    return "attack." + error;
            }
            if (message.underAtk != null && message.hasOwnProperty("underAtk")) {
                var error = $root.battle.cmd_under_atk.verify(message.underAtk);
                if (error)
                    return "underAtk." + error;
            }
            if (message.forceTo != null && message.hasOwnProperty("forceTo")) {
                var error = $root.battle.cmd_force_to.verify(message.forceTo);
                if (error)
                    return "forceTo." + error;
            }
            if (message.moveTo != null && message.hasOwnProperty("moveTo")) {
                var error = $root.battle.cmd_move_to.verify(message.moveTo);
                if (error)
                    return "moveTo." + error;
            }
            if (message.retreat != null && message.hasOwnProperty("retreat")) {
                var error = $root.battle.cmd_retreat.verify(message.retreat);
                if (error)
                    return "retreat." + error;
            }
            if (message.forward != null && message.hasOwnProperty("forward")) {
                var error = $root.battle.cmd_forward.verify(message.forward);
                if (error)
                    return "forward." + error;
            }
            if (message.recoverHp != null && message.hasOwnProperty("recoverHp")) {
                var error = $root.battle.cmd_recover_hp.verify(message.recoverHp);
                if (error)
                    return "recoverHp." + error;
            }
            return null;
        };

        /**
         * Creates a BattleCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleCmd} BattleCmd
         */
        BattleCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleCmd)
                return object;
            var message = new $root.battle.BattleCmd();
            if (object.cmdType != null)
                message.cmdType = object.cmdType >>> 0;
            if (object.addEntity != null) {
                if (typeof object.addEntity !== "object")
                    throw TypeError(".battle.BattleCmd.addEntity: object expected");
                message.addEntity = $root.battle.cmd_add_entity.fromObject(object.addEntity);
            }
            if (object.updateEntity != null) {
                if (typeof object.updateEntity !== "object")
                    throw TypeError(".battle.BattleCmd.updateEntity: object expected");
                message.updateEntity = $root.battle.cmd_update_entity.fromObject(object.updateEntity);
            }
            if (object.delEntity != null) {
                if (typeof object.delEntity !== "object")
                    throw TypeError(".battle.BattleCmd.delEntity: object expected");
                message.delEntity = $root.battle.cmd_del_entity.fromObject(object.delEntity);
            }
            if (object.moveStart != null) {
                if (typeof object.moveStart !== "object")
                    throw TypeError(".battle.BattleCmd.moveStart: object expected");
                message.moveStart = $root.battle.cmd_move_start.fromObject(object.moveStart);
            }
            if (object.moveStop != null) {
                if (typeof object.moveStop !== "object")
                    throw TypeError(".battle.BattleCmd.moveStop: object expected");
                message.moveStop = $root.battle.cmd_move_stop.fromObject(object.moveStop);
            }
            if (object.addBuff != null) {
                if (typeof object.addBuff !== "object")
                    throw TypeError(".battle.BattleCmd.addBuff: object expected");
                message.addBuff = $root.battle.cmd_add_buff.fromObject(object.addBuff);
            }
            if (object.delBuff != null) {
                if (typeof object.delBuff !== "object")
                    throw TypeError(".battle.BattleCmd.delBuff: object expected");
                message.delBuff = $root.battle.cmd_del_buff.fromObject(object.delBuff);
            }
            if (object.attack != null) {
                if (typeof object.attack !== "object")
                    throw TypeError(".battle.BattleCmd.attack: object expected");
                message.attack = $root.battle.cmd_attack.fromObject(object.attack);
            }
            if (object.underAtk != null) {
                if (typeof object.underAtk !== "object")
                    throw TypeError(".battle.BattleCmd.underAtk: object expected");
                message.underAtk = $root.battle.cmd_under_atk.fromObject(object.underAtk);
            }
            if (object.forceTo != null) {
                if (typeof object.forceTo !== "object")
                    throw TypeError(".battle.BattleCmd.forceTo: object expected");
                message.forceTo = $root.battle.cmd_force_to.fromObject(object.forceTo);
            }
            if (object.moveTo != null) {
                if (typeof object.moveTo !== "object")
                    throw TypeError(".battle.BattleCmd.moveTo: object expected");
                message.moveTo = $root.battle.cmd_move_to.fromObject(object.moveTo);
            }
            if (object.retreat != null) {
                if (typeof object.retreat !== "object")
                    throw TypeError(".battle.BattleCmd.retreat: object expected");
                message.retreat = $root.battle.cmd_retreat.fromObject(object.retreat);
            }
            if (object.forward != null) {
                if (typeof object.forward !== "object")
                    throw TypeError(".battle.BattleCmd.forward: object expected");
                message.forward = $root.battle.cmd_forward.fromObject(object.forward);
            }
            if (object.recoverHp != null) {
                if (typeof object.recoverHp !== "object")
                    throw TypeError(".battle.BattleCmd.recoverHp: object expected");
                message.recoverHp = $root.battle.cmd_recover_hp.fromObject(object.recoverHp);
            }
            return message;
        };

        /**
         * Creates a plain object from a BattleCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.BattleCmd} message BattleCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cmdType = 0;
                object.addEntity = null;
                object.updateEntity = null;
                object.delEntity = null;
                object.moveStart = null;
                object.moveStop = null;
                object.addBuff = null;
                object.delBuff = null;
                object.attack = null;
                object.underAtk = null;
                object.forceTo = null;
                object.moveTo = null;
                object.retreat = null;
                object.forward = null;
                object.recoverHp = null;
            }
            if (message.cmdType != null && message.hasOwnProperty("cmdType"))
                object.cmdType = message.cmdType;
            if (message.addEntity != null && message.hasOwnProperty("addEntity"))
                object.addEntity = $root.battle.cmd_add_entity.toObject(message.addEntity, options);
            if (message.updateEntity != null && message.hasOwnProperty("updateEntity"))
                object.updateEntity = $root.battle.cmd_update_entity.toObject(message.updateEntity, options);
            if (message.delEntity != null && message.hasOwnProperty("delEntity"))
                object.delEntity = $root.battle.cmd_del_entity.toObject(message.delEntity, options);
            if (message.moveStart != null && message.hasOwnProperty("moveStart"))
                object.moveStart = $root.battle.cmd_move_start.toObject(message.moveStart, options);
            if (message.moveStop != null && message.hasOwnProperty("moveStop"))
                object.moveStop = $root.battle.cmd_move_stop.toObject(message.moveStop, options);
            if (message.addBuff != null && message.hasOwnProperty("addBuff"))
                object.addBuff = $root.battle.cmd_add_buff.toObject(message.addBuff, options);
            if (message.delBuff != null && message.hasOwnProperty("delBuff"))
                object.delBuff = $root.battle.cmd_del_buff.toObject(message.delBuff, options);
            if (message.attack != null && message.hasOwnProperty("attack"))
                object.attack = $root.battle.cmd_attack.toObject(message.attack, options);
            if (message.underAtk != null && message.hasOwnProperty("underAtk"))
                object.underAtk = $root.battle.cmd_under_atk.toObject(message.underAtk, options);
            if (message.forceTo != null && message.hasOwnProperty("forceTo"))
                object.forceTo = $root.battle.cmd_force_to.toObject(message.forceTo, options);
            if (message.moveTo != null && message.hasOwnProperty("moveTo"))
                object.moveTo = $root.battle.cmd_move_to.toObject(message.moveTo, options);
            if (message.retreat != null && message.hasOwnProperty("retreat"))
                object.retreat = $root.battle.cmd_retreat.toObject(message.retreat, options);
            if (message.forward != null && message.hasOwnProperty("forward"))
                object.forward = $root.battle.cmd_forward.toObject(message.forward, options);
            if (message.recoverHp != null && message.hasOwnProperty("recoverHp"))
                object.recoverHp = $root.battle.cmd_recover_hp.toObject(message.recoverHp, options);
            return object;
        };

        /**
         * Converts this BattleCmd to JSON.
         * @function toJSON
         * @memberof battle.BattleCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleCmd
         * @function getTypeUrl
         * @memberof battle.BattleCmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleCmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleCmd";
        };

        return BattleCmd;
    })();

    battle.BattleFrame = (function() {

        /**
         * Properties of a BattleFrame.
         * @memberof battle
         * @interface IBattleFrame
         * @property {number|null} [frame] BattleFrame frame
         * @property {Array.<battle.IBattleCmd>|null} [cmds] BattleFrame cmds
         */

        /**
         * Constructs a new BattleFrame.
         * @memberof battle
         * @classdesc Represents a BattleFrame.
         * @implements IBattleFrame
         * @constructor
         * @param {battle.IBattleFrame=} [properties] Properties to set
         */
        function BattleFrame(properties) {
            this.cmds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleFrame frame.
         * @member {number} frame
         * @memberof battle.BattleFrame
         * @instance
         */
        BattleFrame.prototype.frame = 0;

        /**
         * BattleFrame cmds.
         * @member {Array.<battle.IBattleCmd>} cmds
         * @memberof battle.BattleFrame
         * @instance
         */
        BattleFrame.prototype.cmds = $util.emptyArray;

        /**
         * Creates a new BattleFrame instance using the specified properties.
         * @function create
         * @memberof battle.BattleFrame
         * @static
         * @param {battle.IBattleFrame=} [properties] Properties to set
         * @returns {battle.BattleFrame} BattleFrame instance
         */
        BattleFrame.create = function create(properties) {
            return new BattleFrame(properties);
        };

        /**
         * Encodes the specified BattleFrame message. Does not implicitly {@link battle.BattleFrame.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleFrame
         * @static
         * @param {battle.IBattleFrame} message BattleFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleFrame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frame != null && Object.hasOwnProperty.call(message, "frame"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.frame);
            if (message.cmds != null && message.cmds.length)
                for (var i = 0; i < message.cmds.length; ++i)
                    $root.battle.BattleCmd.encode(message.cmds[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BattleFrame message, length delimited. Does not implicitly {@link battle.BattleFrame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleFrame
         * @static
         * @param {battle.IBattleFrame} message BattleFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleFrame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleFrame message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleFrame} BattleFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleFrame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleFrame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.frame = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.cmds && message.cmds.length))
                            message.cmds = [];
                        message.cmds.push($root.battle.BattleCmd.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleFrame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleFrame} BattleFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleFrame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleFrame message.
         * @function verify
         * @memberof battle.BattleFrame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleFrame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frame != null && message.hasOwnProperty("frame"))
                if (!$util.isInteger(message.frame))
                    return "frame: integer expected";
            if (message.cmds != null && message.hasOwnProperty("cmds")) {
                if (!Array.isArray(message.cmds))
                    return "cmds: array expected";
                for (var i = 0; i < message.cmds.length; ++i) {
                    var error = $root.battle.BattleCmd.verify(message.cmds[i]);
                    if (error)
                        return "cmds." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BattleFrame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleFrame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleFrame} BattleFrame
         */
        BattleFrame.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleFrame)
                return object;
            var message = new $root.battle.BattleFrame();
            if (object.frame != null)
                message.frame = object.frame >>> 0;
            if (object.cmds) {
                if (!Array.isArray(object.cmds))
                    throw TypeError(".battle.BattleFrame.cmds: array expected");
                message.cmds = [];
                for (var i = 0; i < object.cmds.length; ++i) {
                    if (typeof object.cmds[i] !== "object")
                        throw TypeError(".battle.BattleFrame.cmds: object expected");
                    message.cmds[i] = $root.battle.BattleCmd.fromObject(object.cmds[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BattleFrame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleFrame
         * @static
         * @param {battle.BattleFrame} message BattleFrame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleFrame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cmds = [];
            if (options.defaults)
                object.frame = 0;
            if (message.frame != null && message.hasOwnProperty("frame"))
                object.frame = message.frame;
            if (message.cmds && message.cmds.length) {
                object.cmds = [];
                for (var j = 0; j < message.cmds.length; ++j)
                    object.cmds[j] = $root.battle.BattleCmd.toObject(message.cmds[j], options);
            }
            return object;
        };

        /**
         * Converts this BattleFrame to JSON.
         * @function toJSON
         * @memberof battle.BattleFrame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleFrame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleFrame
         * @function getTypeUrl
         * @memberof battle.BattleFrame
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleFrame";
        };

        return BattleFrame;
    })();

    battle.Battle = (function() {

        /**
         * Properties of a Battle.
         * @memberof battle
         * @interface IBattle
         * @property {number|null} [battleId] Battle battleId
         * @property {number|null} [battleUid] Battle battleUid
         * @property {Array.<battle.IBattleRole>|null} [roles] Battle roles
         * @property {Array.<battle.IBattleFrame>|null} [frames] Battle frames
         */

        /**
         * Constructs a new Battle.
         * @memberof battle
         * @classdesc Represents a Battle.
         * @implements IBattle
         * @constructor
         * @param {battle.IBattle=} [properties] Properties to set
         */
        function Battle(properties) {
            this.roles = [];
            this.frames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Battle battleId.
         * @member {number} battleId
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.battleId = 0;

        /**
         * Battle battleUid.
         * @member {number} battleUid
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.battleUid = 0;

        /**
         * Battle roles.
         * @member {Array.<battle.IBattleRole>} roles
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.roles = $util.emptyArray;

        /**
         * Battle frames.
         * @member {Array.<battle.IBattleFrame>} frames
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.frames = $util.emptyArray;

        /**
         * Creates a new Battle instance using the specified properties.
         * @function create
         * @memberof battle.Battle
         * @static
         * @param {battle.IBattle=} [properties] Properties to set
         * @returns {battle.Battle} Battle instance
         */
        Battle.create = function create(properties) {
            return new Battle(properties);
        };

        /**
         * Encodes the specified Battle message. Does not implicitly {@link battle.Battle.verify|verify} messages.
         * @function encode
         * @memberof battle.Battle
         * @static
         * @param {battle.IBattle} message Battle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Battle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleId != null && Object.hasOwnProperty.call(message, "battleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleId);
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.battleUid);
            if (message.roles != null && message.roles.length)
                for (var i = 0; i < message.roles.length; ++i)
                    $root.battle.BattleRole.encode(message.roles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.frames != null && message.frames.length)
                for (var i = 0; i < message.frames.length; ++i)
                    $root.battle.BattleFrame.encode(message.frames[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Battle message, length delimited. Does not implicitly {@link battle.Battle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.Battle
         * @static
         * @param {battle.IBattle} message Battle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Battle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Battle message from the specified reader or buffer.
         * @function decode
         * @memberof battle.Battle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.Battle} Battle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Battle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.Battle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 3: {
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push($root.battle.BattleRole.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.battle.BattleFrame.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Battle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.Battle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.Battle} Battle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Battle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Battle message.
         * @function verify
         * @memberof battle.Battle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Battle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleId != null && message.hasOwnProperty("battleId"))
                if (!$util.isInteger(message.battleId))
                    return "battleId: integer expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (var i = 0; i < message.roles.length; ++i) {
                    var error = $root.battle.BattleRole.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (var i = 0; i < message.frames.length; ++i) {
                    var error = $root.battle.BattleFrame.verify(message.frames[i]);
                    if (error)
                        return "frames." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Battle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.Battle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.Battle} Battle
         */
        Battle.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.Battle)
                return object;
            var message = new $root.battle.Battle();
            if (object.battleId != null)
                message.battleId = object.battleId >>> 0;
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".battle.Battle.roles: array expected");
                message.roles = [];
                for (var i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".battle.Battle.roles: object expected");
                    message.roles[i] = $root.battle.BattleRole.fromObject(object.roles[i]);
                }
            }
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".battle.Battle.frames: array expected");
                message.frames = [];
                for (var i = 0; i < object.frames.length; ++i) {
                    if (typeof object.frames[i] !== "object")
                        throw TypeError(".battle.Battle.frames: object expected");
                    message.frames[i] = $root.battle.BattleFrame.fromObject(object.frames[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Battle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.Battle
         * @static
         * @param {battle.Battle} message Battle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Battle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.roles = [];
                object.frames = [];
            }
            if (options.defaults) {
                object.battleId = 0;
                object.battleUid = 0;
            }
            if (message.battleId != null && message.hasOwnProperty("battleId"))
                object.battleId = message.battleId;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (var j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.battle.BattleRole.toObject(message.roles[j], options);
            }
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (var j = 0; j < message.frames.length; ++j)
                    object.frames[j] = $root.battle.BattleFrame.toObject(message.frames[j], options);
            }
            return object;
        };

        /**
         * Converts this Battle to JSON.
         * @function toJSON
         * @memberof battle.Battle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Battle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Battle
         * @function getTypeUrl
         * @memberof battle.Battle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Battle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.Battle";
        };

        return Battle;
    })();

    battle.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof battle
         * @interface Ic2s_load
         * @property {number|null} [battleUid] c2s_load battleUid
         */

        /**
         * Constructs a new c2s_load.
         * @memberof battle
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {battle.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load battleUid.
         * @member {number} battleUid
         * @memberof battle.c2s_load
         * @instance
         */
        c2s_load.prototype.battleUid = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof battle.c2s_load
         * @static
         * @param {battle.Ic2s_load=} [properties] Properties to set
         * @returns {battle.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link battle.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_load
         * @static
         * @param {battle.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link battle.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_load
         * @static
         * @param {battle.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof battle.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_load)
                return object;
            var message = new $root.battle.c2s_load();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_load
         * @static
         * @param {battle.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof battle.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof battle.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_load";
        };

        return c2s_load;
    })();

    battle.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof battle
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {battle.IBattle|null} [battle] s2c_load battle
         */

        /**
         * Constructs a new s2c_load.
         * @memberof battle
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {battle.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof battle.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load battle.
         * @member {battle.IBattle|null|undefined} battle
         * @memberof battle.s2c_load
         * @instance
         */
        s2c_load.prototype.battle = null;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof battle.s2c_load
         * @static
         * @param {battle.Is2c_load=} [properties] Properties to set
         * @returns {battle.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link battle.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_load
         * @static
         * @param {battle.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.battle != null && Object.hasOwnProperty.call(message, "battle"))
                $root.battle.Battle.encode(message.battle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link battle.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_load
         * @static
         * @param {battle.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.battle = $root.battle.Battle.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof battle.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.battle != null && message.hasOwnProperty("battle")) {
                var error = $root.battle.Battle.verify(message.battle);
                if (error)
                    return "battle." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_load)
                return object;
            var message = new $root.battle.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.battle != null) {
                if (typeof object.battle !== "object")
                    throw TypeError(".battle.s2c_load.battle: object expected");
                message.battle = $root.battle.Battle.fromObject(object.battle);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_load
         * @static
         * @param {battle.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.battle = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.battle != null && message.hasOwnProperty("battle"))
                object.battle = $root.battle.Battle.toObject(message.battle, options);
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof battle.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof battle.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_load";
        };

        return s2c_load;
    })();

    battle.c2s_ready = (function() {

        /**
         * Properties of a c2s_ready.
         * @memberof battle
         * @interface Ic2s_ready
         * @property {number|null} [battleUid] c2s_ready battleUid
         */

        /**
         * Constructs a new c2s_ready.
         * @memberof battle
         * @classdesc Represents a c2s_ready.
         * @implements Ic2s_ready
         * @constructor
         * @param {battle.Ic2s_ready=} [properties] Properties to set
         */
        function c2s_ready(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_ready battleUid.
         * @member {number} battleUid
         * @memberof battle.c2s_ready
         * @instance
         */
        c2s_ready.prototype.battleUid = 0;

        /**
         * Creates a new c2s_ready instance using the specified properties.
         * @function create
         * @memberof battle.c2s_ready
         * @static
         * @param {battle.Ic2s_ready=} [properties] Properties to set
         * @returns {battle.c2s_ready} c2s_ready instance
         */
        c2s_ready.create = function create(properties) {
            return new c2s_ready(properties);
        };

        /**
         * Encodes the specified c2s_ready message. Does not implicitly {@link battle.c2s_ready.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_ready
         * @static
         * @param {battle.Ic2s_ready} message c2s_ready message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ready.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_ready message, length delimited. Does not implicitly {@link battle.c2s_ready.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_ready
         * @static
         * @param {battle.Ic2s_ready} message c2s_ready message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ready.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_ready message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_ready
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_ready} c2s_ready
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ready.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_ready();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_ready message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_ready
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_ready} c2s_ready
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ready.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_ready message.
         * @function verify
         * @memberof battle.c2s_ready
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_ready.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_ready message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_ready
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_ready} c2s_ready
         */
        c2s_ready.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_ready)
                return object;
            var message = new $root.battle.c2s_ready();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_ready message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_ready
         * @static
         * @param {battle.c2s_ready} message c2s_ready
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_ready.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            return object;
        };

        /**
         * Converts this c2s_ready to JSON.
         * @function toJSON
         * @memberof battle.c2s_ready
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_ready.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_ready
         * @function getTypeUrl
         * @memberof battle.c2s_ready
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_ready.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_ready";
        };

        return c2s_ready;
    })();

    battle.s2c_ready = (function() {

        /**
         * Properties of a s2c_ready.
         * @memberof battle
         * @interface Is2c_ready
         * @property {number|null} [err] s2c_ready err
         */

        /**
         * Constructs a new s2c_ready.
         * @memberof battle
         * @classdesc Represents a s2c_ready.
         * @implements Is2c_ready
         * @constructor
         * @param {battle.Is2c_ready=} [properties] Properties to set
         */
        function s2c_ready(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_ready err.
         * @member {number} err
         * @memberof battle.s2c_ready
         * @instance
         */
        s2c_ready.prototype.err = 0;

        /**
         * Creates a new s2c_ready instance using the specified properties.
         * @function create
         * @memberof battle.s2c_ready
         * @static
         * @param {battle.Is2c_ready=} [properties] Properties to set
         * @returns {battle.s2c_ready} s2c_ready instance
         */
        s2c_ready.create = function create(properties) {
            return new s2c_ready(properties);
        };

        /**
         * Encodes the specified s2c_ready message. Does not implicitly {@link battle.s2c_ready.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_ready
         * @static
         * @param {battle.Is2c_ready} message s2c_ready message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ready.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_ready message, length delimited. Does not implicitly {@link battle.s2c_ready.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_ready
         * @static
         * @param {battle.Is2c_ready} message s2c_ready message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ready.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_ready message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_ready
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_ready} s2c_ready
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ready.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_ready();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_ready message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_ready
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_ready} s2c_ready
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ready.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_ready message.
         * @function verify
         * @memberof battle.s2c_ready
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_ready.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_ready message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_ready
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_ready} s2c_ready
         */
        s2c_ready.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_ready)
                return object;
            var message = new $root.battle.s2c_ready();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_ready message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_ready
         * @static
         * @param {battle.s2c_ready} message s2c_ready
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_ready.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_ready to JSON.
         * @function toJSON
         * @memberof battle.s2c_ready
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_ready.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_ready
         * @function getTypeUrl
         * @memberof battle.s2c_ready
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_ready.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_ready";
        };

        return s2c_ready;
    })();

    battle.notify_cmd = (function() {

        /**
         * Properties of a notify_cmd.
         * @memberof battle
         * @interface Inotify_cmd
         * @property {number|null} [battleUid] notify_cmd battleUid
         * @property {battle.IBattleFrame|null} [frame] notify_cmd frame
         */

        /**
         * Constructs a new notify_cmd.
         * @memberof battle
         * @classdesc Represents a notify_cmd.
         * @implements Inotify_cmd
         * @constructor
         * @param {battle.Inotify_cmd=} [properties] Properties to set
         */
        function notify_cmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_cmd battleUid.
         * @member {number} battleUid
         * @memberof battle.notify_cmd
         * @instance
         */
        notify_cmd.prototype.battleUid = 0;

        /**
         * notify_cmd frame.
         * @member {battle.IBattleFrame|null|undefined} frame
         * @memberof battle.notify_cmd
         * @instance
         */
        notify_cmd.prototype.frame = null;

        /**
         * Creates a new notify_cmd instance using the specified properties.
         * @function create
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.Inotify_cmd=} [properties] Properties to set
         * @returns {battle.notify_cmd} notify_cmd instance
         */
        notify_cmd.create = function create(properties) {
            return new notify_cmd(properties);
        };

        /**
         * Encodes the specified notify_cmd message. Does not implicitly {@link battle.notify_cmd.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.Inotify_cmd} message notify_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_cmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.frame != null && Object.hasOwnProperty.call(message, "frame"))
                $root.battle.BattleFrame.encode(message.frame, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_cmd message, length delimited. Does not implicitly {@link battle.notify_cmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.Inotify_cmd} message notify_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_cmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_cmd message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_cmd} notify_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_cmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_cmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.frame = $root.battle.BattleFrame.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_cmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_cmd} notify_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_cmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_cmd message.
         * @function verify
         * @memberof battle.notify_cmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_cmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.frame != null && message.hasOwnProperty("frame")) {
                var error = $root.battle.BattleFrame.verify(message.frame);
                if (error)
                    return "frame." + error;
            }
            return null;
        };

        /**
         * Creates a notify_cmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_cmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_cmd} notify_cmd
         */
        notify_cmd.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_cmd)
                return object;
            var message = new $root.battle.notify_cmd();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.frame != null) {
                if (typeof object.frame !== "object")
                    throw TypeError(".battle.notify_cmd.frame: object expected");
                message.frame = $root.battle.BattleFrame.fromObject(object.frame);
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_cmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.notify_cmd} message notify_cmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_cmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.battleUid = 0;
                object.frame = null;
            }
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.frame != null && message.hasOwnProperty("frame"))
                object.frame = $root.battle.BattleFrame.toObject(message.frame, options);
            return object;
        };

        /**
         * Converts this notify_cmd to JSON.
         * @function toJSON
         * @memberof battle.notify_cmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_cmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_cmd
         * @function getTypeUrl
         * @memberof battle.notify_cmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_cmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_cmd";
        };

        return notify_cmd;
    })();

    battle.c2s_launch_skill = (function() {

        /**
         * Properties of a c2s_launch_skill.
         * @memberof battle
         * @interface Ic2s_launch_skill
         * @property {number|null} [battleUid] c2s_launch_skill battleUid
         * @property {number|null} [eid] c2s_launch_skill eid
         * @property {number|null} [skillId] c2s_launch_skill skillId
         */

        /**
         * Constructs a new c2s_launch_skill.
         * @memberof battle
         * @classdesc Represents a c2s_launch_skill.
         * @implements Ic2s_launch_skill
         * @constructor
         * @param {battle.Ic2s_launch_skill=} [properties] Properties to set
         */
        function c2s_launch_skill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_launch_skill battleUid.
         * @member {number} battleUid
         * @memberof battle.c2s_launch_skill
         * @instance
         */
        c2s_launch_skill.prototype.battleUid = 0;

        /**
         * c2s_launch_skill eid.
         * @member {number} eid
         * @memberof battle.c2s_launch_skill
         * @instance
         */
        c2s_launch_skill.prototype.eid = 0;

        /**
         * c2s_launch_skill skillId.
         * @member {number} skillId
         * @memberof battle.c2s_launch_skill
         * @instance
         */
        c2s_launch_skill.prototype.skillId = 0;

        /**
         * Creates a new c2s_launch_skill instance using the specified properties.
         * @function create
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.Ic2s_launch_skill=} [properties] Properties to set
         * @returns {battle.c2s_launch_skill} c2s_launch_skill instance
         */
        c2s_launch_skill.create = function create(properties) {
            return new c2s_launch_skill(properties);
        };

        /**
         * Encodes the specified c2s_launch_skill message. Does not implicitly {@link battle.c2s_launch_skill.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.Ic2s_launch_skill} message c2s_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_launch_skill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.eid);
            if (message.skillId != null && Object.hasOwnProperty.call(message, "skillId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.skillId);
            return writer;
        };

        /**
         * Encodes the specified c2s_launch_skill message, length delimited. Does not implicitly {@link battle.c2s_launch_skill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.Ic2s_launch_skill} message c2s_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_launch_skill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_launch_skill message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_launch_skill} c2s_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_launch_skill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_launch_skill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.skillId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_launch_skill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_launch_skill} c2s_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_launch_skill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_launch_skill message.
         * @function verify
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_launch_skill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                if (!$util.isInteger(message.skillId))
                    return "skillId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_launch_skill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_launch_skill} c2s_launch_skill
         */
        c2s_launch_skill.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_launch_skill)
                return object;
            var message = new $root.battle.c2s_launch_skill();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.skillId != null)
                message.skillId = object.skillId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_launch_skill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.c2s_launch_skill} message c2s_launch_skill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_launch_skill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.battleUid = 0;
                object.eid = 0;
                object.skillId = 0;
            }
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                object.skillId = message.skillId;
            return object;
        };

        /**
         * Converts this c2s_launch_skill to JSON.
         * @function toJSON
         * @memberof battle.c2s_launch_skill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_launch_skill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_launch_skill
         * @function getTypeUrl
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_launch_skill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_launch_skill";
        };

        return c2s_launch_skill;
    })();

    battle.s2c_launch_skill = (function() {

        /**
         * Properties of a s2c_launch_skill.
         * @memberof battle
         * @interface Is2c_launch_skill
         * @property {number|null} [err] s2c_launch_skill err
         */

        /**
         * Constructs a new s2c_launch_skill.
         * @memberof battle
         * @classdesc Represents a s2c_launch_skill.
         * @implements Is2c_launch_skill
         * @constructor
         * @param {battle.Is2c_launch_skill=} [properties] Properties to set
         */
        function s2c_launch_skill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_launch_skill err.
         * @member {number} err
         * @memberof battle.s2c_launch_skill
         * @instance
         */
        s2c_launch_skill.prototype.err = 0;

        /**
         * Creates a new s2c_launch_skill instance using the specified properties.
         * @function create
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.Is2c_launch_skill=} [properties] Properties to set
         * @returns {battle.s2c_launch_skill} s2c_launch_skill instance
         */
        s2c_launch_skill.create = function create(properties) {
            return new s2c_launch_skill(properties);
        };

        /**
         * Encodes the specified s2c_launch_skill message. Does not implicitly {@link battle.s2c_launch_skill.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.Is2c_launch_skill} message s2c_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_launch_skill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_launch_skill message, length delimited. Does not implicitly {@link battle.s2c_launch_skill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.Is2c_launch_skill} message s2c_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_launch_skill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_launch_skill message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_launch_skill} s2c_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_launch_skill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_launch_skill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_launch_skill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_launch_skill} s2c_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_launch_skill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_launch_skill message.
         * @function verify
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_launch_skill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_launch_skill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_launch_skill} s2c_launch_skill
         */
        s2c_launch_skill.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_launch_skill)
                return object;
            var message = new $root.battle.s2c_launch_skill();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_launch_skill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.s2c_launch_skill} message s2c_launch_skill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_launch_skill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_launch_skill to JSON.
         * @function toJSON
         * @memberof battle.s2c_launch_skill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_launch_skill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_launch_skill
         * @function getTypeUrl
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_launch_skill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_launch_skill";
        };

        return s2c_launch_skill;
    })();

    battle.c2s_ask_cmd = (function() {

        /**
         * Properties of a c2s_ask_cmd.
         * @memberof battle
         * @interface Ic2s_ask_cmd
         * @property {number|null} [battleUid] c2s_ask_cmd battleUid
         * @property {number|null} [frame] c2s_ask_cmd frame
         */

        /**
         * Constructs a new c2s_ask_cmd.
         * @memberof battle
         * @classdesc Represents a c2s_ask_cmd.
         * @implements Ic2s_ask_cmd
         * @constructor
         * @param {battle.Ic2s_ask_cmd=} [properties] Properties to set
         */
        function c2s_ask_cmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_ask_cmd battleUid.
         * @member {number} battleUid
         * @memberof battle.c2s_ask_cmd
         * @instance
         */
        c2s_ask_cmd.prototype.battleUid = 0;

        /**
         * c2s_ask_cmd frame.
         * @member {number} frame
         * @memberof battle.c2s_ask_cmd
         * @instance
         */
        c2s_ask_cmd.prototype.frame = 0;

        /**
         * Creates a new c2s_ask_cmd instance using the specified properties.
         * @function create
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {battle.Ic2s_ask_cmd=} [properties] Properties to set
         * @returns {battle.c2s_ask_cmd} c2s_ask_cmd instance
         */
        c2s_ask_cmd.create = function create(properties) {
            return new c2s_ask_cmd(properties);
        };

        /**
         * Encodes the specified c2s_ask_cmd message. Does not implicitly {@link battle.c2s_ask_cmd.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {battle.Ic2s_ask_cmd} message c2s_ask_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ask_cmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.frame != null && Object.hasOwnProperty.call(message, "frame"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.frame);
            return writer;
        };

        /**
         * Encodes the specified c2s_ask_cmd message, length delimited. Does not implicitly {@link battle.c2s_ask_cmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {battle.Ic2s_ask_cmd} message c2s_ask_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ask_cmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_ask_cmd message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_ask_cmd} c2s_ask_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ask_cmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_ask_cmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.frame = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_ask_cmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_ask_cmd} c2s_ask_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ask_cmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_ask_cmd message.
         * @function verify
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_ask_cmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.frame != null && message.hasOwnProperty("frame"))
                if (!$util.isInteger(message.frame))
                    return "frame: integer expected";
            return null;
        };

        /**
         * Creates a c2s_ask_cmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_ask_cmd} c2s_ask_cmd
         */
        c2s_ask_cmd.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_ask_cmd)
                return object;
            var message = new $root.battle.c2s_ask_cmd();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.frame != null)
                message.frame = object.frame >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_ask_cmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {battle.c2s_ask_cmd} message c2s_ask_cmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_ask_cmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.battleUid = 0;
                object.frame = 0;
            }
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.frame != null && message.hasOwnProperty("frame"))
                object.frame = message.frame;
            return object;
        };

        /**
         * Converts this c2s_ask_cmd to JSON.
         * @function toJSON
         * @memberof battle.c2s_ask_cmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_ask_cmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_ask_cmd
         * @function getTypeUrl
         * @memberof battle.c2s_ask_cmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_ask_cmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_ask_cmd";
        };

        return c2s_ask_cmd;
    })();

    battle.s2c_ask_cmd = (function() {

        /**
         * Properties of a s2c_ask_cmd.
         * @memberof battle
         * @interface Is2c_ask_cmd
         * @property {number|null} [err] s2c_ask_cmd err
         */

        /**
         * Constructs a new s2c_ask_cmd.
         * @memberof battle
         * @classdesc Represents a s2c_ask_cmd.
         * @implements Is2c_ask_cmd
         * @constructor
         * @param {battle.Is2c_ask_cmd=} [properties] Properties to set
         */
        function s2c_ask_cmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_ask_cmd err.
         * @member {number} err
         * @memberof battle.s2c_ask_cmd
         * @instance
         */
        s2c_ask_cmd.prototype.err = 0;

        /**
         * Creates a new s2c_ask_cmd instance using the specified properties.
         * @function create
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {battle.Is2c_ask_cmd=} [properties] Properties to set
         * @returns {battle.s2c_ask_cmd} s2c_ask_cmd instance
         */
        s2c_ask_cmd.create = function create(properties) {
            return new s2c_ask_cmd(properties);
        };

        /**
         * Encodes the specified s2c_ask_cmd message. Does not implicitly {@link battle.s2c_ask_cmd.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {battle.Is2c_ask_cmd} message s2c_ask_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ask_cmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_ask_cmd message, length delimited. Does not implicitly {@link battle.s2c_ask_cmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {battle.Is2c_ask_cmd} message s2c_ask_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ask_cmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_ask_cmd message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_ask_cmd} s2c_ask_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ask_cmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_ask_cmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_ask_cmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_ask_cmd} s2c_ask_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ask_cmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_ask_cmd message.
         * @function verify
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_ask_cmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_ask_cmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_ask_cmd} s2c_ask_cmd
         */
        s2c_ask_cmd.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_ask_cmd)
                return object;
            var message = new $root.battle.s2c_ask_cmd();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_ask_cmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {battle.s2c_ask_cmd} message s2c_ask_cmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_ask_cmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_ask_cmd to JSON.
         * @function toJSON
         * @memberof battle.s2c_ask_cmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_ask_cmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_ask_cmd
         * @function getTypeUrl
         * @memberof battle.s2c_ask_cmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_ask_cmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_ask_cmd";
        };

        return s2c_ask_cmd;
    })();

    battle.c2s_ask_fight = (function() {

        /**
         * Properties of a c2s_ask_fight.
         * @memberof battle
         * @interface Ic2s_ask_fight
         * @property {number|null} [battleUid] c2s_ask_fight battleUid
         */

        /**
         * Constructs a new c2s_ask_fight.
         * @memberof battle
         * @classdesc Represents a c2s_ask_fight.
         * @implements Ic2s_ask_fight
         * @constructor
         * @param {battle.Ic2s_ask_fight=} [properties] Properties to set
         */
        function c2s_ask_fight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_ask_fight battleUid.
         * @member {number} battleUid
         * @memberof battle.c2s_ask_fight
         * @instance
         */
        c2s_ask_fight.prototype.battleUid = 0;

        /**
         * Creates a new c2s_ask_fight instance using the specified properties.
         * @function create
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {battle.Ic2s_ask_fight=} [properties] Properties to set
         * @returns {battle.c2s_ask_fight} c2s_ask_fight instance
         */
        c2s_ask_fight.create = function create(properties) {
            return new c2s_ask_fight(properties);
        };

        /**
         * Encodes the specified c2s_ask_fight message. Does not implicitly {@link battle.c2s_ask_fight.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {battle.Ic2s_ask_fight} message c2s_ask_fight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ask_fight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_ask_fight message, length delimited. Does not implicitly {@link battle.c2s_ask_fight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {battle.Ic2s_ask_fight} message c2s_ask_fight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ask_fight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_ask_fight message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_ask_fight} c2s_ask_fight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ask_fight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_ask_fight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_ask_fight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_ask_fight} c2s_ask_fight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ask_fight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_ask_fight message.
         * @function verify
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_ask_fight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_ask_fight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_ask_fight} c2s_ask_fight
         */
        c2s_ask_fight.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_ask_fight)
                return object;
            var message = new $root.battle.c2s_ask_fight();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_ask_fight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {battle.c2s_ask_fight} message c2s_ask_fight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_ask_fight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            return object;
        };

        /**
         * Converts this c2s_ask_fight to JSON.
         * @function toJSON
         * @memberof battle.c2s_ask_fight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_ask_fight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_ask_fight
         * @function getTypeUrl
         * @memberof battle.c2s_ask_fight
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_ask_fight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_ask_fight";
        };

        return c2s_ask_fight;
    })();

    battle.s2c_ask_fight = (function() {

        /**
         * Properties of a s2c_ask_fight.
         * @memberof battle
         * @interface Is2c_ask_fight
         * @property {number|null} [err] s2c_ask_fight err
         */

        /**
         * Constructs a new s2c_ask_fight.
         * @memberof battle
         * @classdesc Represents a s2c_ask_fight.
         * @implements Is2c_ask_fight
         * @constructor
         * @param {battle.Is2c_ask_fight=} [properties] Properties to set
         */
        function s2c_ask_fight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_ask_fight err.
         * @member {number} err
         * @memberof battle.s2c_ask_fight
         * @instance
         */
        s2c_ask_fight.prototype.err = 0;

        /**
         * Creates a new s2c_ask_fight instance using the specified properties.
         * @function create
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {battle.Is2c_ask_fight=} [properties] Properties to set
         * @returns {battle.s2c_ask_fight} s2c_ask_fight instance
         */
        s2c_ask_fight.create = function create(properties) {
            return new s2c_ask_fight(properties);
        };

        /**
         * Encodes the specified s2c_ask_fight message. Does not implicitly {@link battle.s2c_ask_fight.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {battle.Is2c_ask_fight} message s2c_ask_fight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ask_fight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_ask_fight message, length delimited. Does not implicitly {@link battle.s2c_ask_fight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {battle.Is2c_ask_fight} message s2c_ask_fight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ask_fight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_ask_fight message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_ask_fight} s2c_ask_fight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ask_fight.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_ask_fight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_ask_fight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_ask_fight} s2c_ask_fight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ask_fight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_ask_fight message.
         * @function verify
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_ask_fight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_ask_fight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_ask_fight} s2c_ask_fight
         */
        s2c_ask_fight.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_ask_fight)
                return object;
            var message = new $root.battle.s2c_ask_fight();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_ask_fight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {battle.s2c_ask_fight} message s2c_ask_fight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_ask_fight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_ask_fight to JSON.
         * @function toJSON
         * @memberof battle.s2c_ask_fight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_ask_fight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_ask_fight
         * @function getTypeUrl
         * @memberof battle.s2c_ask_fight
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_ask_fight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_ask_fight";
        };

        return s2c_ask_fight;
    })();

    battle.notify_start = (function() {

        /**
         * Properties of a notify_start.
         * @memberof battle
         * @interface Inotify_start
         * @property {number|null} [battleUid] notify_start battleUid
         */

        /**
         * Constructs a new notify_start.
         * @memberof battle
         * @classdesc Represents a notify_start.
         * @implements Inotify_start
         * @constructor
         * @param {battle.Inotify_start=} [properties] Properties to set
         */
        function notify_start(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_start battleUid.
         * @member {number} battleUid
         * @memberof battle.notify_start
         * @instance
         */
        notify_start.prototype.battleUid = 0;

        /**
         * Creates a new notify_start instance using the specified properties.
         * @function create
         * @memberof battle.notify_start
         * @static
         * @param {battle.Inotify_start=} [properties] Properties to set
         * @returns {battle.notify_start} notify_start instance
         */
        notify_start.create = function create(properties) {
            return new notify_start(properties);
        };

        /**
         * Encodes the specified notify_start message. Does not implicitly {@link battle.notify_start.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_start
         * @static
         * @param {battle.Inotify_start} message notify_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_start.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            return writer;
        };

        /**
         * Encodes the specified notify_start message, length delimited. Does not implicitly {@link battle.notify_start.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_start
         * @static
         * @param {battle.Inotify_start} message notify_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_start.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_start message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_start} notify_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_start.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_start();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_start message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_start} notify_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_start.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_start message.
         * @function verify
         * @memberof battle.notify_start
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_start.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            return null;
        };

        /**
         * Creates a notify_start message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_start
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_start} notify_start
         */
        notify_start.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_start)
                return object;
            var message = new $root.battle.notify_start();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a notify_start message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_start
         * @static
         * @param {battle.notify_start} message notify_start
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_start.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            return object;
        };

        /**
         * Converts this notify_start to JSON.
         * @function toJSON
         * @memberof battle.notify_start
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_start.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_start
         * @function getTypeUrl
         * @memberof battle.notify_start
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_start.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_start";
        };

        return notify_start;
    })();

    battle.notify_end = (function() {

        /**
         * Properties of a notify_end.
         * @memberof battle
         * @interface Inotify_end
         * @property {number|null} [battleUid] notify_end battleUid
         */

        /**
         * Constructs a new notify_end.
         * @memberof battle
         * @classdesc Represents a notify_end.
         * @implements Inotify_end
         * @constructor
         * @param {battle.Inotify_end=} [properties] Properties to set
         */
        function notify_end(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_end battleUid.
         * @member {number} battleUid
         * @memberof battle.notify_end
         * @instance
         */
        notify_end.prototype.battleUid = 0;

        /**
         * Creates a new notify_end instance using the specified properties.
         * @function create
         * @memberof battle.notify_end
         * @static
         * @param {battle.Inotify_end=} [properties] Properties to set
         * @returns {battle.notify_end} notify_end instance
         */
        notify_end.create = function create(properties) {
            return new notify_end(properties);
        };

        /**
         * Encodes the specified notify_end message. Does not implicitly {@link battle.notify_end.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_end
         * @static
         * @param {battle.Inotify_end} message notify_end message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_end.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            return writer;
        };

        /**
         * Encodes the specified notify_end message, length delimited. Does not implicitly {@link battle.notify_end.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_end
         * @static
         * @param {battle.Inotify_end} message notify_end message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_end.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_end message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_end
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_end} notify_end
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_end.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_end();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_end message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_end
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_end} notify_end
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_end.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_end message.
         * @function verify
         * @memberof battle.notify_end
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_end.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            return null;
        };

        /**
         * Creates a notify_end message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_end
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_end} notify_end
         */
        notify_end.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_end)
                return object;
            var message = new $root.battle.notify_end();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a notify_end message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_end
         * @static
         * @param {battle.notify_end} message notify_end
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_end.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            return object;
        };

        /**
         * Converts this notify_end to JSON.
         * @function toJSON
         * @memberof battle.notify_end
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_end.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_end
         * @function getTypeUrl
         * @memberof battle.notify_end
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_end.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_end";
        };

        return notify_end;
    })();

    battle.DebugInfo = (function() {

        /**
         * Properties of a DebugInfo.
         * @memberof battle
         * @interface IDebugInfo
         * @property {battle.IPosition|null} [pos] DebugInfo pos
         * @property {number|null} [color] DebugInfo color
         * @property {number|null} [size] DebugInfo size
         */

        /**
         * Constructs a new DebugInfo.
         * @memberof battle
         * @classdesc Represents a DebugInfo.
         * @implements IDebugInfo
         * @constructor
         * @param {battle.IDebugInfo=} [properties] Properties to set
         */
        function DebugInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugInfo pos.
         * @member {battle.IPosition|null|undefined} pos
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.pos = null;

        /**
         * DebugInfo color.
         * @member {number} color
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.color = 0;

        /**
         * DebugInfo size.
         * @member {number} size
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.size = 0;

        /**
         * Creates a new DebugInfo instance using the specified properties.
         * @function create
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.IDebugInfo=} [properties] Properties to set
         * @returns {battle.DebugInfo} DebugInfo instance
         */
        DebugInfo.create = function create(properties) {
            return new DebugInfo(properties);
        };

        /**
         * Encodes the specified DebugInfo message. Does not implicitly {@link battle.DebugInfo.verify|verify} messages.
         * @function encode
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.IDebugInfo} message DebugInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.battle.Position.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.color);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.size);
            return writer;
        };

        /**
         * Encodes the specified DebugInfo message, length delimited. Does not implicitly {@link battle.DebugInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.IDebugInfo} message DebugInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugInfo message from the specified reader or buffer.
         * @function decode
         * @memberof battle.DebugInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.DebugInfo} DebugInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.DebugInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = $root.battle.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.color = reader.uint32();
                        break;
                    }
                case 3: {
                        message.size = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.DebugInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.DebugInfo} DebugInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugInfo message.
         * @function verify
         * @memberof battle.DebugInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.battle.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            return null;
        };

        /**
         * Creates a DebugInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.DebugInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.DebugInfo} DebugInfo
         */
        DebugInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.DebugInfo)
                return object;
            var message = new $root.battle.DebugInfo();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".battle.DebugInfo.pos: object expected");
                message.pos = $root.battle.Position.fromObject(object.pos);
            }
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.size != null)
                message.size = object.size >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DebugInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.DebugInfo} message DebugInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = null;
                object.color = 0;
                object.size = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.battle.Position.toObject(message.pos, options);
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            return object;
        };

        /**
         * Converts this DebugInfo to JSON.
         * @function toJSON
         * @memberof battle.DebugInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DebugInfo
         * @function getTypeUrl
         * @memberof battle.DebugInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DebugInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.DebugInfo";
        };

        return DebugInfo;
    })();

    battle.notify_debug = (function() {

        /**
         * Properties of a notify_debug.
         * @memberof battle
         * @interface Inotify_debug
         * @property {Array.<battle.IDebugInfo>|null} [infos] notify_debug infos
         * @property {Array.<string>|null} [logs] notify_debug logs
         */

        /**
         * Constructs a new notify_debug.
         * @memberof battle
         * @classdesc Represents a notify_debug.
         * @implements Inotify_debug
         * @constructor
         * @param {battle.Inotify_debug=} [properties] Properties to set
         */
        function notify_debug(properties) {
            this.infos = [];
            this.logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_debug infos.
         * @member {Array.<battle.IDebugInfo>} infos
         * @memberof battle.notify_debug
         * @instance
         */
        notify_debug.prototype.infos = $util.emptyArray;

        /**
         * notify_debug logs.
         * @member {Array.<string>} logs
         * @memberof battle.notify_debug
         * @instance
         */
        notify_debug.prototype.logs = $util.emptyArray;

        /**
         * Creates a new notify_debug instance using the specified properties.
         * @function create
         * @memberof battle.notify_debug
         * @static
         * @param {battle.Inotify_debug=} [properties] Properties to set
         * @returns {battle.notify_debug} notify_debug instance
         */
        notify_debug.create = function create(properties) {
            return new notify_debug(properties);
        };

        /**
         * Encodes the specified notify_debug message. Does not implicitly {@link battle.notify_debug.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_debug
         * @static
         * @param {battle.Inotify_debug} message notify_debug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_debug.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.battle.DebugInfo.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.logs != null && message.logs.length)
                for (var i = 0; i < message.logs.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.logs[i]);
            return writer;
        };

        /**
         * Encodes the specified notify_debug message, length delimited. Does not implicitly {@link battle.notify_debug.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_debug
         * @static
         * @param {battle.Inotify_debug} message notify_debug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_debug.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_debug message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_debug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_debug} notify_debug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_debug.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_debug();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.infos && message.infos.length))
                            message.infos = [];
                        message.infos.push($root.battle.DebugInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.logs && message.logs.length))
                            message.logs = [];
                        message.logs.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_debug message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_debug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_debug} notify_debug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_debug.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_debug message.
         * @function verify
         * @memberof battle.notify_debug
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_debug.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.battle.DebugInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (var i = 0; i < message.logs.length; ++i)
                    if (!$util.isString(message.logs[i]))
                        return "logs: string[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_debug message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_debug
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_debug} notify_debug
         */
        notify_debug.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_debug)
                return object;
            var message = new $root.battle.notify_debug();
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".battle.notify_debug.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".battle.notify_debug.infos: object expected");
                    message.infos[i] = $root.battle.DebugInfo.fromObject(object.infos[i]);
                }
            }
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".battle.notify_debug.logs: array expected");
                message.logs = [];
                for (var i = 0; i < object.logs.length; ++i)
                    message.logs[i] = String(object.logs[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_debug message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_debug
         * @static
         * @param {battle.notify_debug} message notify_debug
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_debug.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.infos = [];
                object.logs = [];
            }
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.battle.DebugInfo.toObject(message.infos[j], options);
            }
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (var j = 0; j < message.logs.length; ++j)
                    object.logs[j] = message.logs[j];
            }
            return object;
        };

        /**
         * Converts this notify_debug to JSON.
         * @function toJSON
         * @memberof battle.notify_debug
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_debug.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_debug
         * @function getTypeUrl
         * @memberof battle.notify_debug
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_debug.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_debug";
        };

        return notify_debug;
    })();

    return battle;
})();

$root.chest = (function() {

    /**
     * Namespace chest.
     * @exports chest
     * @namespace
     */
    var chest = {};

    chest.EquipItem = (function() {

        /**
         * Properties of an EquipItem.
         * @memberof chest
         * @interface IEquipItem
         * @property {number|null} [id] EquipItem id
         * @property {Object.<string,number>|null} [attrs] EquipItem attrs
         */

        /**
         * Constructs a new EquipItem.
         * @memberof chest
         * @classdesc Represents an EquipItem.
         * @implements IEquipItem
         * @constructor
         * @param {chest.IEquipItem=} [properties] Properties to set
         */
        function EquipItem(properties) {
            this.attrs = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipItem id.
         * @member {number} id
         * @memberof chest.EquipItem
         * @instance
         */
        EquipItem.prototype.id = 0;

        /**
         * EquipItem attrs.
         * @member {Object.<string,number>} attrs
         * @memberof chest.EquipItem
         * @instance
         */
        EquipItem.prototype.attrs = $util.emptyObject;

        /**
         * Creates a new EquipItem instance using the specified properties.
         * @function create
         * @memberof chest.EquipItem
         * @static
         * @param {chest.IEquipItem=} [properties] Properties to set
         * @returns {chest.EquipItem} EquipItem instance
         */
        EquipItem.create = function create(properties) {
            return new EquipItem(properties);
        };

        /**
         * Encodes the specified EquipItem message. Does not implicitly {@link chest.EquipItem.verify|verify} messages.
         * @function encode
         * @memberof chest.EquipItem
         * @static
         * @param {chest.IEquipItem} message EquipItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.attrs != null && Object.hasOwnProperty.call(message, "attrs"))
                for (var keys = Object.keys(message.attrs), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.attrs[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EquipItem message, length delimited. Does not implicitly {@link chest.EquipItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.EquipItem
         * @static
         * @param {chest.IEquipItem} message EquipItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipItem message from the specified reader or buffer.
         * @function decode
         * @memberof chest.EquipItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.EquipItem} EquipItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.EquipItem(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        if (message.attrs === $util.emptyObject)
                            message.attrs = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = reader.int32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attrs[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.EquipItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.EquipItem} EquipItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipItem message.
         * @function verify
         * @memberof chest.EquipItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.attrs != null && message.hasOwnProperty("attrs")) {
                if (!$util.isObject(message.attrs))
                    return "attrs: object expected";
                var key = Object.keys(message.attrs);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "attrs: integer key{k:uint32} expected";
                    if (!$util.isInteger(message.attrs[key[i]]))
                        return "attrs: integer{k:uint32} expected";
                }
            }
            return null;
        };

        /**
         * Creates an EquipItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.EquipItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.EquipItem} EquipItem
         */
        EquipItem.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.EquipItem)
                return object;
            var message = new $root.chest.EquipItem();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.attrs) {
                if (typeof object.attrs !== "object")
                    throw TypeError(".chest.EquipItem.attrs: object expected");
                message.attrs = {};
                for (var keys = Object.keys(object.attrs), i = 0; i < keys.length; ++i)
                    message.attrs[keys[i]] = object.attrs[keys[i]] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from an EquipItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.EquipItem
         * @static
         * @param {chest.EquipItem} message EquipItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EquipItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.attrs = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            var keys2;
            if (message.attrs && (keys2 = Object.keys(message.attrs)).length) {
                object.attrs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.attrs[keys2[j]] = message.attrs[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this EquipItem to JSON.
         * @function toJSON
         * @memberof chest.EquipItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EquipItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EquipItem
         * @function getTypeUrl
         * @memberof chest.EquipItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EquipItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.EquipItem";
        };

        return EquipItem;
    })();

    chest.ChestInfo = (function() {

        /**
         * Properties of a ChestInfo.
         * @memberof chest
         * @interface IChestInfo
         * @property {chest.IEquipItem|null} ["new"] ChestInfo new
         * @property {Object.<string,chest.IEquipItem>|null} [equips] ChestInfo equips
         * @property {Object.<string,number>|null} [fullAttrs] ChestInfo fullAttrs
         * @property {number|null} [amount] ChestInfo amount
         * @property {number|null} [lv] ChestInfo lv
         * @property {number|null} [exp] ChestInfo exp
         * @property {number|null} [dungeonId] ChestInfo dungeonId
         */

        /**
         * Constructs a new ChestInfo.
         * @memberof chest
         * @classdesc Represents a ChestInfo.
         * @implements IChestInfo
         * @constructor
         * @param {chest.IChestInfo=} [properties] Properties to set
         */
        function ChestInfo(properties) {
            this.equips = {};
            this.fullAttrs = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChestInfo new.
         * @member {chest.IEquipItem|null|undefined} new
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype["new"] = null;

        /**
         * ChestInfo equips.
         * @member {Object.<string,chest.IEquipItem>} equips
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.equips = $util.emptyObject;

        /**
         * ChestInfo fullAttrs.
         * @member {Object.<string,number>} fullAttrs
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.fullAttrs = $util.emptyObject;

        /**
         * ChestInfo amount.
         * @member {number} amount
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.amount = 0;

        /**
         * ChestInfo lv.
         * @member {number} lv
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.lv = 0;

        /**
         * ChestInfo exp.
         * @member {number} exp
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.exp = 0;

        /**
         * ChestInfo dungeonId.
         * @member {number} dungeonId
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.dungeonId = 0;

        /**
         * Creates a new ChestInfo instance using the specified properties.
         * @function create
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.IChestInfo=} [properties] Properties to set
         * @returns {chest.ChestInfo} ChestInfo instance
         */
        ChestInfo.create = function create(properties) {
            return new ChestInfo(properties);
        };

        /**
         * Encodes the specified ChestInfo message. Does not implicitly {@link chest.ChestInfo.verify|verify} messages.
         * @function encode
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.IChestInfo} message ChestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChestInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["new"] != null && Object.hasOwnProperty.call(message, "new"))
                $root.chest.EquipItem.encode(message["new"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.equips != null && Object.hasOwnProperty.call(message, "equips"))
                for (var keys = Object.keys(message.equips), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.chest.EquipItem.encode(message.equips[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.fullAttrs != null && Object.hasOwnProperty.call(message, "fullAttrs"))
                for (var keys = Object.keys(message.fullAttrs), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).int32(message.fullAttrs[keys[i]]).ldelim();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.amount);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.lv);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.exp);
            if (message.dungeonId != null && Object.hasOwnProperty.call(message, "dungeonId"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.dungeonId);
            return writer;
        };

        /**
         * Encodes the specified ChestInfo message, length delimited. Does not implicitly {@link chest.ChestInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.IChestInfo} message ChestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChestInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChestInfo message from the specified reader or buffer.
         * @function decode
         * @memberof chest.ChestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.ChestInfo} ChestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChestInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.ChestInfo(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message["new"] = $root.chest.EquipItem.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (message.equips === $util.emptyObject)
                            message.equips = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.chest.EquipItem.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.equips[key] = value;
                        break;
                    }
                case 3: {
                        if (message.fullAttrs === $util.emptyObject)
                            message.fullAttrs = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = reader.int32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.fullAttrs[key] = value;
                        break;
                    }
                case 4: {
                        message.amount = reader.uint32();
                        break;
                    }
                case 5: {
                        message.lv = reader.uint32();
                        break;
                    }
                case 6: {
                        message.exp = reader.uint32();
                        break;
                    }
                case 7: {
                        message.dungeonId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChestInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.ChestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.ChestInfo} ChestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChestInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChestInfo message.
         * @function verify
         * @memberof chest.ChestInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChestInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["new"] != null && message.hasOwnProperty("new")) {
                var error = $root.chest.EquipItem.verify(message["new"]);
                if (error)
                    return "new." + error;
            }
            if (message.equips != null && message.hasOwnProperty("equips")) {
                if (!$util.isObject(message.equips))
                    return "equips: object expected";
                var key = Object.keys(message.equips);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "equips: integer key{k:uint32} expected";
                    {
                        var error = $root.chest.EquipItem.verify(message.equips[key[i]]);
                        if (error)
                            return "equips." + error;
                    }
                }
            }
            if (message.fullAttrs != null && message.hasOwnProperty("fullAttrs")) {
                if (!$util.isObject(message.fullAttrs))
                    return "fullAttrs: object expected";
                var key = Object.keys(message.fullAttrs);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "fullAttrs: integer key{k:uint32} expected";
                    if (!$util.isInteger(message.fullAttrs[key[i]]))
                        return "fullAttrs: integer{k:uint32} expected";
                }
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                if (!$util.isInteger(message.dungeonId))
                    return "dungeonId: integer expected";
            return null;
        };

        /**
         * Creates a ChestInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.ChestInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.ChestInfo} ChestInfo
         */
        ChestInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.ChestInfo)
                return object;
            var message = new $root.chest.ChestInfo();
            if (object["new"] != null) {
                if (typeof object["new"] !== "object")
                    throw TypeError(".chest.ChestInfo.new: object expected");
                message["new"] = $root.chest.EquipItem.fromObject(object["new"]);
            }
            if (object.equips) {
                if (typeof object.equips !== "object")
                    throw TypeError(".chest.ChestInfo.equips: object expected");
                message.equips = {};
                for (var keys = Object.keys(object.equips), i = 0; i < keys.length; ++i) {
                    if (typeof object.equips[keys[i]] !== "object")
                        throw TypeError(".chest.ChestInfo.equips: object expected");
                    message.equips[keys[i]] = $root.chest.EquipItem.fromObject(object.equips[keys[i]]);
                }
            }
            if (object.fullAttrs) {
                if (typeof object.fullAttrs !== "object")
                    throw TypeError(".chest.ChestInfo.fullAttrs: object expected");
                message.fullAttrs = {};
                for (var keys = Object.keys(object.fullAttrs), i = 0; i < keys.length; ++i)
                    message.fullAttrs[keys[i]] = object.fullAttrs[keys[i]] | 0;
            }
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            if (object.lv != null)
                message.lv = object.lv >>> 0;
            if (object.exp != null)
                message.exp = object.exp >>> 0;
            if (object.dungeonId != null)
                message.dungeonId = object.dungeonId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChestInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.ChestInfo} message ChestInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChestInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.equips = {};
                object.fullAttrs = {};
            }
            if (options.defaults) {
                object["new"] = null;
                object.amount = 0;
                object.lv = 0;
                object.exp = 0;
                object.dungeonId = 0;
            }
            if (message["new"] != null && message.hasOwnProperty("new"))
                object["new"] = $root.chest.EquipItem.toObject(message["new"], options);
            var keys2;
            if (message.equips && (keys2 = Object.keys(message.equips)).length) {
                object.equips = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.equips[keys2[j]] = $root.chest.EquipItem.toObject(message.equips[keys2[j]], options);
            }
            if (message.fullAttrs && (keys2 = Object.keys(message.fullAttrs)).length) {
                object.fullAttrs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.fullAttrs[keys2[j]] = message.fullAttrs[keys2[j]];
            }
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                object.dungeonId = message.dungeonId;
            return object;
        };

        /**
         * Converts this ChestInfo to JSON.
         * @function toJSON
         * @memberof chest.ChestInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChestInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChestInfo
         * @function getTypeUrl
         * @memberof chest.ChestInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChestInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.ChestInfo";
        };

        return ChestInfo;
    })();

    chest.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof chest
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof chest
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {chest.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof chest.c2s_load
         * @static
         * @param {chest.Ic2s_load=} [properties] Properties to set
         * @returns {chest.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link chest.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_load
         * @static
         * @param {chest.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link chest.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_load
         * @static
         * @param {chest.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof chest.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_load)
                return object;
            return new $root.chest.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_load
         * @static
         * @param {chest.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof chest.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof chest.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_load";
        };

        return c2s_load;
    })();

    chest.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof chest
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {chest.IChestInfo|null} [info] s2c_load info
         */

        /**
         * Constructs a new s2c_load.
         * @memberof chest
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {chest.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load info.
         * @member {chest.IChestInfo|null|undefined} info
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.info = null;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof chest.s2c_load
         * @static
         * @param {chest.Is2c_load=} [properties] Properties to set
         * @returns {chest.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link chest.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_load
         * @static
         * @param {chest.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.chest.ChestInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link chest.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_load
         * @static
         * @param {chest.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.info = $root.chest.ChestInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof chest.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.chest.ChestInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_load)
                return object;
            var message = new $root.chest.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".chest.s2c_load.info: object expected");
                message.info = $root.chest.ChestInfo.fromObject(object.info);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_load
         * @static
         * @param {chest.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.info = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.chest.ChestInfo.toObject(message.info, options);
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof chest.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof chest.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_load";
        };

        return s2c_load;
    })();

    chest.c2s_open = (function() {

        /**
         * Properties of a c2s_open.
         * @memberof chest
         * @interface Ic2s_open
         */

        /**
         * Constructs a new c2s_open.
         * @memberof chest
         * @classdesc Represents a c2s_open.
         * @implements Ic2s_open
         * @constructor
         * @param {chest.Ic2s_open=} [properties] Properties to set
         */
        function c2s_open(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_open instance using the specified properties.
         * @function create
         * @memberof chest.c2s_open
         * @static
         * @param {chest.Ic2s_open=} [properties] Properties to set
         * @returns {chest.c2s_open} c2s_open instance
         */
        c2s_open.create = function create(properties) {
            return new c2s_open(properties);
        };

        /**
         * Encodes the specified c2s_open message. Does not implicitly {@link chest.c2s_open.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_open
         * @static
         * @param {chest.Ic2s_open} message c2s_open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_open message, length delimited. Does not implicitly {@link chest.c2s_open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_open
         * @static
         * @param {chest.Ic2s_open} message c2s_open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_open message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_open} c2s_open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_open();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_open} c2s_open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_open message.
         * @function verify
         * @memberof chest.c2s_open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_open} c2s_open
         */
        c2s_open.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_open)
                return object;
            return new $root.chest.c2s_open();
        };

        /**
         * Creates a plain object from a c2s_open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_open
         * @static
         * @param {chest.c2s_open} message c2s_open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_open.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_open to JSON.
         * @function toJSON
         * @memberof chest.c2s_open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_open
         * @function getTypeUrl
         * @memberof chest.c2s_open
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_open.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_open";
        };

        return c2s_open;
    })();

    chest.s2c_open = (function() {

        /**
         * Properties of a s2c_open.
         * @memberof chest
         * @interface Is2c_open
         * @property {number|null} [err] s2c_open err
         * @property {chest.IChestInfo|null} [info] s2c_open info
         */

        /**
         * Constructs a new s2c_open.
         * @memberof chest
         * @classdesc Represents a s2c_open.
         * @implements Is2c_open
         * @constructor
         * @param {chest.Is2c_open=} [properties] Properties to set
         */
        function s2c_open(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_open err.
         * @member {number} err
         * @memberof chest.s2c_open
         * @instance
         */
        s2c_open.prototype.err = 0;

        /**
         * s2c_open info.
         * @member {chest.IChestInfo|null|undefined} info
         * @memberof chest.s2c_open
         * @instance
         */
        s2c_open.prototype.info = null;

        /**
         * Creates a new s2c_open instance using the specified properties.
         * @function create
         * @memberof chest.s2c_open
         * @static
         * @param {chest.Is2c_open=} [properties] Properties to set
         * @returns {chest.s2c_open} s2c_open instance
         */
        s2c_open.create = function create(properties) {
            return new s2c_open(properties);
        };

        /**
         * Encodes the specified s2c_open message. Does not implicitly {@link chest.s2c_open.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_open
         * @static
         * @param {chest.Is2c_open} message s2c_open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_open.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.chest.ChestInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_open message, length delimited. Does not implicitly {@link chest.s2c_open.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_open
         * @static
         * @param {chest.Is2c_open} message s2c_open message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_open.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_open message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_open} s2c_open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_open.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_open();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.info = $root.chest.ChestInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_open message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_open
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_open} s2c_open
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_open.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_open message.
         * @function verify
         * @memberof chest.s2c_open
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_open.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.chest.ChestInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_open message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_open
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_open} s2c_open
         */
        s2c_open.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_open)
                return object;
            var message = new $root.chest.s2c_open();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".chest.s2c_open.info: object expected");
                message.info = $root.chest.ChestInfo.fromObject(object.info);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_open message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_open
         * @static
         * @param {chest.s2c_open} message s2c_open
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_open.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.info = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.chest.ChestInfo.toObject(message.info, options);
            return object;
        };

        /**
         * Converts this s2c_open to JSON.
         * @function toJSON
         * @memberof chest.s2c_open
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_open.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_open
         * @function getTypeUrl
         * @memberof chest.s2c_open
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_open.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_open";
        };

        return s2c_open;
    })();

    chest.c2s_replace = (function() {

        /**
         * Properties of a c2s_replace.
         * @memberof chest
         * @interface Ic2s_replace
         */

        /**
         * Constructs a new c2s_replace.
         * @memberof chest
         * @classdesc Represents a c2s_replace.
         * @implements Ic2s_replace
         * @constructor
         * @param {chest.Ic2s_replace=} [properties] Properties to set
         */
        function c2s_replace(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_replace instance using the specified properties.
         * @function create
         * @memberof chest.c2s_replace
         * @static
         * @param {chest.Ic2s_replace=} [properties] Properties to set
         * @returns {chest.c2s_replace} c2s_replace instance
         */
        c2s_replace.create = function create(properties) {
            return new c2s_replace(properties);
        };

        /**
         * Encodes the specified c2s_replace message. Does not implicitly {@link chest.c2s_replace.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_replace
         * @static
         * @param {chest.Ic2s_replace} message c2s_replace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_replace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_replace message, length delimited. Does not implicitly {@link chest.c2s_replace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_replace
         * @static
         * @param {chest.Ic2s_replace} message c2s_replace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_replace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_replace message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_replace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_replace} c2s_replace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_replace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_replace();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_replace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_replace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_replace} c2s_replace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_replace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_replace message.
         * @function verify
         * @memberof chest.c2s_replace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_replace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_replace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_replace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_replace} c2s_replace
         */
        c2s_replace.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_replace)
                return object;
            return new $root.chest.c2s_replace();
        };

        /**
         * Creates a plain object from a c2s_replace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_replace
         * @static
         * @param {chest.c2s_replace} message c2s_replace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_replace.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_replace to JSON.
         * @function toJSON
         * @memberof chest.c2s_replace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_replace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_replace
         * @function getTypeUrl
         * @memberof chest.c2s_replace
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_replace.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_replace";
        };

        return c2s_replace;
    })();

    chest.s2c_replace = (function() {

        /**
         * Properties of a s2c_replace.
         * @memberof chest
         * @interface Is2c_replace
         * @property {number|null} [err] s2c_replace err
         * @property {chest.IChestInfo|null} [info] s2c_replace info
         */

        /**
         * Constructs a new s2c_replace.
         * @memberof chest
         * @classdesc Represents a s2c_replace.
         * @implements Is2c_replace
         * @constructor
         * @param {chest.Is2c_replace=} [properties] Properties to set
         */
        function s2c_replace(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_replace err.
         * @member {number} err
         * @memberof chest.s2c_replace
         * @instance
         */
        s2c_replace.prototype.err = 0;

        /**
         * s2c_replace info.
         * @member {chest.IChestInfo|null|undefined} info
         * @memberof chest.s2c_replace
         * @instance
         */
        s2c_replace.prototype.info = null;

        /**
         * Creates a new s2c_replace instance using the specified properties.
         * @function create
         * @memberof chest.s2c_replace
         * @static
         * @param {chest.Is2c_replace=} [properties] Properties to set
         * @returns {chest.s2c_replace} s2c_replace instance
         */
        s2c_replace.create = function create(properties) {
            return new s2c_replace(properties);
        };

        /**
         * Encodes the specified s2c_replace message. Does not implicitly {@link chest.s2c_replace.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_replace
         * @static
         * @param {chest.Is2c_replace} message s2c_replace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_replace.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.chest.ChestInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_replace message, length delimited. Does not implicitly {@link chest.s2c_replace.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_replace
         * @static
         * @param {chest.Is2c_replace} message s2c_replace message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_replace.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_replace message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_replace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_replace} s2c_replace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_replace.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_replace();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.info = $root.chest.ChestInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_replace message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_replace
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_replace} s2c_replace
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_replace.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_replace message.
         * @function verify
         * @memberof chest.s2c_replace
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_replace.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.chest.ChestInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_replace message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_replace
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_replace} s2c_replace
         */
        s2c_replace.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_replace)
                return object;
            var message = new $root.chest.s2c_replace();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".chest.s2c_replace.info: object expected");
                message.info = $root.chest.ChestInfo.fromObject(object.info);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_replace message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_replace
         * @static
         * @param {chest.s2c_replace} message s2c_replace
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_replace.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.info = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.chest.ChestInfo.toObject(message.info, options);
            return object;
        };

        /**
         * Converts this s2c_replace to JSON.
         * @function toJSON
         * @memberof chest.s2c_replace
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_replace.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_replace
         * @function getTypeUrl
         * @memberof chest.s2c_replace
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_replace.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_replace";
        };

        return s2c_replace;
    })();

    chest.c2s_abandon = (function() {

        /**
         * Properties of a c2s_abandon.
         * @memberof chest
         * @interface Ic2s_abandon
         */

        /**
         * Constructs a new c2s_abandon.
         * @memberof chest
         * @classdesc Represents a c2s_abandon.
         * @implements Ic2s_abandon
         * @constructor
         * @param {chest.Ic2s_abandon=} [properties] Properties to set
         */
        function c2s_abandon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_abandon instance using the specified properties.
         * @function create
         * @memberof chest.c2s_abandon
         * @static
         * @param {chest.Ic2s_abandon=} [properties] Properties to set
         * @returns {chest.c2s_abandon} c2s_abandon instance
         */
        c2s_abandon.create = function create(properties) {
            return new c2s_abandon(properties);
        };

        /**
         * Encodes the specified c2s_abandon message. Does not implicitly {@link chest.c2s_abandon.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_abandon
         * @static
         * @param {chest.Ic2s_abandon} message c2s_abandon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_abandon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_abandon message, length delimited. Does not implicitly {@link chest.c2s_abandon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_abandon
         * @static
         * @param {chest.Ic2s_abandon} message c2s_abandon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_abandon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_abandon message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_abandon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_abandon} c2s_abandon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_abandon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_abandon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_abandon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_abandon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_abandon} c2s_abandon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_abandon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_abandon message.
         * @function verify
         * @memberof chest.c2s_abandon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_abandon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_abandon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_abandon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_abandon} c2s_abandon
         */
        c2s_abandon.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_abandon)
                return object;
            return new $root.chest.c2s_abandon();
        };

        /**
         * Creates a plain object from a c2s_abandon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_abandon
         * @static
         * @param {chest.c2s_abandon} message c2s_abandon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_abandon.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_abandon to JSON.
         * @function toJSON
         * @memberof chest.c2s_abandon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_abandon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_abandon
         * @function getTypeUrl
         * @memberof chest.c2s_abandon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_abandon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_abandon";
        };

        return c2s_abandon;
    })();

    chest.s2c_abandon = (function() {

        /**
         * Properties of a s2c_abandon.
         * @memberof chest
         * @interface Is2c_abandon
         * @property {number|null} [err] s2c_abandon err
         */

        /**
         * Constructs a new s2c_abandon.
         * @memberof chest
         * @classdesc Represents a s2c_abandon.
         * @implements Is2c_abandon
         * @constructor
         * @param {chest.Is2c_abandon=} [properties] Properties to set
         */
        function s2c_abandon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_abandon err.
         * @member {number} err
         * @memberof chest.s2c_abandon
         * @instance
         */
        s2c_abandon.prototype.err = 0;

        /**
         * Creates a new s2c_abandon instance using the specified properties.
         * @function create
         * @memberof chest.s2c_abandon
         * @static
         * @param {chest.Is2c_abandon=} [properties] Properties to set
         * @returns {chest.s2c_abandon} s2c_abandon instance
         */
        s2c_abandon.create = function create(properties) {
            return new s2c_abandon(properties);
        };

        /**
         * Encodes the specified s2c_abandon message. Does not implicitly {@link chest.s2c_abandon.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_abandon
         * @static
         * @param {chest.Is2c_abandon} message s2c_abandon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_abandon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_abandon message, length delimited. Does not implicitly {@link chest.s2c_abandon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_abandon
         * @static
         * @param {chest.Is2c_abandon} message s2c_abandon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_abandon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_abandon message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_abandon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_abandon} s2c_abandon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_abandon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_abandon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_abandon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_abandon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_abandon} s2c_abandon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_abandon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_abandon message.
         * @function verify
         * @memberof chest.s2c_abandon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_abandon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_abandon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_abandon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_abandon} s2c_abandon
         */
        s2c_abandon.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_abandon)
                return object;
            var message = new $root.chest.s2c_abandon();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_abandon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_abandon
         * @static
         * @param {chest.s2c_abandon} message s2c_abandon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_abandon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_abandon to JSON.
         * @function toJSON
         * @memberof chest.s2c_abandon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_abandon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_abandon
         * @function getTypeUrl
         * @memberof chest.s2c_abandon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_abandon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_abandon";
        };

        return s2c_abandon;
    })();

    chest.c2s_challenge_dungeon = (function() {

        /**
         * Properties of a c2s_challenge_dungeon.
         * @memberof chest
         * @interface Ic2s_challenge_dungeon
         * @property {number|null} [dungeonId] c2s_challenge_dungeon dungeonId
         */

        /**
         * Constructs a new c2s_challenge_dungeon.
         * @memberof chest
         * @classdesc Represents a c2s_challenge_dungeon.
         * @implements Ic2s_challenge_dungeon
         * @constructor
         * @param {chest.Ic2s_challenge_dungeon=} [properties] Properties to set
         */
        function c2s_challenge_dungeon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_challenge_dungeon dungeonId.
         * @member {number} dungeonId
         * @memberof chest.c2s_challenge_dungeon
         * @instance
         */
        c2s_challenge_dungeon.prototype.dungeonId = 0;

        /**
         * Creates a new c2s_challenge_dungeon instance using the specified properties.
         * @function create
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {chest.Ic2s_challenge_dungeon=} [properties] Properties to set
         * @returns {chest.c2s_challenge_dungeon} c2s_challenge_dungeon instance
         */
        c2s_challenge_dungeon.create = function create(properties) {
            return new c2s_challenge_dungeon(properties);
        };

        /**
         * Encodes the specified c2s_challenge_dungeon message. Does not implicitly {@link chest.c2s_challenge_dungeon.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {chest.Ic2s_challenge_dungeon} message c2s_challenge_dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_challenge_dungeon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dungeonId != null && Object.hasOwnProperty.call(message, "dungeonId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.dungeonId);
            return writer;
        };

        /**
         * Encodes the specified c2s_challenge_dungeon message, length delimited. Does not implicitly {@link chest.c2s_challenge_dungeon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {chest.Ic2s_challenge_dungeon} message c2s_challenge_dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_challenge_dungeon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_challenge_dungeon message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_challenge_dungeon} c2s_challenge_dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_challenge_dungeon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_challenge_dungeon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dungeonId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_challenge_dungeon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_challenge_dungeon} c2s_challenge_dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_challenge_dungeon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_challenge_dungeon message.
         * @function verify
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_challenge_dungeon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                if (!$util.isInteger(message.dungeonId))
                    return "dungeonId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_challenge_dungeon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_challenge_dungeon} c2s_challenge_dungeon
         */
        c2s_challenge_dungeon.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_challenge_dungeon)
                return object;
            var message = new $root.chest.c2s_challenge_dungeon();
            if (object.dungeonId != null)
                message.dungeonId = object.dungeonId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_challenge_dungeon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {chest.c2s_challenge_dungeon} message c2s_challenge_dungeon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_challenge_dungeon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.dungeonId = 0;
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                object.dungeonId = message.dungeonId;
            return object;
        };

        /**
         * Converts this c2s_challenge_dungeon to JSON.
         * @function toJSON
         * @memberof chest.c2s_challenge_dungeon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_challenge_dungeon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_challenge_dungeon
         * @function getTypeUrl
         * @memberof chest.c2s_challenge_dungeon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_challenge_dungeon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_challenge_dungeon";
        };

        return c2s_challenge_dungeon;
    })();

    chest.s2c_challenge_dungeon = (function() {

        /**
         * Properties of a s2c_challenge_dungeon.
         * @memberof chest
         * @interface Is2c_challenge_dungeon
         * @property {number|null} [err] s2c_challenge_dungeon err
         * @property {number|null} [warUid] s2c_challenge_dungeon warUid
         */

        /**
         * Constructs a new s2c_challenge_dungeon.
         * @memberof chest
         * @classdesc Represents a s2c_challenge_dungeon.
         * @implements Is2c_challenge_dungeon
         * @constructor
         * @param {chest.Is2c_challenge_dungeon=} [properties] Properties to set
         */
        function s2c_challenge_dungeon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_challenge_dungeon err.
         * @member {number} err
         * @memberof chest.s2c_challenge_dungeon
         * @instance
         */
        s2c_challenge_dungeon.prototype.err = 0;

        /**
         * s2c_challenge_dungeon warUid.
         * @member {number} warUid
         * @memberof chest.s2c_challenge_dungeon
         * @instance
         */
        s2c_challenge_dungeon.prototype.warUid = 0;

        /**
         * Creates a new s2c_challenge_dungeon instance using the specified properties.
         * @function create
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {chest.Is2c_challenge_dungeon=} [properties] Properties to set
         * @returns {chest.s2c_challenge_dungeon} s2c_challenge_dungeon instance
         */
        s2c_challenge_dungeon.create = function create(properties) {
            return new s2c_challenge_dungeon(properties);
        };

        /**
         * Encodes the specified s2c_challenge_dungeon message. Does not implicitly {@link chest.s2c_challenge_dungeon.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {chest.Is2c_challenge_dungeon} message s2c_challenge_dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_challenge_dungeon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.warUid != null && Object.hasOwnProperty.call(message, "warUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.warUid);
            return writer;
        };

        /**
         * Encodes the specified s2c_challenge_dungeon message, length delimited. Does not implicitly {@link chest.s2c_challenge_dungeon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {chest.Is2c_challenge_dungeon} message s2c_challenge_dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_challenge_dungeon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_challenge_dungeon message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_challenge_dungeon} s2c_challenge_dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_challenge_dungeon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_challenge_dungeon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.warUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_challenge_dungeon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_challenge_dungeon} s2c_challenge_dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_challenge_dungeon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_challenge_dungeon message.
         * @function verify
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_challenge_dungeon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.warUid != null && message.hasOwnProperty("warUid"))
                if (!$util.isInteger(message.warUid))
                    return "warUid: integer expected";
            return null;
        };

        /**
         * Creates a s2c_challenge_dungeon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_challenge_dungeon} s2c_challenge_dungeon
         */
        s2c_challenge_dungeon.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_challenge_dungeon)
                return object;
            var message = new $root.chest.s2c_challenge_dungeon();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.warUid != null)
                message.warUid = object.warUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_challenge_dungeon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {chest.s2c_challenge_dungeon} message s2c_challenge_dungeon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_challenge_dungeon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.warUid = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.warUid != null && message.hasOwnProperty("warUid"))
                object.warUid = message.warUid;
            return object;
        };

        /**
         * Converts this s2c_challenge_dungeon to JSON.
         * @function toJSON
         * @memberof chest.s2c_challenge_dungeon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_challenge_dungeon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_challenge_dungeon
         * @function getTypeUrl
         * @memberof chest.s2c_challenge_dungeon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_challenge_dungeon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_challenge_dungeon";
        };

        return s2c_challenge_dungeon;
    })();

    return chest;
})();

$root.dungeon = (function() {

    /**
     * Namespace dungeon.
     * @exports dungeon
     * @namespace
     */
    var dungeon = {};

    dungeon.Dungeon = (function() {

        /**
         * Properties of a Dungeon.
         * @memberof dungeon
         * @interface IDungeon
         * @property {number|null} [star] Dungeon star
         */

        /**
         * Constructs a new Dungeon.
         * @memberof dungeon
         * @classdesc Represents a Dungeon.
         * @implements IDungeon
         * @constructor
         * @param {dungeon.IDungeon=} [properties] Properties to set
         */
        function Dungeon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dungeon star.
         * @member {number} star
         * @memberof dungeon.Dungeon
         * @instance
         */
        Dungeon.prototype.star = 0;

        /**
         * Creates a new Dungeon instance using the specified properties.
         * @function create
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.IDungeon=} [properties] Properties to set
         * @returns {dungeon.Dungeon} Dungeon instance
         */
        Dungeon.create = function create(properties) {
            return new Dungeon(properties);
        };

        /**
         * Encodes the specified Dungeon message. Does not implicitly {@link dungeon.Dungeon.verify|verify} messages.
         * @function encode
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.IDungeon} message Dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dungeon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.star);
            return writer;
        };

        /**
         * Encodes the specified Dungeon message, length delimited. Does not implicitly {@link dungeon.Dungeon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.IDungeon} message Dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dungeon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dungeon message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.Dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.Dungeon} Dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dungeon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.Dungeon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.star = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dungeon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.Dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.Dungeon} Dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dungeon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dungeon message.
         * @function verify
         * @memberof dungeon.Dungeon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dungeon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            return null;
        };

        /**
         * Creates a Dungeon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.Dungeon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.Dungeon} Dungeon
         */
        Dungeon.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.Dungeon)
                return object;
            var message = new $root.dungeon.Dungeon();
            if (object.star != null)
                message.star = object.star >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Dungeon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.Dungeon} message Dungeon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dungeon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.star = 0;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            return object;
        };

        /**
         * Converts this Dungeon to JSON.
         * @function toJSON
         * @memberof dungeon.Dungeon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dungeon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Dungeon
         * @function getTypeUrl
         * @memberof dungeon.Dungeon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Dungeon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.Dungeon";
        };

        return Dungeon;
    })();

    dungeon.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof dungeon
         * @interface Ic2s_load
         * @property {number|null} [dungeonType] c2s_load dungeonType
         */

        /**
         * Constructs a new c2s_load.
         * @memberof dungeon
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {dungeon.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load dungeonType.
         * @member {number} dungeonType
         * @memberof dungeon.c2s_load
         * @instance
         */
        c2s_load.prototype.dungeonType = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.Ic2s_load=} [properties] Properties to set
         * @returns {dungeon.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link dungeon.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dungeonType != null && Object.hasOwnProperty.call(message, "dungeonType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.dungeonType);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link dungeon.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dungeonType = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof dungeon.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dungeonType != null && message.hasOwnProperty("dungeonType"))
                if (!$util.isInteger(message.dungeonType))
                    return "dungeonType: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.c2s_load)
                return object;
            var message = new $root.dungeon.c2s_load();
            if (object.dungeonType != null)
                message.dungeonType = object.dungeonType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.dungeonType = 0;
            if (message.dungeonType != null && message.hasOwnProperty("dungeonType"))
                object.dungeonType = message.dungeonType;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof dungeon.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof dungeon.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.c2s_load";
        };

        return c2s_load;
    })();

    dungeon.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof dungeon
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<dungeon.IDungeon>|null} [dungeonList] s2c_load dungeonList
         */

        /**
         * Constructs a new s2c_load.
         * @memberof dungeon
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {dungeon.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.dungeonList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof dungeon.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load dungeonList.
         * @member {Array.<dungeon.IDungeon>} dungeonList
         * @memberof dungeon.s2c_load
         * @instance
         */
        s2c_load.prototype.dungeonList = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.Is2c_load=} [properties] Properties to set
         * @returns {dungeon.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link dungeon.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.dungeonList != null && message.dungeonList.length)
                for (var i = 0; i < message.dungeonList.length; ++i)
                    $root.dungeon.Dungeon.encode(message.dungeonList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link dungeon.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.dungeonList && message.dungeonList.length))
                            message.dungeonList = [];
                        message.dungeonList.push($root.dungeon.Dungeon.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof dungeon.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.dungeonList != null && message.hasOwnProperty("dungeonList")) {
                if (!Array.isArray(message.dungeonList))
                    return "dungeonList: array expected";
                for (var i = 0; i < message.dungeonList.length; ++i) {
                    var error = $root.dungeon.Dungeon.verify(message.dungeonList[i]);
                    if (error)
                        return "dungeonList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.s2c_load)
                return object;
            var message = new $root.dungeon.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.dungeonList) {
                if (!Array.isArray(object.dungeonList))
                    throw TypeError(".dungeon.s2c_load.dungeonList: array expected");
                message.dungeonList = [];
                for (var i = 0; i < object.dungeonList.length; ++i) {
                    if (typeof object.dungeonList[i] !== "object")
                        throw TypeError(".dungeon.s2c_load.dungeonList: object expected");
                    message.dungeonList[i] = $root.dungeon.Dungeon.fromObject(object.dungeonList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dungeonList = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.dungeonList && message.dungeonList.length) {
                object.dungeonList = [];
                for (var j = 0; j < message.dungeonList.length; ++j)
                    object.dungeonList[j] = $root.dungeon.Dungeon.toObject(message.dungeonList[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof dungeon.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof dungeon.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.s2c_load";
        };

        return s2c_load;
    })();

    return dungeon;
})();

$root.hero = (function() {

    /**
     * Namespace hero.
     * @exports hero
     * @namespace
     */
    var hero = {};

    hero.Hero = (function() {

        /**
         * Properties of a Hero.
         * @memberof hero
         * @interface IHero
         * @property {number|null} [uid] Hero uid
         * @property {number|null} [id] Hero id
         */

        /**
         * Constructs a new Hero.
         * @memberof hero
         * @classdesc Represents a Hero.
         * @implements IHero
         * @constructor
         * @param {hero.IHero=} [properties] Properties to set
         */
        function Hero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hero uid.
         * @member {number} uid
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.uid = 0;

        /**
         * Hero id.
         * @member {number} id
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.id = 0;

        /**
         * Creates a new Hero instance using the specified properties.
         * @function create
         * @memberof hero.Hero
         * @static
         * @param {hero.IHero=} [properties] Properties to set
         * @returns {hero.Hero} Hero instance
         */
        Hero.create = function create(properties) {
            return new Hero(properties);
        };

        /**
         * Encodes the specified Hero message. Does not implicitly {@link hero.Hero.verify|verify} messages.
         * @function encode
         * @memberof hero.Hero
         * @static
         * @param {hero.IHero} message Hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified Hero message, length delimited. Does not implicitly {@link hero.Hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hero.Hero
         * @static
         * @param {hero.IHero} message Hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hero message from the specified reader or buffer.
         * @function decode
         * @memberof hero.Hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hero.Hero} Hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hero.Hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hero.Hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hero.Hero} Hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hero message.
         * @function verify
         * @memberof hero.Hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a Hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hero.Hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hero.Hero} Hero
         */
        Hero.fromObject = function fromObject(object) {
            if (object instanceof $root.hero.Hero)
                return object;
            var message = new $root.hero.Hero();
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hero.Hero
         * @static
         * @param {hero.Hero} message Hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uid = 0;
                object.id = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this Hero to JSON.
         * @function toJSON
         * @memberof hero.Hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Hero
         * @function getTypeUrl
         * @memberof hero.Hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hero.Hero";
        };

        return Hero;
    })();

    hero.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof hero
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof hero
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {hero.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof hero.c2s_load
         * @static
         * @param {hero.Ic2s_load=} [properties] Properties to set
         * @returns {hero.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link hero.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof hero.c2s_load
         * @static
         * @param {hero.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link hero.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hero.c2s_load
         * @static
         * @param {hero.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof hero.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hero.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hero.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hero.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hero.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof hero.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hero.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hero.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.hero.c2s_load)
                return object;
            return new $root.hero.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hero.c2s_load
         * @static
         * @param {hero.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof hero.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof hero.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hero.c2s_load";
        };

        return c2s_load;
    })();

    hero.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof hero
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<hero.IHero>|null} [heroList] s2c_load heroList
         */

        /**
         * Constructs a new s2c_load.
         * @memberof hero
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {hero.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.heroList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof hero.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load heroList.
         * @member {Array.<hero.IHero>} heroList
         * @memberof hero.s2c_load
         * @instance
         */
        s2c_load.prototype.heroList = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof hero.s2c_load
         * @static
         * @param {hero.Is2c_load=} [properties] Properties to set
         * @returns {hero.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link hero.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof hero.s2c_load
         * @static
         * @param {hero.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.heroList != null && message.heroList.length)
                for (var i = 0; i < message.heroList.length; ++i)
                    $root.hero.Hero.encode(message.heroList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link hero.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hero.s2c_load
         * @static
         * @param {hero.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof hero.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hero.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hero.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.heroList && message.heroList.length))
                            message.heroList = [];
                        message.heroList.push($root.hero.Hero.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hero.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hero.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof hero.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.heroList != null && message.hasOwnProperty("heroList")) {
                if (!Array.isArray(message.heroList))
                    return "heroList: array expected";
                for (var i = 0; i < message.heroList.length; ++i) {
                    var error = $root.hero.Hero.verify(message.heroList[i]);
                    if (error)
                        return "heroList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hero.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hero.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.hero.s2c_load)
                return object;
            var message = new $root.hero.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.heroList) {
                if (!Array.isArray(object.heroList))
                    throw TypeError(".hero.s2c_load.heroList: array expected");
                message.heroList = [];
                for (var i = 0; i < object.heroList.length; ++i) {
                    if (typeof object.heroList[i] !== "object")
                        throw TypeError(".hero.s2c_load.heroList: object expected");
                    message.heroList[i] = $root.hero.Hero.fromObject(object.heroList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hero.s2c_load
         * @static
         * @param {hero.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroList = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.heroList && message.heroList.length) {
                object.heroList = [];
                for (var j = 0; j < message.heroList.length; ++j)
                    object.heroList[j] = $root.hero.Hero.toObject(message.heroList[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof hero.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof hero.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hero.s2c_load";
        };

        return s2c_load;
    })();

    return hero;
})();

$root.mail = (function() {

    /**
     * Namespace mail.
     * @exports mail
     * @namespace
     */
    var mail = {};

    mail.MailInfo = (function() {

        /**
         * Properties of a MailInfo.
         * @memberof mail
         * @interface IMailInfo
         * @property {number|null} [uid] MailInfo uid
         * @property {number|null} [id] MailInfo id
         * @property {number|null} [time] MailInfo time
         * @property {number|null} [state] MailInfo state
         * @property {string|null} [title] MailInfo title
         * @property {string|null} [content] MailInfo content
         * @property {Array.<bag.IItem>|null} [reward] MailInfo reward
         * @property {number|null} [expiredSec] MailInfo expiredSec
         */

        /**
         * Constructs a new MailInfo.
         * @memberof mail
         * @classdesc Represents a MailInfo.
         * @implements IMailInfo
         * @constructor
         * @param {mail.IMailInfo=} [properties] Properties to set
         */
        function MailInfo(properties) {
            this.reward = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailInfo uid.
         * @member {number} uid
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.uid = 0;

        /**
         * MailInfo id.
         * @member {number} id
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.id = 0;

        /**
         * MailInfo time.
         * @member {number} time
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.time = 0;

        /**
         * MailInfo state.
         * @member {number} state
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.state = 0;

        /**
         * MailInfo title.
         * @member {string} title
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.title = "";

        /**
         * MailInfo content.
         * @member {string} content
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.content = "";

        /**
         * MailInfo reward.
         * @member {Array.<bag.IItem>} reward
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.reward = $util.emptyArray;

        /**
         * MailInfo expiredSec.
         * @member {number} expiredSec
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.expiredSec = 0;

        /**
         * Creates a new MailInfo instance using the specified properties.
         * @function create
         * @memberof mail.MailInfo
         * @static
         * @param {mail.IMailInfo=} [properties] Properties to set
         * @returns {mail.MailInfo} MailInfo instance
         */
        MailInfo.create = function create(properties) {
            return new MailInfo(properties);
        };

        /**
         * Encodes the specified MailInfo message. Does not implicitly {@link mail.MailInfo.verify|verify} messages.
         * @function encode
         * @memberof mail.MailInfo
         * @static
         * @param {mail.IMailInfo} message MailInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.time);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.state);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.title);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.content);
            if (message.reward != null && message.reward.length)
                for (var i = 0; i < message.reward.length; ++i)
                    $root.bag.Item.encode(message.reward[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.expiredSec != null && Object.hasOwnProperty.call(message, "expiredSec"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expiredSec);
            return writer;
        };

        /**
         * Encodes the specified MailInfo message, length delimited. Does not implicitly {@link mail.MailInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.MailInfo
         * @static
         * @param {mail.IMailInfo} message MailInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mail.MailInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.MailInfo} MailInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.MailInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                case 3: {
                        message.time = reader.uint32();
                        break;
                    }
                case 4: {
                        message.state = reader.uint32();
                        break;
                    }
                case 5: {
                        message.title = reader.string();
                        break;
                    }
                case 6: {
                        message.content = reader.string();
                        break;
                    }
                case 7: {
                        if (!(message.reward && message.reward.length))
                            message.reward = [];
                        message.reward.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.expiredSec = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.MailInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.MailInfo} MailInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailInfo message.
         * @function verify
         * @memberof mail.MailInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                if (!Array.isArray(message.reward))
                    return "reward: array expected";
                for (var i = 0; i < message.reward.length; ++i) {
                    var error = $root.bag.Item.verify(message.reward[i]);
                    if (error)
                        return "reward." + error;
                }
            }
            if (message.expiredSec != null && message.hasOwnProperty("expiredSec"))
                if (!$util.isInteger(message.expiredSec))
                    return "expiredSec: integer expected";
            return null;
        };

        /**
         * Creates a MailInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.MailInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.MailInfo} MailInfo
         */
        MailInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.MailInfo)
                return object;
            var message = new $root.mail.MailInfo();
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.time != null)
                message.time = object.time >>> 0;
            if (object.state != null)
                message.state = object.state >>> 0;
            if (object.title != null)
                message.title = String(object.title);
            if (object.content != null)
                message.content = String(object.content);
            if (object.reward) {
                if (!Array.isArray(object.reward))
                    throw TypeError(".mail.MailInfo.reward: array expected");
                message.reward = [];
                for (var i = 0; i < object.reward.length; ++i) {
                    if (typeof object.reward[i] !== "object")
                        throw TypeError(".mail.MailInfo.reward: object expected");
                    message.reward[i] = $root.bag.Item.fromObject(object.reward[i]);
                }
            }
            if (object.expiredSec != null)
                message.expiredSec = object.expiredSec >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MailInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.MailInfo
         * @static
         * @param {mail.MailInfo} message MailInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reward = [];
            if (options.defaults) {
                object.uid = 0;
                object.id = 0;
                object.time = 0;
                object.state = 0;
                object.title = "";
                object.content = "";
                object.expiredSec = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.reward && message.reward.length) {
                object.reward = [];
                for (var j = 0; j < message.reward.length; ++j)
                    object.reward[j] = $root.bag.Item.toObject(message.reward[j], options);
            }
            if (message.expiredSec != null && message.hasOwnProperty("expiredSec"))
                object.expiredSec = message.expiredSec;
            return object;
        };

        /**
         * Converts this MailInfo to JSON.
         * @function toJSON
         * @memberof mail.MailInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MailInfo
         * @function getTypeUrl
         * @memberof mail.MailInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MailInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.MailInfo";
        };

        return MailInfo;
    })();

    mail.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof mail
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof mail
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {mail.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof mail.c2s_load
         * @static
         * @param {mail.Ic2s_load=} [properties] Properties to set
         * @returns {mail.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link mail.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_load
         * @static
         * @param {mail.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link mail.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_load
         * @static
         * @param {mail.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof mail.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_load)
                return object;
            return new $root.mail.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_load
         * @static
         * @param {mail.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof mail.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof mail.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_load";
        };

        return c2s_load;
    })();

    mail.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof mail
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<mail.IMailInfo>|null} [mails] s2c_load mails
         */

        /**
         * Constructs a new s2c_load.
         * @memberof mail
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {mail.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof mail.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load mails.
         * @member {Array.<mail.IMailInfo>} mails
         * @memberof mail.s2c_load
         * @instance
         */
        s2c_load.prototype.mails = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof mail.s2c_load
         * @static
         * @param {mail.Is2c_load=} [properties] Properties to set
         * @returns {mail.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link mail.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_load
         * @static
         * @param {mail.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.mails != null && message.mails.length)
                for (var i = 0; i < message.mails.length; ++i)
                    $root.mail.MailInfo.encode(message.mails[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link mail.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_load
         * @static
         * @param {mail.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.mails && message.mails.length))
                            message.mails = [];
                        message.mails.push($root.mail.MailInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof mail.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.mails != null && message.hasOwnProperty("mails")) {
                if (!Array.isArray(message.mails))
                    return "mails: array expected";
                for (var i = 0; i < message.mails.length; ++i) {
                    var error = $root.mail.MailInfo.verify(message.mails[i]);
                    if (error)
                        return "mails." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_load)
                return object;
            var message = new $root.mail.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.mails) {
                if (!Array.isArray(object.mails))
                    throw TypeError(".mail.s2c_load.mails: array expected");
                message.mails = [];
                for (var i = 0; i < object.mails.length; ++i) {
                    if (typeof object.mails[i] !== "object")
                        throw TypeError(".mail.s2c_load.mails: object expected");
                    message.mails[i] = $root.mail.MailInfo.fromObject(object.mails[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_load
         * @static
         * @param {mail.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mails = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.mails && message.mails.length) {
                object.mails = [];
                for (var j = 0; j < message.mails.length; ++j)
                    object.mails[j] = $root.mail.MailInfo.toObject(message.mails[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof mail.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof mail.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_load";
        };

        return s2c_load;
    })();

    mail.c2s_read = (function() {

        /**
         * Properties of a c2s_read.
         * @memberof mail
         * @interface Ic2s_read
         * @property {Array.<number>|null} [mailUids] c2s_read mailUids
         */

        /**
         * Constructs a new c2s_read.
         * @memberof mail
         * @classdesc Represents a c2s_read.
         * @implements Ic2s_read
         * @constructor
         * @param {mail.Ic2s_read=} [properties] Properties to set
         */
        function c2s_read(properties) {
            this.mailUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_read mailUids.
         * @member {Array.<number>} mailUids
         * @memberof mail.c2s_read
         * @instance
         */
        c2s_read.prototype.mailUids = $util.emptyArray;

        /**
         * Creates a new c2s_read instance using the specified properties.
         * @function create
         * @memberof mail.c2s_read
         * @static
         * @param {mail.Ic2s_read=} [properties] Properties to set
         * @returns {mail.c2s_read} c2s_read instance
         */
        c2s_read.create = function create(properties) {
            return new c2s_read(properties);
        };

        /**
         * Encodes the specified c2s_read message. Does not implicitly {@link mail.c2s_read.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_read
         * @static
         * @param {mail.Ic2s_read} message c2s_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_read.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailUids != null && message.mailUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mailUids.length; ++i)
                    writer.uint32(message.mailUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_read message, length delimited. Does not implicitly {@link mail.c2s_read.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_read
         * @static
         * @param {mail.Ic2s_read} message c2s_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_read.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_read message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_read} c2s_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_read.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_read();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mailUids && message.mailUids.length))
                            message.mailUids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.mailUids.push(reader.uint32());
                        } else
                            message.mailUids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_read message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_read} c2s_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_read.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_read message.
         * @function verify
         * @memberof mail.c2s_read
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_read.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailUids != null && message.hasOwnProperty("mailUids")) {
                if (!Array.isArray(message.mailUids))
                    return "mailUids: array expected";
                for (var i = 0; i < message.mailUids.length; ++i)
                    if (!$util.isInteger(message.mailUids[i]))
                        return "mailUids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_read message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_read
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_read} c2s_read
         */
        c2s_read.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_read)
                return object;
            var message = new $root.mail.c2s_read();
            if (object.mailUids) {
                if (!Array.isArray(object.mailUids))
                    throw TypeError(".mail.c2s_read.mailUids: array expected");
                message.mailUids = [];
                for (var i = 0; i < object.mailUids.length; ++i)
                    message.mailUids[i] = object.mailUids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_read message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_read
         * @static
         * @param {mail.c2s_read} message c2s_read
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_read.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailUids = [];
            if (message.mailUids && message.mailUids.length) {
                object.mailUids = [];
                for (var j = 0; j < message.mailUids.length; ++j)
                    object.mailUids[j] = message.mailUids[j];
            }
            return object;
        };

        /**
         * Converts this c2s_read to JSON.
         * @function toJSON
         * @memberof mail.c2s_read
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_read.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_read
         * @function getTypeUrl
         * @memberof mail.c2s_read
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_read.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_read";
        };

        return c2s_read;
    })();

    mail.s2c_read = (function() {

        /**
         * Properties of a s2c_read.
         * @memberof mail
         * @interface Is2c_read
         * @property {number|null} [err] s2c_read err
         */

        /**
         * Constructs a new s2c_read.
         * @memberof mail
         * @classdesc Represents a s2c_read.
         * @implements Is2c_read
         * @constructor
         * @param {mail.Is2c_read=} [properties] Properties to set
         */
        function s2c_read(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_read err.
         * @member {number} err
         * @memberof mail.s2c_read
         * @instance
         */
        s2c_read.prototype.err = 0;

        /**
         * Creates a new s2c_read instance using the specified properties.
         * @function create
         * @memberof mail.s2c_read
         * @static
         * @param {mail.Is2c_read=} [properties] Properties to set
         * @returns {mail.s2c_read} s2c_read instance
         */
        s2c_read.create = function create(properties) {
            return new s2c_read(properties);
        };

        /**
         * Encodes the specified s2c_read message. Does not implicitly {@link mail.s2c_read.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_read
         * @static
         * @param {mail.Is2c_read} message s2c_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_read.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_read message, length delimited. Does not implicitly {@link mail.s2c_read.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_read
         * @static
         * @param {mail.Is2c_read} message s2c_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_read.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_read message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_read} s2c_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_read.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_read();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_read message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_read} s2c_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_read.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_read message.
         * @function verify
         * @memberof mail.s2c_read
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_read.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_read message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_read
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_read} s2c_read
         */
        s2c_read.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_read)
                return object;
            var message = new $root.mail.s2c_read();
            if (object.err != null)
                message.err = object.err | 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_read message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_read
         * @static
         * @param {mail.s2c_read} message s2c_read
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_read.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_read to JSON.
         * @function toJSON
         * @memberof mail.s2c_read
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_read.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_read
         * @function getTypeUrl
         * @memberof mail.s2c_read
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_read.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_read";
        };

        return s2c_read;
    })();

    mail.c2s_receive_reward = (function() {

        /**
         * Properties of a c2s_receive_reward.
         * @memberof mail
         * @interface Ic2s_receive_reward
         * @property {Array.<number>|null} [mailUids] c2s_receive_reward mailUids
         */

        /**
         * Constructs a new c2s_receive_reward.
         * @memberof mail
         * @classdesc Represents a c2s_receive_reward.
         * @implements Ic2s_receive_reward
         * @constructor
         * @param {mail.Ic2s_receive_reward=} [properties] Properties to set
         */
        function c2s_receive_reward(properties) {
            this.mailUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_receive_reward mailUids.
         * @member {Array.<number>} mailUids
         * @memberof mail.c2s_receive_reward
         * @instance
         */
        c2s_receive_reward.prototype.mailUids = $util.emptyArray;

        /**
         * Creates a new c2s_receive_reward instance using the specified properties.
         * @function create
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.Ic2s_receive_reward=} [properties] Properties to set
         * @returns {mail.c2s_receive_reward} c2s_receive_reward instance
         */
        c2s_receive_reward.create = function create(properties) {
            return new c2s_receive_reward(properties);
        };

        /**
         * Encodes the specified c2s_receive_reward message. Does not implicitly {@link mail.c2s_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailUids != null && message.mailUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mailUids.length; ++i)
                    writer.uint32(message.mailUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_receive_reward message, length delimited. Does not implicitly {@link mail.c2s_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mailUids && message.mailUids.length))
                            message.mailUids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.mailUids.push(reader.uint32());
                        } else
                            message.mailUids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_receive_reward message.
         * @function verify
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailUids != null && message.hasOwnProperty("mailUids")) {
                if (!Array.isArray(message.mailUids))
                    return "mailUids: array expected";
                for (var i = 0; i < message.mailUids.length; ++i)
                    if (!$util.isInteger(message.mailUids[i]))
                        return "mailUids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_receive_reward} c2s_receive_reward
         */
        c2s_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_receive_reward)
                return object;
            var message = new $root.mail.c2s_receive_reward();
            if (object.mailUids) {
                if (!Array.isArray(object.mailUids))
                    throw TypeError(".mail.c2s_receive_reward.mailUids: array expected");
                message.mailUids = [];
                for (var i = 0; i < object.mailUids.length; ++i)
                    message.mailUids[i] = object.mailUids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.c2s_receive_reward} message c2s_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailUids = [];
            if (message.mailUids && message.mailUids.length) {
                object.mailUids = [];
                for (var j = 0; j < message.mailUids.length; ++j)
                    object.mailUids[j] = message.mailUids[j];
            }
            return object;
        };

        /**
         * Converts this c2s_receive_reward to JSON.
         * @function toJSON
         * @memberof mail.c2s_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_receive_reward
         * @function getTypeUrl
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_receive_reward";
        };

        return c2s_receive_reward;
    })();

    mail.s2c_receive_reward = (function() {

        /**
         * Properties of a s2c_receive_reward.
         * @memberof mail
         * @interface Is2c_receive_reward
         * @property {number|null} [err] s2c_receive_reward err
         */

        /**
         * Constructs a new s2c_receive_reward.
         * @memberof mail
         * @classdesc Represents a s2c_receive_reward.
         * @implements Is2c_receive_reward
         * @constructor
         * @param {mail.Is2c_receive_reward=} [properties] Properties to set
         */
        function s2c_receive_reward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_receive_reward err.
         * @member {number} err
         * @memberof mail.s2c_receive_reward
         * @instance
         */
        s2c_receive_reward.prototype.err = 0;

        /**
         * Creates a new s2c_receive_reward instance using the specified properties.
         * @function create
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.Is2c_receive_reward=} [properties] Properties to set
         * @returns {mail.s2c_receive_reward} s2c_receive_reward instance
         */
        s2c_receive_reward.create = function create(properties) {
            return new s2c_receive_reward(properties);
        };

        /**
         * Encodes the specified s2c_receive_reward message. Does not implicitly {@link mail.s2c_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_receive_reward message, length delimited. Does not implicitly {@link mail.s2c_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_receive_reward message.
         * @function verify
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_receive_reward} s2c_receive_reward
         */
        s2c_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_receive_reward)
                return object;
            var message = new $root.mail.s2c_receive_reward();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.s2c_receive_reward} message s2c_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_receive_reward to JSON.
         * @function toJSON
         * @memberof mail.s2c_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_receive_reward
         * @function getTypeUrl
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_receive_reward";
        };

        return s2c_receive_reward;
    })();

    mail.c2s_delete_mails = (function() {

        /**
         * Properties of a c2s_delete_mails.
         * @memberof mail
         * @interface Ic2s_delete_mails
         * @property {Array.<number>|null} [mailUids] c2s_delete_mails mailUids
         */

        /**
         * Constructs a new c2s_delete_mails.
         * @memberof mail
         * @classdesc Represents a c2s_delete_mails.
         * @implements Ic2s_delete_mails
         * @constructor
         * @param {mail.Ic2s_delete_mails=} [properties] Properties to set
         */
        function c2s_delete_mails(properties) {
            this.mailUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_delete_mails mailUids.
         * @member {Array.<number>} mailUids
         * @memberof mail.c2s_delete_mails
         * @instance
         */
        c2s_delete_mails.prototype.mailUids = $util.emptyArray;

        /**
         * Creates a new c2s_delete_mails instance using the specified properties.
         * @function create
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.Ic2s_delete_mails=} [properties] Properties to set
         * @returns {mail.c2s_delete_mails} c2s_delete_mails instance
         */
        c2s_delete_mails.create = function create(properties) {
            return new c2s_delete_mails(properties);
        };

        /**
         * Encodes the specified c2s_delete_mails message. Does not implicitly {@link mail.c2s_delete_mails.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.Ic2s_delete_mails} message c2s_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_delete_mails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailUids != null && message.mailUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mailUids.length; ++i)
                    writer.uint32(message.mailUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_delete_mails message, length delimited. Does not implicitly {@link mail.c2s_delete_mails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.Ic2s_delete_mails} message c2s_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_delete_mails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_delete_mails message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_delete_mails} c2s_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_delete_mails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_delete_mails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mailUids && message.mailUids.length))
                            message.mailUids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.mailUids.push(reader.uint32());
                        } else
                            message.mailUids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_delete_mails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_delete_mails} c2s_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_delete_mails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_delete_mails message.
         * @function verify
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_delete_mails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailUids != null && message.hasOwnProperty("mailUids")) {
                if (!Array.isArray(message.mailUids))
                    return "mailUids: array expected";
                for (var i = 0; i < message.mailUids.length; ++i)
                    if (!$util.isInteger(message.mailUids[i]))
                        return "mailUids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_delete_mails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_delete_mails} c2s_delete_mails
         */
        c2s_delete_mails.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_delete_mails)
                return object;
            var message = new $root.mail.c2s_delete_mails();
            if (object.mailUids) {
                if (!Array.isArray(object.mailUids))
                    throw TypeError(".mail.c2s_delete_mails.mailUids: array expected");
                message.mailUids = [];
                for (var i = 0; i < object.mailUids.length; ++i)
                    message.mailUids[i] = object.mailUids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_delete_mails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.c2s_delete_mails} message c2s_delete_mails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_delete_mails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailUids = [];
            if (message.mailUids && message.mailUids.length) {
                object.mailUids = [];
                for (var j = 0; j < message.mailUids.length; ++j)
                    object.mailUids[j] = message.mailUids[j];
            }
            return object;
        };

        /**
         * Converts this c2s_delete_mails to JSON.
         * @function toJSON
         * @memberof mail.c2s_delete_mails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_delete_mails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_delete_mails
         * @function getTypeUrl
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_delete_mails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_delete_mails";
        };

        return c2s_delete_mails;
    })();

    mail.s2c_delete_mails = (function() {

        /**
         * Properties of a s2c_delete_mails.
         * @memberof mail
         * @interface Is2c_delete_mails
         * @property {number|null} [err] s2c_delete_mails err
         */

        /**
         * Constructs a new s2c_delete_mails.
         * @memberof mail
         * @classdesc Represents a s2c_delete_mails.
         * @implements Is2c_delete_mails
         * @constructor
         * @param {mail.Is2c_delete_mails=} [properties] Properties to set
         */
        function s2c_delete_mails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_delete_mails err.
         * @member {number} err
         * @memberof mail.s2c_delete_mails
         * @instance
         */
        s2c_delete_mails.prototype.err = 0;

        /**
         * Creates a new s2c_delete_mails instance using the specified properties.
         * @function create
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.Is2c_delete_mails=} [properties] Properties to set
         * @returns {mail.s2c_delete_mails} s2c_delete_mails instance
         */
        s2c_delete_mails.create = function create(properties) {
            return new s2c_delete_mails(properties);
        };

        /**
         * Encodes the specified s2c_delete_mails message. Does not implicitly {@link mail.s2c_delete_mails.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.Is2c_delete_mails} message s2c_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_delete_mails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_delete_mails message, length delimited. Does not implicitly {@link mail.s2c_delete_mails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.Is2c_delete_mails} message s2c_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_delete_mails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_delete_mails message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_delete_mails} s2c_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_delete_mails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_delete_mails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_delete_mails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_delete_mails} s2c_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_delete_mails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_delete_mails message.
         * @function verify
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_delete_mails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_delete_mails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_delete_mails} s2c_delete_mails
         */
        s2c_delete_mails.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_delete_mails)
                return object;
            var message = new $root.mail.s2c_delete_mails();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_delete_mails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.s2c_delete_mails} message s2c_delete_mails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_delete_mails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_delete_mails to JSON.
         * @function toJSON
         * @memberof mail.s2c_delete_mails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_delete_mails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_delete_mails
         * @function getTypeUrl
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_delete_mails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_delete_mails";
        };

        return s2c_delete_mails;
    })();

    mail.notify_new_mails = (function() {

        /**
         * Properties of a notify_new_mails.
         * @memberof mail
         * @interface Inotify_new_mails
         * @property {Array.<mail.IMailInfo>|null} [mails] notify_new_mails mails
         */

        /**
         * Constructs a new notify_new_mails.
         * @memberof mail
         * @classdesc Represents a notify_new_mails.
         * @implements Inotify_new_mails
         * @constructor
         * @param {mail.Inotify_new_mails=} [properties] Properties to set
         */
        function notify_new_mails(properties) {
            this.mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_new_mails mails.
         * @member {Array.<mail.IMailInfo>} mails
         * @memberof mail.notify_new_mails
         * @instance
         */
        notify_new_mails.prototype.mails = $util.emptyArray;

        /**
         * Creates a new notify_new_mails instance using the specified properties.
         * @function create
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.Inotify_new_mails=} [properties] Properties to set
         * @returns {mail.notify_new_mails} notify_new_mails instance
         */
        notify_new_mails.create = function create(properties) {
            return new notify_new_mails(properties);
        };

        /**
         * Encodes the specified notify_new_mails message. Does not implicitly {@link mail.notify_new_mails.verify|verify} messages.
         * @function encode
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.Inotify_new_mails} message notify_new_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_new_mails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mails != null && message.mails.length)
                for (var i = 0; i < message.mails.length; ++i)
                    $root.mail.MailInfo.encode(message.mails[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_new_mails message, length delimited. Does not implicitly {@link mail.notify_new_mails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.Inotify_new_mails} message notify_new_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_new_mails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_new_mails message from the specified reader or buffer.
         * @function decode
         * @memberof mail.notify_new_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.notify_new_mails} notify_new_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_new_mails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.notify_new_mails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mails && message.mails.length))
                            message.mails = [];
                        message.mails.push($root.mail.MailInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_new_mails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.notify_new_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.notify_new_mails} notify_new_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_new_mails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_new_mails message.
         * @function verify
         * @memberof mail.notify_new_mails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_new_mails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mails != null && message.hasOwnProperty("mails")) {
                if (!Array.isArray(message.mails))
                    return "mails: array expected";
                for (var i = 0; i < message.mails.length; ++i) {
                    var error = $root.mail.MailInfo.verify(message.mails[i]);
                    if (error)
                        return "mails." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_new_mails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.notify_new_mails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.notify_new_mails} notify_new_mails
         */
        notify_new_mails.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.notify_new_mails)
                return object;
            var message = new $root.mail.notify_new_mails();
            if (object.mails) {
                if (!Array.isArray(object.mails))
                    throw TypeError(".mail.notify_new_mails.mails: array expected");
                message.mails = [];
                for (var i = 0; i < object.mails.length; ++i) {
                    if (typeof object.mails[i] !== "object")
                        throw TypeError(".mail.notify_new_mails.mails: object expected");
                    message.mails[i] = $root.mail.MailInfo.fromObject(object.mails[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_new_mails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.notify_new_mails} message notify_new_mails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_new_mails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mails = [];
            if (message.mails && message.mails.length) {
                object.mails = [];
                for (var j = 0; j < message.mails.length; ++j)
                    object.mails[j] = $root.mail.MailInfo.toObject(message.mails[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_new_mails to JSON.
         * @function toJSON
         * @memberof mail.notify_new_mails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_new_mails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_new_mails
         * @function getTypeUrl
         * @memberof mail.notify_new_mails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_new_mails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.notify_new_mails";
        };

        return notify_new_mails;
    })();

    return mail;
})();

$root.money = (function() {

    /**
     * Namespace money.
     * @exports money
     * @namespace
     */
    var money = {};

    money.MoneyItem = (function() {

        /**
         * Properties of a MoneyItem.
         * @memberof money
         * @interface IMoneyItem
         * @property {number|null} [id] MoneyItem id
         * @property {number|null} [num] MoneyItem num
         * @property {number|null} [recoverTs] MoneyItem recoverTs
         */

        /**
         * Constructs a new MoneyItem.
         * @memberof money
         * @classdesc Represents a MoneyItem.
         * @implements IMoneyItem
         * @constructor
         * @param {money.IMoneyItem=} [properties] Properties to set
         */
        function MoneyItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoneyItem id.
         * @member {number} id
         * @memberof money.MoneyItem
         * @instance
         */
        MoneyItem.prototype.id = 0;

        /**
         * MoneyItem num.
         * @member {number} num
         * @memberof money.MoneyItem
         * @instance
         */
        MoneyItem.prototype.num = 0;

        /**
         * MoneyItem recoverTs.
         * @member {number} recoverTs
         * @memberof money.MoneyItem
         * @instance
         */
        MoneyItem.prototype.recoverTs = 0;

        /**
         * Creates a new MoneyItem instance using the specified properties.
         * @function create
         * @memberof money.MoneyItem
         * @static
         * @param {money.IMoneyItem=} [properties] Properties to set
         * @returns {money.MoneyItem} MoneyItem instance
         */
        MoneyItem.create = function create(properties) {
            return new MoneyItem(properties);
        };

        /**
         * Encodes the specified MoneyItem message. Does not implicitly {@link money.MoneyItem.verify|verify} messages.
         * @function encode
         * @memberof money.MoneyItem
         * @static
         * @param {money.IMoneyItem} message MoneyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoneyItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.recoverTs != null && Object.hasOwnProperty.call(message, "recoverTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.recoverTs);
            return writer;
        };

        /**
         * Encodes the specified MoneyItem message, length delimited. Does not implicitly {@link money.MoneyItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.MoneyItem
         * @static
         * @param {money.IMoneyItem} message MoneyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoneyItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoneyItem message from the specified reader or buffer.
         * @function decode
         * @memberof money.MoneyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.MoneyItem} MoneyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoneyItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.MoneyItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                case 3: {
                        message.recoverTs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoneyItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.MoneyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.MoneyItem} MoneyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoneyItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoneyItem message.
         * @function verify
         * @memberof money.MoneyItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoneyItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.recoverTs != null && message.hasOwnProperty("recoverTs"))
                if (!$util.isInteger(message.recoverTs))
                    return "recoverTs: integer expected";
            return null;
        };

        /**
         * Creates a MoneyItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.MoneyItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.MoneyItem} MoneyItem
         */
        MoneyItem.fromObject = function fromObject(object) {
            if (object instanceof $root.money.MoneyItem)
                return object;
            var message = new $root.money.MoneyItem();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.recoverTs != null)
                message.recoverTs = object.recoverTs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MoneyItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.MoneyItem
         * @static
         * @param {money.MoneyItem} message MoneyItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoneyItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.recoverTs = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.recoverTs != null && message.hasOwnProperty("recoverTs"))
                object.recoverTs = message.recoverTs;
            return object;
        };

        /**
         * Converts this MoneyItem to JSON.
         * @function toJSON
         * @memberof money.MoneyItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoneyItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MoneyItem
         * @function getTypeUrl
         * @memberof money.MoneyItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MoneyItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.MoneyItem";
        };

        return MoneyItem;
    })();

    money.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof money
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof money
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {money.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof money.c2s_load
         * @static
         * @param {money.Ic2s_load=} [properties] Properties to set
         * @returns {money.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link money.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof money.c2s_load
         * @static
         * @param {money.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link money.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.c2s_load
         * @static
         * @param {money.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof money.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof money.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.money.c2s_load)
                return object;
            return new $root.money.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.c2s_load
         * @static
         * @param {money.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof money.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof money.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.c2s_load";
        };

        return c2s_load;
    })();

    money.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof money
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<money.IMoneyItem>|null} [items] s2c_load items
         */

        /**
         * Constructs a new s2c_load.
         * @memberof money
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {money.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof money.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load items.
         * @member {Array.<money.IMoneyItem>} items
         * @memberof money.s2c_load
         * @instance
         */
        s2c_load.prototype.items = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof money.s2c_load
         * @static
         * @param {money.Is2c_load=} [properties] Properties to set
         * @returns {money.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link money.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof money.s2c_load
         * @static
         * @param {money.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.money.MoneyItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link money.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.s2c_load
         * @static
         * @param {money.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof money.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.money.MoneyItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof money.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.money.MoneyItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.money.s2c_load)
                return object;
            var message = new $root.money.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".money.s2c_load.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".money.s2c_load.items: object expected");
                    message.items[i] = $root.money.MoneyItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.s2c_load
         * @static
         * @param {money.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.money.MoneyItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof money.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof money.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.s2c_load";
        };

        return s2c_load;
    })();

    money.notify_items = (function() {

        /**
         * Properties of a notify_items.
         * @memberof money
         * @interface Inotify_items
         * @property {Array.<money.IMoneyItem>|null} [items] notify_items items
         */

        /**
         * Constructs a new notify_items.
         * @memberof money
         * @classdesc Represents a notify_items.
         * @implements Inotify_items
         * @constructor
         * @param {money.Inotify_items=} [properties] Properties to set
         */
        function notify_items(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_items items.
         * @member {Array.<money.IMoneyItem>} items
         * @memberof money.notify_items
         * @instance
         */
        notify_items.prototype.items = $util.emptyArray;

        /**
         * Creates a new notify_items instance using the specified properties.
         * @function create
         * @memberof money.notify_items
         * @static
         * @param {money.Inotify_items=} [properties] Properties to set
         * @returns {money.notify_items} notify_items instance
         */
        notify_items.create = function create(properties) {
            return new notify_items(properties);
        };

        /**
         * Encodes the specified notify_items message. Does not implicitly {@link money.notify_items.verify|verify} messages.
         * @function encode
         * @memberof money.notify_items
         * @static
         * @param {money.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.money.MoneyItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_items message, length delimited. Does not implicitly {@link money.notify_items.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.notify_items
         * @static
         * @param {money.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer.
         * @function decode
         * @memberof money.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.notify_items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.money.MoneyItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_items message.
         * @function verify
         * @memberof money.notify_items
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.money.MoneyItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_items message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.notify_items
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.notify_items} notify_items
         */
        notify_items.fromObject = function fromObject(object) {
            if (object instanceof $root.money.notify_items)
                return object;
            var message = new $root.money.notify_items();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".money.notify_items.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".money.notify_items.items: object expected");
                    message.items[i] = $root.money.MoneyItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_items message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.notify_items
         * @static
         * @param {money.notify_items} message notify_items
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.money.MoneyItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_items to JSON.
         * @function toJSON
         * @memberof money.notify_items
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_items
         * @function getTypeUrl
         * @memberof money.notify_items
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.notify_items";
        };

        return notify_items;
    })();

    return money;
})();

$root.profile = (function() {

    /**
     * Namespace profile.
     * @exports profile
     * @namespace
     */
    var profile = {};

    profile.ProfileInfo = (function() {

        /**
         * Properties of a ProfileInfo.
         * @memberof profile
         * @interface IProfileInfo
         * @property {string|null} [name] ProfileInfo name
         * @property {number|null} [gender] ProfileInfo gender
         * @property {number|null} [exp] ProfileInfo exp
         * @property {number|null} [lv] ProfileInfo lv
         */

        /**
         * Constructs a new ProfileInfo.
         * @memberof profile
         * @classdesc Represents a ProfileInfo.
         * @implements IProfileInfo
         * @constructor
         * @param {profile.IProfileInfo=} [properties] Properties to set
         */
        function ProfileInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProfileInfo name.
         * @member {string} name
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.name = "";

        /**
         * ProfileInfo gender.
         * @member {number} gender
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.gender = 0;

        /**
         * ProfileInfo exp.
         * @member {number} exp
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.exp = 0;

        /**
         * ProfileInfo lv.
         * @member {number} lv
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.lv = 0;

        /**
         * Creates a new ProfileInfo instance using the specified properties.
         * @function create
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.IProfileInfo=} [properties] Properties to set
         * @returns {profile.ProfileInfo} ProfileInfo instance
         */
        ProfileInfo.create = function create(properties) {
            return new ProfileInfo(properties);
        };

        /**
         * Encodes the specified ProfileInfo message. Does not implicitly {@link profile.ProfileInfo.verify|verify} messages.
         * @function encode
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.IProfileInfo} message ProfileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfileInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gender);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.exp);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.lv);
            return writer;
        };

        /**
         * Encodes the specified ProfileInfo message, length delimited. Does not implicitly {@link profile.ProfileInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.IProfileInfo} message ProfileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfileInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProfileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof profile.ProfileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.ProfileInfo} ProfileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfileInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.ProfileInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.gender = reader.uint32();
                        break;
                    }
                case 3: {
                        message.exp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.lv = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProfileInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.ProfileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.ProfileInfo} ProfileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfileInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProfileInfo message.
         * @function verify
         * @memberof profile.ProfileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProfileInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            return null;
        };

        /**
         * Creates a ProfileInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.ProfileInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.ProfileInfo} ProfileInfo
         */
        ProfileInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.ProfileInfo)
                return object;
            var message = new $root.profile.ProfileInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.gender != null)
                message.gender = object.gender >>> 0;
            if (object.exp != null)
                message.exp = object.exp >>> 0;
            if (object.lv != null)
                message.lv = object.lv >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProfileInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.ProfileInfo} message ProfileInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProfileInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.gender = 0;
                object.exp = 0;
                object.lv = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            return object;
        };

        /**
         * Converts this ProfileInfo to JSON.
         * @function toJSON
         * @memberof profile.ProfileInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProfileInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProfileInfo
         * @function getTypeUrl
         * @memberof profile.ProfileInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProfileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.ProfileInfo";
        };

        return ProfileInfo;
    })();

    profile.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof profile
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof profile
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {profile.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof profile.c2s_load
         * @static
         * @param {profile.Ic2s_load=} [properties] Properties to set
         * @returns {profile.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link profile.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof profile.c2s_load
         * @static
         * @param {profile.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link profile.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.c2s_load
         * @static
         * @param {profile.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof profile.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof profile.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.c2s_load)
                return object;
            return new $root.profile.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.c2s_load
         * @static
         * @param {profile.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof profile.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof profile.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.c2s_load";
        };

        return c2s_load;
    })();

    profile.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof profile
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {profile.IProfileInfo|null} [profile] s2c_load profile
         */

        /**
         * Constructs a new s2c_load.
         * @memberof profile
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {profile.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof profile.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load profile.
         * @member {profile.IProfileInfo|null|undefined} profile
         * @memberof profile.s2c_load
         * @instance
         */
        s2c_load.prototype.profile = null;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof profile.s2c_load
         * @static
         * @param {profile.Is2c_load=} [properties] Properties to set
         * @returns {profile.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link profile.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof profile.s2c_load
         * @static
         * @param {profile.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.err);
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.profile.ProfileInfo.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link profile.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.s2c_load
         * @static
         * @param {profile.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof profile.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.int32();
                        break;
                    }
                case 2: {
                        message.profile = $root.profile.ProfileInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof profile.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.profile.ProfileInfo.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.s2c_load)
                return object;
            var message = new $root.profile.s2c_load();
            if (object.err != null)
                message.err = object.err | 0;
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".profile.s2c_load.profile: object expected");
                message.profile = $root.profile.ProfileInfo.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.s2c_load
         * @static
         * @param {profile.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.profile = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.profile.ProfileInfo.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof profile.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof profile.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.s2c_load";
        };

        return s2c_load;
    })();

    profile.notify_profile = (function() {

        /**
         * Properties of a notify_profile.
         * @memberof profile
         * @interface Inotify_profile
         * @property {profile.IProfileInfo|null} [profile] notify_profile profile
         */

        /**
         * Constructs a new notify_profile.
         * @memberof profile
         * @classdesc Represents a notify_profile.
         * @implements Inotify_profile
         * @constructor
         * @param {profile.Inotify_profile=} [properties] Properties to set
         */
        function notify_profile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_profile profile.
         * @member {profile.IProfileInfo|null|undefined} profile
         * @memberof profile.notify_profile
         * @instance
         */
        notify_profile.prototype.profile = null;

        /**
         * Creates a new notify_profile instance using the specified properties.
         * @function create
         * @memberof profile.notify_profile
         * @static
         * @param {profile.Inotify_profile=} [properties] Properties to set
         * @returns {profile.notify_profile} notify_profile instance
         */
        notify_profile.create = function create(properties) {
            return new notify_profile(properties);
        };

        /**
         * Encodes the specified notify_profile message. Does not implicitly {@link profile.notify_profile.verify|verify} messages.
         * @function encode
         * @memberof profile.notify_profile
         * @static
         * @param {profile.Inotify_profile} message notify_profile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_profile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.profile.ProfileInfo.encode(message.profile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_profile message, length delimited. Does not implicitly {@link profile.notify_profile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.notify_profile
         * @static
         * @param {profile.Inotify_profile} message notify_profile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_profile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_profile message from the specified reader or buffer.
         * @function decode
         * @memberof profile.notify_profile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.notify_profile} notify_profile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_profile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.notify_profile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.profile = $root.profile.ProfileInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_profile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.notify_profile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.notify_profile} notify_profile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_profile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_profile message.
         * @function verify
         * @memberof profile.notify_profile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_profile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.profile.ProfileInfo.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a notify_profile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.notify_profile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.notify_profile} notify_profile
         */
        notify_profile.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.notify_profile)
                return object;
            var message = new $root.profile.notify_profile();
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".profile.notify_profile.profile: object expected");
                message.profile = $root.profile.ProfileInfo.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_profile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.notify_profile
         * @static
         * @param {profile.notify_profile} message notify_profile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_profile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.profile = null;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.profile.ProfileInfo.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this notify_profile to JSON.
         * @function toJSON
         * @memberof profile.notify_profile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_profile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_profile
         * @function getTypeUrl
         * @memberof profile.notify_profile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_profile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.notify_profile";
        };

        return notify_profile;
    })();

    return profile;
})();

$root.task = (function() {

    /**
     * Namespace task.
     * @exports task
     * @namespace
     */
    var task = {};

    task.TaskInfo = (function() {

        /**
         * Properties of a TaskInfo.
         * @memberof task
         * @interface ITaskInfo
         * @property {number|null} [id] TaskInfo id
         * @property {number|null} [num] TaskInfo num
         * @property {number|null} [max] TaskInfo max
         * @property {boolean|null} [finish] TaskInfo finish
         */

        /**
         * Constructs a new TaskInfo.
         * @memberof task
         * @classdesc Represents a TaskInfo.
         * @implements ITaskInfo
         * @constructor
         * @param {task.ITaskInfo=} [properties] Properties to set
         */
        function TaskInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskInfo id.
         * @member {number} id
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.id = 0;

        /**
         * TaskInfo num.
         * @member {number} num
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.num = 0;

        /**
         * TaskInfo max.
         * @member {number} max
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.max = 0;

        /**
         * TaskInfo finish.
         * @member {boolean} finish
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.finish = false;

        /**
         * Creates a new TaskInfo instance using the specified properties.
         * @function create
         * @memberof task.TaskInfo
         * @static
         * @param {task.ITaskInfo=} [properties] Properties to set
         * @returns {task.TaskInfo} TaskInfo instance
         */
        TaskInfo.create = function create(properties) {
            return new TaskInfo(properties);
        };

        /**
         * Encodes the specified TaskInfo message. Does not implicitly {@link task.TaskInfo.verify|verify} messages.
         * @function encode
         * @memberof task.TaskInfo
         * @static
         * @param {task.ITaskInfo} message TaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.max);
            if (message.finish != null && Object.hasOwnProperty.call(message, "finish"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.finish);
            return writer;
        };

        /**
         * Encodes the specified TaskInfo message, length delimited. Does not implicitly {@link task.TaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.TaskInfo
         * @static
         * @param {task.ITaskInfo} message TaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof task.TaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.TaskInfo} TaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.TaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                case 3: {
                        message.max = reader.uint32();
                        break;
                    }
                case 4: {
                        message.finish = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.TaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.TaskInfo} TaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskInfo message.
         * @function verify
         * @memberof task.TaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.max != null && message.hasOwnProperty("max"))
                if (!$util.isInteger(message.max))
                    return "max: integer expected";
            if (message.finish != null && message.hasOwnProperty("finish"))
                if (typeof message.finish !== "boolean")
                    return "finish: boolean expected";
            return null;
        };

        /**
         * Creates a TaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.TaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.TaskInfo} TaskInfo
         */
        TaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.task.TaskInfo)
                return object;
            var message = new $root.task.TaskInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.max != null)
                message.max = object.max >>> 0;
            if (object.finish != null)
                message.finish = Boolean(object.finish);
            return message;
        };

        /**
         * Creates a plain object from a TaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.TaskInfo
         * @static
         * @param {task.TaskInfo} message TaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.max = 0;
                object.finish = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.max != null && message.hasOwnProperty("max"))
                object.max = message.max;
            if (message.finish != null && message.hasOwnProperty("finish"))
                object.finish = message.finish;
            return object;
        };

        /**
         * Converts this TaskInfo to JSON.
         * @function toJSON
         * @memberof task.TaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TaskInfo
         * @function getTypeUrl
         * @memberof task.TaskInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TaskInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.TaskInfo";
        };

        return TaskInfo;
    })();

    task.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof task
         * @interface Ic2s_load
         * @property {number|null} [taskType] c2s_load taskType
         */

        /**
         * Constructs a new c2s_load.
         * @memberof task
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {task.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load taskType.
         * @member {number} taskType
         * @memberof task.c2s_load
         * @instance
         */
        c2s_load.prototype.taskType = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof task.c2s_load
         * @static
         * @param {task.Ic2s_load=} [properties] Properties to set
         * @returns {task.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link task.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof task.c2s_load
         * @static
         * @param {task.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskType != null && Object.hasOwnProperty.call(message, "taskType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.taskType);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link task.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.c2s_load
         * @static
         * @param {task.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof task.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.taskType = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof task.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskType != null && message.hasOwnProperty("taskType"))
                if (!$util.isInteger(message.taskType))
                    return "taskType: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.task.c2s_load)
                return object;
            var message = new $root.task.c2s_load();
            if (object.taskType != null)
                message.taskType = object.taskType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.c2s_load
         * @static
         * @param {task.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.taskType = 0;
            if (message.taskType != null && message.hasOwnProperty("taskType"))
                object.taskType = message.taskType;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof task.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof task.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.c2s_load";
        };

        return c2s_load;
    })();

    task.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof task
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<task.ITaskInfo>|null} [tasks] s2c_load tasks
         */

        /**
         * Constructs a new s2c_load.
         * @memberof task
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {task.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.tasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof task.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load tasks.
         * @member {Array.<task.ITaskInfo>} tasks
         * @memberof task.s2c_load
         * @instance
         */
        s2c_load.prototype.tasks = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof task.s2c_load
         * @static
         * @param {task.Is2c_load=} [properties] Properties to set
         * @returns {task.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link task.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof task.s2c_load
         * @static
         * @param {task.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.task.TaskInfo.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link task.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.s2c_load
         * @static
         * @param {task.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof task.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.task.TaskInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof task.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.task.TaskInfo.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.task.s2c_load)
                return object;
            var message = new $root.task.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".task.s2c_load.tasks: array expected");
                message.tasks = [];
                for (var i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".task.s2c_load.tasks: object expected");
                    message.tasks[i] = $root.task.TaskInfo.fromObject(object.tasks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.s2c_load
         * @static
         * @param {task.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (var j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.task.TaskInfo.toObject(message.tasks[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof task.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof task.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.s2c_load";
        };

        return s2c_load;
    })();

    task.c2s_receive_reward = (function() {

        /**
         * Properties of a c2s_receive_reward.
         * @memberof task
         * @interface Ic2s_receive_reward
         * @property {Array.<number>|null} [taskIds] c2s_receive_reward taskIds
         */

        /**
         * Constructs a new c2s_receive_reward.
         * @memberof task
         * @classdesc Represents a c2s_receive_reward.
         * @implements Ic2s_receive_reward
         * @constructor
         * @param {task.Ic2s_receive_reward=} [properties] Properties to set
         */
        function c2s_receive_reward(properties) {
            this.taskIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_receive_reward taskIds.
         * @member {Array.<number>} taskIds
         * @memberof task.c2s_receive_reward
         * @instance
         */
        c2s_receive_reward.prototype.taskIds = $util.emptyArray;

        /**
         * Creates a new c2s_receive_reward instance using the specified properties.
         * @function create
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.Ic2s_receive_reward=} [properties] Properties to set
         * @returns {task.c2s_receive_reward} c2s_receive_reward instance
         */
        c2s_receive_reward.create = function create(properties) {
            return new c2s_receive_reward(properties);
        };

        /**
         * Encodes the specified c2s_receive_reward message. Does not implicitly {@link task.c2s_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskIds != null && message.taskIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.taskIds.length; ++i)
                    writer.uint32(message.taskIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_receive_reward message, length delimited. Does not implicitly {@link task.c2s_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof task.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.c2s_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.taskIds && message.taskIds.length))
                            message.taskIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.taskIds.push(reader.uint32());
                        } else
                            message.taskIds.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_receive_reward message.
         * @function verify
         * @memberof task.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskIds != null && message.hasOwnProperty("taskIds")) {
                if (!Array.isArray(message.taskIds))
                    return "taskIds: array expected";
                for (var i = 0; i < message.taskIds.length; ++i)
                    if (!$util.isInteger(message.taskIds[i]))
                        return "taskIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.c2s_receive_reward} c2s_receive_reward
         */
        c2s_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.task.c2s_receive_reward)
                return object;
            var message = new $root.task.c2s_receive_reward();
            if (object.taskIds) {
                if (!Array.isArray(object.taskIds))
                    throw TypeError(".task.c2s_receive_reward.taskIds: array expected");
                message.taskIds = [];
                for (var i = 0; i < object.taskIds.length; ++i)
                    message.taskIds[i] = object.taskIds[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.c2s_receive_reward} message c2s_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskIds = [];
            if (message.taskIds && message.taskIds.length) {
                object.taskIds = [];
                for (var j = 0; j < message.taskIds.length; ++j)
                    object.taskIds[j] = message.taskIds[j];
            }
            return object;
        };

        /**
         * Converts this c2s_receive_reward to JSON.
         * @function toJSON
         * @memberof task.c2s_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_receive_reward
         * @function getTypeUrl
         * @memberof task.c2s_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.c2s_receive_reward";
        };

        return c2s_receive_reward;
    })();

    task.s2c_receive_reward = (function() {

        /**
         * Properties of a s2c_receive_reward.
         * @memberof task
         * @interface Is2c_receive_reward
         * @property {number|null} [err] s2c_receive_reward err
         */

        /**
         * Constructs a new s2c_receive_reward.
         * @memberof task
         * @classdesc Represents a s2c_receive_reward.
         * @implements Is2c_receive_reward
         * @constructor
         * @param {task.Is2c_receive_reward=} [properties] Properties to set
         */
        function s2c_receive_reward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_receive_reward err.
         * @member {number} err
         * @memberof task.s2c_receive_reward
         * @instance
         */
        s2c_receive_reward.prototype.err = 0;

        /**
         * Creates a new s2c_receive_reward instance using the specified properties.
         * @function create
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.Is2c_receive_reward=} [properties] Properties to set
         * @returns {task.s2c_receive_reward} s2c_receive_reward instance
         */
        s2c_receive_reward.create = function create(properties) {
            return new s2c_receive_reward(properties);
        };

        /**
         * Encodes the specified s2c_receive_reward message. Does not implicitly {@link task.s2c_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_receive_reward message, length delimited. Does not implicitly {@link task.s2c_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof task.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.s2c_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_receive_reward message.
         * @function verify
         * @memberof task.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.s2c_receive_reward} s2c_receive_reward
         */
        s2c_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.task.s2c_receive_reward)
                return object;
            var message = new $root.task.s2c_receive_reward();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.s2c_receive_reward} message s2c_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_receive_reward to JSON.
         * @function toJSON
         * @memberof task.s2c_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_receive_reward
         * @function getTypeUrl
         * @memberof task.s2c_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.s2c_receive_reward";
        };

        return s2c_receive_reward;
    })();

    task.notify_tasks = (function() {

        /**
         * Properties of a notify_tasks.
         * @memberof task
         * @interface Inotify_tasks
         * @property {Array.<task.ITaskInfo>|null} [tasks] notify_tasks tasks
         */

        /**
         * Constructs a new notify_tasks.
         * @memberof task
         * @classdesc Represents a notify_tasks.
         * @implements Inotify_tasks
         * @constructor
         * @param {task.Inotify_tasks=} [properties] Properties to set
         */
        function notify_tasks(properties) {
            this.tasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_tasks tasks.
         * @member {Array.<task.ITaskInfo>} tasks
         * @memberof task.notify_tasks
         * @instance
         */
        notify_tasks.prototype.tasks = $util.emptyArray;

        /**
         * Creates a new notify_tasks instance using the specified properties.
         * @function create
         * @memberof task.notify_tasks
         * @static
         * @param {task.Inotify_tasks=} [properties] Properties to set
         * @returns {task.notify_tasks} notify_tasks instance
         */
        notify_tasks.create = function create(properties) {
            return new notify_tasks(properties);
        };

        /**
         * Encodes the specified notify_tasks message. Does not implicitly {@link task.notify_tasks.verify|verify} messages.
         * @function encode
         * @memberof task.notify_tasks
         * @static
         * @param {task.Inotify_tasks} message notify_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_tasks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.task.TaskInfo.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_tasks message, length delimited. Does not implicitly {@link task.notify_tasks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.notify_tasks
         * @static
         * @param {task.Inotify_tasks} message notify_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_tasks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_tasks message from the specified reader or buffer.
         * @function decode
         * @memberof task.notify_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.notify_tasks} notify_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_tasks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.notify_tasks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.task.TaskInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_tasks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.notify_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.notify_tasks} notify_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_tasks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_tasks message.
         * @function verify
         * @memberof task.notify_tasks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_tasks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.task.TaskInfo.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_tasks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.notify_tasks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.notify_tasks} notify_tasks
         */
        notify_tasks.fromObject = function fromObject(object) {
            if (object instanceof $root.task.notify_tasks)
                return object;
            var message = new $root.task.notify_tasks();
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".task.notify_tasks.tasks: array expected");
                message.tasks = [];
                for (var i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".task.notify_tasks.tasks: object expected");
                    message.tasks[i] = $root.task.TaskInfo.fromObject(object.tasks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_tasks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.notify_tasks
         * @static
         * @param {task.notify_tasks} message notify_tasks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_tasks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (var j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.task.TaskInfo.toObject(message.tasks[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_tasks to JSON.
         * @function toJSON
         * @memberof task.notify_tasks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_tasks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_tasks
         * @function getTypeUrl
         * @memberof task.notify_tasks
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_tasks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.notify_tasks";
        };

        return notify_tasks;
    })();

    task.notify_remove_tasks = (function() {

        /**
         * Properties of a notify_remove_tasks.
         * @memberof task
         * @interface Inotify_remove_tasks
         * @property {Array.<number>|null} [taskIds] notify_remove_tasks taskIds
         */

        /**
         * Constructs a new notify_remove_tasks.
         * @memberof task
         * @classdesc Represents a notify_remove_tasks.
         * @implements Inotify_remove_tasks
         * @constructor
         * @param {task.Inotify_remove_tasks=} [properties] Properties to set
         */
        function notify_remove_tasks(properties) {
            this.taskIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_remove_tasks taskIds.
         * @member {Array.<number>} taskIds
         * @memberof task.notify_remove_tasks
         * @instance
         */
        notify_remove_tasks.prototype.taskIds = $util.emptyArray;

        /**
         * Creates a new notify_remove_tasks instance using the specified properties.
         * @function create
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.Inotify_remove_tasks=} [properties] Properties to set
         * @returns {task.notify_remove_tasks} notify_remove_tasks instance
         */
        notify_remove_tasks.create = function create(properties) {
            return new notify_remove_tasks(properties);
        };

        /**
         * Encodes the specified notify_remove_tasks message. Does not implicitly {@link task.notify_remove_tasks.verify|verify} messages.
         * @function encode
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.Inotify_remove_tasks} message notify_remove_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_remove_tasks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskIds != null && message.taskIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.taskIds.length; ++i)
                    writer.int32(message.taskIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified notify_remove_tasks message, length delimited. Does not implicitly {@link task.notify_remove_tasks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.Inotify_remove_tasks} message notify_remove_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_remove_tasks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_remove_tasks message from the specified reader or buffer.
         * @function decode
         * @memberof task.notify_remove_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.notify_remove_tasks} notify_remove_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_remove_tasks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.notify_remove_tasks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.taskIds && message.taskIds.length))
                            message.taskIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.taskIds.push(reader.int32());
                        } else
                            message.taskIds.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_remove_tasks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.notify_remove_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.notify_remove_tasks} notify_remove_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_remove_tasks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_remove_tasks message.
         * @function verify
         * @memberof task.notify_remove_tasks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_remove_tasks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskIds != null && message.hasOwnProperty("taskIds")) {
                if (!Array.isArray(message.taskIds))
                    return "taskIds: array expected";
                for (var i = 0; i < message.taskIds.length; ++i)
                    if (!$util.isInteger(message.taskIds[i]))
                        return "taskIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_remove_tasks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.notify_remove_tasks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.notify_remove_tasks} notify_remove_tasks
         */
        notify_remove_tasks.fromObject = function fromObject(object) {
            if (object instanceof $root.task.notify_remove_tasks)
                return object;
            var message = new $root.task.notify_remove_tasks();
            if (object.taskIds) {
                if (!Array.isArray(object.taskIds))
                    throw TypeError(".task.notify_remove_tasks.taskIds: array expected");
                message.taskIds = [];
                for (var i = 0; i < object.taskIds.length; ++i)
                    message.taskIds[i] = object.taskIds[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_remove_tasks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.notify_remove_tasks} message notify_remove_tasks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_remove_tasks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskIds = [];
            if (message.taskIds && message.taskIds.length) {
                object.taskIds = [];
                for (var j = 0; j < message.taskIds.length; ++j)
                    object.taskIds[j] = message.taskIds[j];
            }
            return object;
        };

        /**
         * Converts this notify_remove_tasks to JSON.
         * @function toJSON
         * @memberof task.notify_remove_tasks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_remove_tasks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_remove_tasks
         * @function getTypeUrl
         * @memberof task.notify_remove_tasks
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_remove_tasks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.notify_remove_tasks";
        };

        return notify_remove_tasks;
    })();

    return task;
})();

$root.troop = (function() {

    /**
     * Namespace troop.
     * @exports troop
     * @namespace
     */
    var troop = {};

    troop.Troop = (function() {

        /**
         * Properties of a Troop.
         * @memberof troop
         * @interface ITroop
         * @property {number|null} [idx] Troop idx
         * @property {number|null} [eid] Troop eid
         * @property {number|null} [heroUid] Troop heroUid
         * @property {number|null} [soldierId] Troop soldierId
         * @property {number|null} [soldierAmount] Troop soldierAmount
         */

        /**
         * Constructs a new Troop.
         * @memberof troop
         * @classdesc Represents a Troop.
         * @implements ITroop
         * @constructor
         * @param {troop.ITroop=} [properties] Properties to set
         */
        function Troop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Troop idx.
         * @member {number} idx
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.idx = 0;

        /**
         * Troop eid.
         * @member {number} eid
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.eid = 0;

        /**
         * Troop heroUid.
         * @member {number} heroUid
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.heroUid = 0;

        /**
         * Troop soldierId.
         * @member {number} soldierId
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.soldierId = 0;

        /**
         * Troop soldierAmount.
         * @member {number} soldierAmount
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.soldierAmount = 0;

        /**
         * Creates a new Troop instance using the specified properties.
         * @function create
         * @memberof troop.Troop
         * @static
         * @param {troop.ITroop=} [properties] Properties to set
         * @returns {troop.Troop} Troop instance
         */
        Troop.create = function create(properties) {
            return new Troop(properties);
        };

        /**
         * Encodes the specified Troop message. Does not implicitly {@link troop.Troop.verify|verify} messages.
         * @function encode
         * @memberof troop.Troop
         * @static
         * @param {troop.ITroop} message Troop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Troop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idx);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.eid);
            if (message.heroUid != null && Object.hasOwnProperty.call(message, "heroUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heroUid);
            if (message.soldierId != null && Object.hasOwnProperty.call(message, "soldierId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.soldierId);
            if (message.soldierAmount != null && Object.hasOwnProperty.call(message, "soldierAmount"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.soldierAmount);
            return writer;
        };

        /**
         * Encodes the specified Troop message, length delimited. Does not implicitly {@link troop.Troop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof troop.Troop
         * @static
         * @param {troop.ITroop} message Troop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Troop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Troop message from the specified reader or buffer.
         * @function decode
         * @memberof troop.Troop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {troop.Troop} Troop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Troop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.troop.Troop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idx = reader.uint32();
                        break;
                    }
                case 2: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.heroUid = reader.uint32();
                        break;
                    }
                case 4: {
                        message.soldierId = reader.uint32();
                        break;
                    }
                case 5: {
                        message.soldierAmount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Troop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof troop.Troop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {troop.Troop} Troop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Troop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Troop message.
         * @function verify
         * @memberof troop.Troop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Troop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.heroUid != null && message.hasOwnProperty("heroUid"))
                if (!$util.isInteger(message.heroUid))
                    return "heroUid: integer expected";
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                if (!$util.isInteger(message.soldierId))
                    return "soldierId: integer expected";
            if (message.soldierAmount != null && message.hasOwnProperty("soldierAmount"))
                if (!$util.isInteger(message.soldierAmount))
                    return "soldierAmount: integer expected";
            return null;
        };

        /**
         * Creates a Troop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof troop.Troop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {troop.Troop} Troop
         */
        Troop.fromObject = function fromObject(object) {
            if (object instanceof $root.troop.Troop)
                return object;
            var message = new $root.troop.Troop();
            if (object.idx != null)
                message.idx = object.idx >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.heroUid != null)
                message.heroUid = object.heroUid >>> 0;
            if (object.soldierId != null)
                message.soldierId = object.soldierId >>> 0;
            if (object.soldierAmount != null)
                message.soldierAmount = object.soldierAmount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Troop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof troop.Troop
         * @static
         * @param {troop.Troop} message Troop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Troop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.idx = 0;
                object.eid = 0;
                object.heroUid = 0;
                object.soldierId = 0;
                object.soldierAmount = 0;
            }
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.heroUid != null && message.hasOwnProperty("heroUid"))
                object.heroUid = message.heroUid;
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                object.soldierId = message.soldierId;
            if (message.soldierAmount != null && message.hasOwnProperty("soldierAmount"))
                object.soldierAmount = message.soldierAmount;
            return object;
        };

        /**
         * Converts this Troop to JSON.
         * @function toJSON
         * @memberof troop.Troop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Troop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Troop
         * @function getTypeUrl
         * @memberof troop.Troop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Troop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/troop.Troop";
        };

        return Troop;
    })();

    troop.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof troop
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof troop
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {troop.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof troop.c2s_load
         * @static
         * @param {troop.Ic2s_load=} [properties] Properties to set
         * @returns {troop.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link troop.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof troop.c2s_load
         * @static
         * @param {troop.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link troop.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof troop.c2s_load
         * @static
         * @param {troop.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof troop.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {troop.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.troop.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof troop.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {troop.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof troop.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof troop.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {troop.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.troop.c2s_load)
                return object;
            return new $root.troop.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof troop.c2s_load
         * @static
         * @param {troop.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof troop.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof troop.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/troop.c2s_load";
        };

        return c2s_load;
    })();

    troop.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof troop
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<troop.ITroop>|null} [troopList] s2c_load troopList
         */

        /**
         * Constructs a new s2c_load.
         * @memberof troop
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {troop.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.troopList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof troop.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load troopList.
         * @member {Array.<troop.ITroop>} troopList
         * @memberof troop.s2c_load
         * @instance
         */
        s2c_load.prototype.troopList = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof troop.s2c_load
         * @static
         * @param {troop.Is2c_load=} [properties] Properties to set
         * @returns {troop.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link troop.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof troop.s2c_load
         * @static
         * @param {troop.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.troopList != null && message.troopList.length)
                for (var i = 0; i < message.troopList.length; ++i)
                    $root.troop.Troop.encode(message.troopList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link troop.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof troop.s2c_load
         * @static
         * @param {troop.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof troop.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {troop.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.troop.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.troopList && message.troopList.length))
                            message.troopList = [];
                        message.troopList.push($root.troop.Troop.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof troop.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {troop.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof troop.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.troopList != null && message.hasOwnProperty("troopList")) {
                if (!Array.isArray(message.troopList))
                    return "troopList: array expected";
                for (var i = 0; i < message.troopList.length; ++i) {
                    var error = $root.troop.Troop.verify(message.troopList[i]);
                    if (error)
                        return "troopList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof troop.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {troop.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.troop.s2c_load)
                return object;
            var message = new $root.troop.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.troopList) {
                if (!Array.isArray(object.troopList))
                    throw TypeError(".troop.s2c_load.troopList: array expected");
                message.troopList = [];
                for (var i = 0; i < object.troopList.length; ++i) {
                    if (typeof object.troopList[i] !== "object")
                        throw TypeError(".troop.s2c_load.troopList: object expected");
                    message.troopList[i] = $root.troop.Troop.fromObject(object.troopList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof troop.s2c_load
         * @static
         * @param {troop.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.troopList = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.troopList && message.troopList.length) {
                object.troopList = [];
                for (var j = 0; j < message.troopList.length; ++j)
                    object.troopList[j] = $root.troop.Troop.toObject(message.troopList[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof troop.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof troop.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/troop.s2c_load";
        };

        return s2c_load;
    })();

    return troop;
})();

$root.user = (function() {

    /**
     * Namespace user.
     * @exports user
     * @namespace
     */
    var user = {};

    user.UserInfo = (function() {

        /**
         * Properties of a UserInfo.
         * @memberof user
         * @interface IUserInfo
         * @property {string|null} [uid] UserInfo uid
         */

        /**
         * Constructs a new UserInfo.
         * @memberof user
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {user.IUserInfo=} [properties] Properties to set
         */
        function UserInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfo uid.
         * @member {string} uid
         * @memberof user.UserInfo
         * @instance
         */
        UserInfo.prototype.uid = "";

        /**
         * Creates a new UserInfo instance using the specified properties.
         * @function create
         * @memberof user.UserInfo
         * @static
         * @param {user.IUserInfo=} [properties] Properties to set
         * @returns {user.UserInfo} UserInfo instance
         */
        UserInfo.create = function create(properties) {
            return new UserInfo(properties);
        };

        /**
         * Encodes the specified UserInfo message. Does not implicitly {@link user.UserInfo.verify|verify} messages.
         * @function encode
         * @memberof user.UserInfo
         * @static
         * @param {user.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
            return writer;
        };

        /**
         * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link user.UserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.UserInfo
         * @static
         * @param {user.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof user.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.UserInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfo message.
         * @function verify
         * @memberof user.UserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isString(message.uid))
                    return "uid: string expected";
            return null;
        };

        /**
         * Creates a UserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.UserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.UserInfo} UserInfo
         */
        UserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.user.UserInfo)
                return object;
            var message = new $root.user.UserInfo();
            if (object.uid != null)
                message.uid = String(object.uid);
            return message;
        };

        /**
         * Creates a plain object from a UserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.UserInfo
         * @static
         * @param {user.UserInfo} message UserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.uid = "";
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            return object;
        };

        /**
         * Converts this UserInfo to JSON.
         * @function toJSON
         * @memberof user.UserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfo
         * @function getTypeUrl
         * @memberof user.UserInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.UserInfo";
        };

        return UserInfo;
    })();

    user.RoleInfo = (function() {

        /**
         * Properties of a RoleInfo.
         * @memberof user
         * @interface IRoleInfo
         * @property {number|Long|null} [rid] RoleInfo rid
         */

        /**
         * Constructs a new RoleInfo.
         * @memberof user
         * @classdesc Represents a RoleInfo.
         * @implements IRoleInfo
         * @constructor
         * @param {user.IRoleInfo=} [properties] Properties to set
         */
        function RoleInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoleInfo rid.
         * @member {number|Long} rid
         * @memberof user.RoleInfo
         * @instance
         */
        RoleInfo.prototype.rid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RoleInfo instance using the specified properties.
         * @function create
         * @memberof user.RoleInfo
         * @static
         * @param {user.IRoleInfo=} [properties] Properties to set
         * @returns {user.RoleInfo} RoleInfo instance
         */
        RoleInfo.create = function create(properties) {
            return new RoleInfo(properties);
        };

        /**
         * Encodes the specified RoleInfo message. Does not implicitly {@link user.RoleInfo.verify|verify} messages.
         * @function encode
         * @memberof user.RoleInfo
         * @static
         * @param {user.IRoleInfo} message RoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rid);
            return writer;
        };

        /**
         * Encodes the specified RoleInfo message, length delimited. Does not implicitly {@link user.RoleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.RoleInfo
         * @static
         * @param {user.IRoleInfo} message RoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof user.RoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.RoleInfo} RoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.RoleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.RoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.RoleInfo} RoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoleInfo message.
         * @function verify
         * @memberof user.RoleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid) && !(message.rid && $util.isInteger(message.rid.low) && $util.isInteger(message.rid.high)))
                    return "rid: integer|Long expected";
            return null;
        };

        /**
         * Creates a RoleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.RoleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.RoleInfo} RoleInfo
         */
        RoleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.user.RoleInfo)
                return object;
            var message = new $root.user.RoleInfo();
            if (object.rid != null)
                if ($util.Long)
                    (message.rid = $util.Long.fromValue(object.rid)).unsigned = false;
                else if (typeof object.rid === "string")
                    message.rid = parseInt(object.rid, 10);
                else if (typeof object.rid === "number")
                    message.rid = object.rid;
                else if (typeof object.rid === "object")
                    message.rid = new $util.LongBits(object.rid.low >>> 0, object.rid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RoleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.RoleInfo
         * @static
         * @param {user.RoleInfo} message RoleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.rid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rid = options.longs === String ? "0" : 0;
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (typeof message.rid === "number")
                    object.rid = options.longs === String ? String(message.rid) : message.rid;
                else
                    object.rid = options.longs === String ? $util.Long.prototype.toString.call(message.rid) : options.longs === Number ? new $util.LongBits(message.rid.low >>> 0, message.rid.high >>> 0).toNumber() : message.rid;
            return object;
        };

        /**
         * Converts this RoleInfo to JSON.
         * @function toJSON
         * @memberof user.RoleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RoleInfo
         * @function getTypeUrl
         * @memberof user.RoleInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.RoleInfo";
        };

        return RoleInfo;
    })();

    user.c2s_login = (function() {

        /**
         * Properties of a c2s_login.
         * @memberof user
         * @interface Ic2s_login
         * @property {string|null} [uid] c2s_login uid
         */

        /**
         * Constructs a new c2s_login.
         * @memberof user
         * @classdesc Represents a c2s_login.
         * @implements Ic2s_login
         * @constructor
         * @param {user.Ic2s_login=} [properties] Properties to set
         */
        function c2s_login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_login uid.
         * @member {string} uid
         * @memberof user.c2s_login
         * @instance
         */
        c2s_login.prototype.uid = "";

        /**
         * Creates a new c2s_login instance using the specified properties.
         * @function create
         * @memberof user.c2s_login
         * @static
         * @param {user.Ic2s_login=} [properties] Properties to set
         * @returns {user.c2s_login} c2s_login instance
         */
        c2s_login.create = function create(properties) {
            return new c2s_login(properties);
        };

        /**
         * Encodes the specified c2s_login message. Does not implicitly {@link user.c2s_login.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_login
         * @static
         * @param {user.Ic2s_login} message c2s_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
            return writer;
        };

        /**
         * Encodes the specified c2s_login message, length delimited. Does not implicitly {@link user.c2s_login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_login
         * @static
         * @param {user.Ic2s_login} message c2s_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_login message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_login} c2s_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_login} c2s_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_login message.
         * @function verify
         * @memberof user.c2s_login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isString(message.uid))
                    return "uid: string expected";
            return null;
        };

        /**
         * Creates a c2s_login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_login} c2s_login
         */
        c2s_login.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_login)
                return object;
            var message = new $root.user.c2s_login();
            if (object.uid != null)
                message.uid = String(object.uid);
            return message;
        };

        /**
         * Creates a plain object from a c2s_login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_login
         * @static
         * @param {user.c2s_login} message c2s_login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.uid = "";
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            return object;
        };

        /**
         * Converts this c2s_login to JSON.
         * @function toJSON
         * @memberof user.c2s_login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_login
         * @function getTypeUrl
         * @memberof user.c2s_login
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_login.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_login";
        };

        return c2s_login;
    })();

    user.s2c_login = (function() {

        /**
         * Properties of a s2c_login.
         * @memberof user
         * @interface Is2c_login
         * @property {number|null} [err] s2c_login err
         * @property {user.IUserInfo|null} [info] s2c_login info
         * @property {user.IRoleInfo|null} [role] s2c_login role
         */

        /**
         * Constructs a new s2c_login.
         * @memberof user
         * @classdesc Represents a s2c_login.
         * @implements Is2c_login
         * @constructor
         * @param {user.Is2c_login=} [properties] Properties to set
         */
        function s2c_login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_login err.
         * @member {number} err
         * @memberof user.s2c_login
         * @instance
         */
        s2c_login.prototype.err = 0;

        /**
         * s2c_login info.
         * @member {user.IUserInfo|null|undefined} info
         * @memberof user.s2c_login
         * @instance
         */
        s2c_login.prototype.info = null;

        /**
         * s2c_login role.
         * @member {user.IRoleInfo|null|undefined} role
         * @memberof user.s2c_login
         * @instance
         */
        s2c_login.prototype.role = null;

        /**
         * Creates a new s2c_login instance using the specified properties.
         * @function create
         * @memberof user.s2c_login
         * @static
         * @param {user.Is2c_login=} [properties] Properties to set
         * @returns {user.s2c_login} s2c_login instance
         */
        s2c_login.create = function create(properties) {
            return new s2c_login(properties);
        };

        /**
         * Encodes the specified s2c_login message. Does not implicitly {@link user.s2c_login.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_login
         * @static
         * @param {user.Is2c_login} message s2c_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.user.UserInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                $root.user.RoleInfo.encode(message.role, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_login message, length delimited. Does not implicitly {@link user.s2c_login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_login
         * @static
         * @param {user.Is2c_login} message s2c_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_login message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_login} s2c_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.info = $root.user.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.role = $root.user.RoleInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_login} s2c_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_login message.
         * @function verify
         * @memberof user.s2c_login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.user.UserInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.role != null && message.hasOwnProperty("role")) {
                var error = $root.user.RoleInfo.verify(message.role);
                if (error)
                    return "role." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_login} s2c_login
         */
        s2c_login.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_login)
                return object;
            var message = new $root.user.s2c_login();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".user.s2c_login.info: object expected");
                message.info = $root.user.UserInfo.fromObject(object.info);
            }
            if (object.role != null) {
                if (typeof object.role !== "object")
                    throw TypeError(".user.s2c_login.role: object expected");
                message.role = $root.user.RoleInfo.fromObject(object.role);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_login
         * @static
         * @param {user.s2c_login} message s2c_login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.info = null;
                object.role = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.user.UserInfo.toObject(message.info, options);
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = $root.user.RoleInfo.toObject(message.role, options);
            return object;
        };

        /**
         * Converts this s2c_login to JSON.
         * @function toJSON
         * @memberof user.s2c_login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_login
         * @function getTypeUrl
         * @memberof user.s2c_login
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_login.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_login";
        };

        return s2c_login;
    })();

    user.c2s_random_name = (function() {

        /**
         * Properties of a c2s_random_name.
         * @memberof user
         * @interface Ic2s_random_name
         */

        /**
         * Constructs a new c2s_random_name.
         * @memberof user
         * @classdesc Represents a c2s_random_name.
         * @implements Ic2s_random_name
         * @constructor
         * @param {user.Ic2s_random_name=} [properties] Properties to set
         */
        function c2s_random_name(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_random_name instance using the specified properties.
         * @function create
         * @memberof user.c2s_random_name
         * @static
         * @param {user.Ic2s_random_name=} [properties] Properties to set
         * @returns {user.c2s_random_name} c2s_random_name instance
         */
        c2s_random_name.create = function create(properties) {
            return new c2s_random_name(properties);
        };

        /**
         * Encodes the specified c2s_random_name message. Does not implicitly {@link user.c2s_random_name.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_random_name
         * @static
         * @param {user.Ic2s_random_name} message c2s_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_random_name.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_random_name message, length delimited. Does not implicitly {@link user.c2s_random_name.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_random_name
         * @static
         * @param {user.Ic2s_random_name} message c2s_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_random_name.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_random_name message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_random_name} c2s_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_random_name.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_random_name();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_random_name message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_random_name} c2s_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_random_name.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_random_name message.
         * @function verify
         * @memberof user.c2s_random_name
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_random_name.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_random_name message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_random_name
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_random_name} c2s_random_name
         */
        c2s_random_name.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_random_name)
                return object;
            return new $root.user.c2s_random_name();
        };

        /**
         * Creates a plain object from a c2s_random_name message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_random_name
         * @static
         * @param {user.c2s_random_name} message c2s_random_name
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_random_name.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_random_name to JSON.
         * @function toJSON
         * @memberof user.c2s_random_name
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_random_name.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_random_name
         * @function getTypeUrl
         * @memberof user.c2s_random_name
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_random_name.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_random_name";
        };

        return c2s_random_name;
    })();

    user.s2c_random_name = (function() {

        /**
         * Properties of a s2c_random_name.
         * @memberof user
         * @interface Is2c_random_name
         * @property {number|null} [err] s2c_random_name err
         * @property {string|null} [name] s2c_random_name name
         */

        /**
         * Constructs a new s2c_random_name.
         * @memberof user
         * @classdesc Represents a s2c_random_name.
         * @implements Is2c_random_name
         * @constructor
         * @param {user.Is2c_random_name=} [properties] Properties to set
         */
        function s2c_random_name(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_random_name err.
         * @member {number} err
         * @memberof user.s2c_random_name
         * @instance
         */
        s2c_random_name.prototype.err = 0;

        /**
         * s2c_random_name name.
         * @member {string} name
         * @memberof user.s2c_random_name
         * @instance
         */
        s2c_random_name.prototype.name = "";

        /**
         * Creates a new s2c_random_name instance using the specified properties.
         * @function create
         * @memberof user.s2c_random_name
         * @static
         * @param {user.Is2c_random_name=} [properties] Properties to set
         * @returns {user.s2c_random_name} s2c_random_name instance
         */
        s2c_random_name.create = function create(properties) {
            return new s2c_random_name(properties);
        };

        /**
         * Encodes the specified s2c_random_name message. Does not implicitly {@link user.s2c_random_name.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_random_name
         * @static
         * @param {user.Is2c_random_name} message s2c_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_random_name.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified s2c_random_name message, length delimited. Does not implicitly {@link user.s2c_random_name.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_random_name
         * @static
         * @param {user.Is2c_random_name} message s2c_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_random_name.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_random_name message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_random_name} s2c_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_random_name.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_random_name();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_random_name message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_random_name} s2c_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_random_name.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_random_name message.
         * @function verify
         * @memberof user.s2c_random_name
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_random_name.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a s2c_random_name message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_random_name
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_random_name} s2c_random_name
         */
        s2c_random_name.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_random_name)
                return object;
            var message = new $root.user.s2c_random_name();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a s2c_random_name message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_random_name
         * @static
         * @param {user.s2c_random_name} message s2c_random_name
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_random_name.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.name = "";
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this s2c_random_name to JSON.
         * @function toJSON
         * @memberof user.s2c_random_name
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_random_name.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_random_name
         * @function getTypeUrl
         * @memberof user.s2c_random_name
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_random_name.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_random_name";
        };

        return s2c_random_name;
    })();

    user.c2s_create_role = (function() {

        /**
         * Properties of a c2s_create_role.
         * @memberof user
         * @interface Ic2s_create_role
         * @property {string|null} [name] c2s_create_role name
         */

        /**
         * Constructs a new c2s_create_role.
         * @memberof user
         * @classdesc Represents a c2s_create_role.
         * @implements Ic2s_create_role
         * @constructor
         * @param {user.Ic2s_create_role=} [properties] Properties to set
         */
        function c2s_create_role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_create_role name.
         * @member {string} name
         * @memberof user.c2s_create_role
         * @instance
         */
        c2s_create_role.prototype.name = "";

        /**
         * Creates a new c2s_create_role instance using the specified properties.
         * @function create
         * @memberof user.c2s_create_role
         * @static
         * @param {user.Ic2s_create_role=} [properties] Properties to set
         * @returns {user.c2s_create_role} c2s_create_role instance
         */
        c2s_create_role.create = function create(properties) {
            return new c2s_create_role(properties);
        };

        /**
         * Encodes the specified c2s_create_role message. Does not implicitly {@link user.c2s_create_role.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_create_role
         * @static
         * @param {user.Ic2s_create_role} message c2s_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_create_role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified c2s_create_role message, length delimited. Does not implicitly {@link user.c2s_create_role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_create_role
         * @static
         * @param {user.Ic2s_create_role} message c2s_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_create_role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_create_role message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_create_role} c2s_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_create_role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_create_role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_create_role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_create_role} c2s_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_create_role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_create_role message.
         * @function verify
         * @memberof user.c2s_create_role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_create_role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a c2s_create_role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_create_role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_create_role} c2s_create_role
         */
        c2s_create_role.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_create_role)
                return object;
            var message = new $root.user.c2s_create_role();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a c2s_create_role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_create_role
         * @static
         * @param {user.c2s_create_role} message c2s_create_role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_create_role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this c2s_create_role to JSON.
         * @function toJSON
         * @memberof user.c2s_create_role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_create_role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_create_role
         * @function getTypeUrl
         * @memberof user.c2s_create_role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_create_role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_create_role";
        };

        return c2s_create_role;
    })();

    user.s2c_create_role = (function() {

        /**
         * Properties of a s2c_create_role.
         * @memberof user
         * @interface Is2c_create_role
         * @property {number|null} [err] s2c_create_role err
         * @property {user.IRoleInfo|null} [role] s2c_create_role role
         */

        /**
         * Constructs a new s2c_create_role.
         * @memberof user
         * @classdesc Represents a s2c_create_role.
         * @implements Is2c_create_role
         * @constructor
         * @param {user.Is2c_create_role=} [properties] Properties to set
         */
        function s2c_create_role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_create_role err.
         * @member {number} err
         * @memberof user.s2c_create_role
         * @instance
         */
        s2c_create_role.prototype.err = 0;

        /**
         * s2c_create_role role.
         * @member {user.IRoleInfo|null|undefined} role
         * @memberof user.s2c_create_role
         * @instance
         */
        s2c_create_role.prototype.role = null;

        /**
         * Creates a new s2c_create_role instance using the specified properties.
         * @function create
         * @memberof user.s2c_create_role
         * @static
         * @param {user.Is2c_create_role=} [properties] Properties to set
         * @returns {user.s2c_create_role} s2c_create_role instance
         */
        s2c_create_role.create = function create(properties) {
            return new s2c_create_role(properties);
        };

        /**
         * Encodes the specified s2c_create_role message. Does not implicitly {@link user.s2c_create_role.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_create_role
         * @static
         * @param {user.Is2c_create_role} message s2c_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_create_role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                $root.user.RoleInfo.encode(message.role, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_create_role message, length delimited. Does not implicitly {@link user.s2c_create_role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_create_role
         * @static
         * @param {user.Is2c_create_role} message s2c_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_create_role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_create_role message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_create_role} s2c_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_create_role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_create_role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.role = $root.user.RoleInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_create_role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_create_role} s2c_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_create_role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_create_role message.
         * @function verify
         * @memberof user.s2c_create_role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_create_role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.role != null && message.hasOwnProperty("role")) {
                var error = $root.user.RoleInfo.verify(message.role);
                if (error)
                    return "role." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_create_role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_create_role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_create_role} s2c_create_role
         */
        s2c_create_role.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_create_role)
                return object;
            var message = new $root.user.s2c_create_role();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.role != null) {
                if (typeof object.role !== "object")
                    throw TypeError(".user.s2c_create_role.role: object expected");
                message.role = $root.user.RoleInfo.fromObject(object.role);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_create_role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_create_role
         * @static
         * @param {user.s2c_create_role} message s2c_create_role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_create_role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.role = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = $root.user.RoleInfo.toObject(message.role, options);
            return object;
        };

        /**
         * Converts this s2c_create_role to JSON.
         * @function toJSON
         * @memberof user.s2c_create_role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_create_role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_create_role
         * @function getTypeUrl
         * @memberof user.s2c_create_role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_create_role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_create_role";
        };

        return s2c_create_role;
    })();

    user.c2s_ping = (function() {

        /**
         * Properties of a c2s_ping.
         * @memberof user
         * @interface Ic2s_ping
         */

        /**
         * Constructs a new c2s_ping.
         * @memberof user
         * @classdesc Represents a c2s_ping.
         * @implements Ic2s_ping
         * @constructor
         * @param {user.Ic2s_ping=} [properties] Properties to set
         */
        function c2s_ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_ping instance using the specified properties.
         * @function create
         * @memberof user.c2s_ping
         * @static
         * @param {user.Ic2s_ping=} [properties] Properties to set
         * @returns {user.c2s_ping} c2s_ping instance
         */
        c2s_ping.create = function create(properties) {
            return new c2s_ping(properties);
        };

        /**
         * Encodes the specified c2s_ping message. Does not implicitly {@link user.c2s_ping.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_ping
         * @static
         * @param {user.Ic2s_ping} message c2s_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_ping message, length delimited. Does not implicitly {@link user.c2s_ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_ping
         * @static
         * @param {user.Ic2s_ping} message c2s_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_ping message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_ping} c2s_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_ping} c2s_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_ping message.
         * @function verify
         * @memberof user.c2s_ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_ping} c2s_ping
         */
        c2s_ping.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_ping)
                return object;
            return new $root.user.c2s_ping();
        };

        /**
         * Creates a plain object from a c2s_ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_ping
         * @static
         * @param {user.c2s_ping} message c2s_ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_ping.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_ping to JSON.
         * @function toJSON
         * @memberof user.c2s_ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_ping
         * @function getTypeUrl
         * @memberof user.c2s_ping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_ping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_ping";
        };

        return c2s_ping;
    })();

    user.s2c_ping = (function() {

        /**
         * Properties of a s2c_ping.
         * @memberof user
         * @interface Is2c_ping
         * @property {number|null} [err] s2c_ping err
         */

        /**
         * Constructs a new s2c_ping.
         * @memberof user
         * @classdesc Represents a s2c_ping.
         * @implements Is2c_ping
         * @constructor
         * @param {user.Is2c_ping=} [properties] Properties to set
         */
        function s2c_ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_ping err.
         * @member {number} err
         * @memberof user.s2c_ping
         * @instance
         */
        s2c_ping.prototype.err = 0;

        /**
         * Creates a new s2c_ping instance using the specified properties.
         * @function create
         * @memberof user.s2c_ping
         * @static
         * @param {user.Is2c_ping=} [properties] Properties to set
         * @returns {user.s2c_ping} s2c_ping instance
         */
        s2c_ping.create = function create(properties) {
            return new s2c_ping(properties);
        };

        /**
         * Encodes the specified s2c_ping message. Does not implicitly {@link user.s2c_ping.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_ping
         * @static
         * @param {user.Is2c_ping} message s2c_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_ping message, length delimited. Does not implicitly {@link user.s2c_ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_ping
         * @static
         * @param {user.Is2c_ping} message s2c_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_ping message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_ping} s2c_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_ping} s2c_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_ping message.
         * @function verify
         * @memberof user.s2c_ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_ping} s2c_ping
         */
        s2c_ping.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_ping)
                return object;
            var message = new $root.user.s2c_ping();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_ping
         * @static
         * @param {user.s2c_ping} message s2c_ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_ping to JSON.
         * @function toJSON
         * @memberof user.s2c_ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_ping
         * @function getTypeUrl
         * @memberof user.s2c_ping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_ping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_ping";
        };

        return s2c_ping;
    })();

    user.c2s_gm = (function() {

        /**
         * Properties of a c2s_gm.
         * @memberof user
         * @interface Ic2s_gm
         * @property {string|null} [cmd] c2s_gm cmd
         */

        /**
         * Constructs a new c2s_gm.
         * @memberof user
         * @classdesc Represents a c2s_gm.
         * @implements Ic2s_gm
         * @constructor
         * @param {user.Ic2s_gm=} [properties] Properties to set
         */
        function c2s_gm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_gm cmd.
         * @member {string} cmd
         * @memberof user.c2s_gm
         * @instance
         */
        c2s_gm.prototype.cmd = "";

        /**
         * Creates a new c2s_gm instance using the specified properties.
         * @function create
         * @memberof user.c2s_gm
         * @static
         * @param {user.Ic2s_gm=} [properties] Properties to set
         * @returns {user.c2s_gm} c2s_gm instance
         */
        c2s_gm.create = function create(properties) {
            return new c2s_gm(properties);
        };

        /**
         * Encodes the specified c2s_gm message. Does not implicitly {@link user.c2s_gm.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_gm
         * @static
         * @param {user.Ic2s_gm} message c2s_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_gm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            return writer;
        };

        /**
         * Encodes the specified c2s_gm message, length delimited. Does not implicitly {@link user.c2s_gm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_gm
         * @static
         * @param {user.Ic2s_gm} message c2s_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_gm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_gm message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_gm} c2s_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_gm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_gm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmd = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_gm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_gm} c2s_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_gm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_gm message.
         * @function verify
         * @memberof user.c2s_gm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_gm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isString(message.cmd))
                    return "cmd: string expected";
            return null;
        };

        /**
         * Creates a c2s_gm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_gm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_gm} c2s_gm
         */
        c2s_gm.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_gm)
                return object;
            var message = new $root.user.c2s_gm();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            return message;
        };

        /**
         * Creates a plain object from a c2s_gm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_gm
         * @static
         * @param {user.c2s_gm} message c2s_gm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_gm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cmd = "";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            return object;
        };

        /**
         * Converts this c2s_gm to JSON.
         * @function toJSON
         * @memberof user.c2s_gm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_gm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_gm
         * @function getTypeUrl
         * @memberof user.c2s_gm
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_gm.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_gm";
        };

        return c2s_gm;
    })();

    user.s2c_gm = (function() {

        /**
         * Properties of a s2c_gm.
         * @memberof user
         * @interface Is2c_gm
         * @property {number|null} [err] s2c_gm err
         * @property {string|null} [msg] s2c_gm msg
         */

        /**
         * Constructs a new s2c_gm.
         * @memberof user
         * @classdesc Represents a s2c_gm.
         * @implements Is2c_gm
         * @constructor
         * @param {user.Is2c_gm=} [properties] Properties to set
         */
        function s2c_gm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_gm err.
         * @member {number} err
         * @memberof user.s2c_gm
         * @instance
         */
        s2c_gm.prototype.err = 0;

        /**
         * s2c_gm msg.
         * @member {string} msg
         * @memberof user.s2c_gm
         * @instance
         */
        s2c_gm.prototype.msg = "";

        /**
         * Creates a new s2c_gm instance using the specified properties.
         * @function create
         * @memberof user.s2c_gm
         * @static
         * @param {user.Is2c_gm=} [properties] Properties to set
         * @returns {user.s2c_gm} s2c_gm instance
         */
        s2c_gm.create = function create(properties) {
            return new s2c_gm(properties);
        };

        /**
         * Encodes the specified s2c_gm message. Does not implicitly {@link user.s2c_gm.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_gm
         * @static
         * @param {user.Is2c_gm} message s2c_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_gm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
            return writer;
        };

        /**
         * Encodes the specified s2c_gm message, length delimited. Does not implicitly {@link user.s2c_gm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_gm
         * @static
         * @param {user.Is2c_gm} message s2c_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_gm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_gm message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_gm} s2c_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_gm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_gm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.msg = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_gm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_gm} s2c_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_gm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_gm message.
         * @function verify
         * @memberof user.s2c_gm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_gm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            return null;
        };

        /**
         * Creates a s2c_gm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_gm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_gm} s2c_gm
         */
        s2c_gm.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_gm)
                return object;
            var message = new $root.user.s2c_gm();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.msg != null)
                message.msg = String(object.msg);
            return message;
        };

        /**
         * Creates a plain object from a s2c_gm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_gm
         * @static
         * @param {user.s2c_gm} message s2c_gm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_gm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.msg = "";
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            return object;
        };

        /**
         * Converts this s2c_gm to JSON.
         * @function toJSON
         * @memberof user.s2c_gm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_gm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_gm
         * @function getTypeUrl
         * @memberof user.s2c_gm
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_gm.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_gm";
        };

        return s2c_gm;
    })();

    user.c2s_rename = (function() {

        /**
         * Properties of a c2s_rename.
         * @memberof user
         * @interface Ic2s_rename
         * @property {string|null} [name] c2s_rename name
         */

        /**
         * Constructs a new c2s_rename.
         * @memberof user
         * @classdesc Represents a c2s_rename.
         * @implements Ic2s_rename
         * @constructor
         * @param {user.Ic2s_rename=} [properties] Properties to set
         */
        function c2s_rename(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_rename name.
         * @member {string} name
         * @memberof user.c2s_rename
         * @instance
         */
        c2s_rename.prototype.name = "";

        /**
         * Creates a new c2s_rename instance using the specified properties.
         * @function create
         * @memberof user.c2s_rename
         * @static
         * @param {user.Ic2s_rename=} [properties] Properties to set
         * @returns {user.c2s_rename} c2s_rename instance
         */
        c2s_rename.create = function create(properties) {
            return new c2s_rename(properties);
        };

        /**
         * Encodes the specified c2s_rename message. Does not implicitly {@link user.c2s_rename.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_rename
         * @static
         * @param {user.Ic2s_rename} message c2s_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_rename.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified c2s_rename message, length delimited. Does not implicitly {@link user.c2s_rename.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_rename
         * @static
         * @param {user.Ic2s_rename} message c2s_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_rename.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_rename message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_rename} c2s_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_rename.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_rename();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_rename message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_rename} c2s_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_rename.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_rename message.
         * @function verify
         * @memberof user.c2s_rename
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_rename.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a c2s_rename message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_rename
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_rename} c2s_rename
         */
        c2s_rename.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_rename)
                return object;
            var message = new $root.user.c2s_rename();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a c2s_rename message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_rename
         * @static
         * @param {user.c2s_rename} message c2s_rename
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_rename.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this c2s_rename to JSON.
         * @function toJSON
         * @memberof user.c2s_rename
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_rename.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_rename
         * @function getTypeUrl
         * @memberof user.c2s_rename
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_rename.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_rename";
        };

        return c2s_rename;
    })();

    user.s2c_rename = (function() {

        /**
         * Properties of a s2c_rename.
         * @memberof user
         * @interface Is2c_rename
         * @property {number|null} [err] s2c_rename err
         */

        /**
         * Constructs a new s2c_rename.
         * @memberof user
         * @classdesc Represents a s2c_rename.
         * @implements Is2c_rename
         * @constructor
         * @param {user.Is2c_rename=} [properties] Properties to set
         */
        function s2c_rename(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_rename err.
         * @member {number} err
         * @memberof user.s2c_rename
         * @instance
         */
        s2c_rename.prototype.err = 0;

        /**
         * Creates a new s2c_rename instance using the specified properties.
         * @function create
         * @memberof user.s2c_rename
         * @static
         * @param {user.Is2c_rename=} [properties] Properties to set
         * @returns {user.s2c_rename} s2c_rename instance
         */
        s2c_rename.create = function create(properties) {
            return new s2c_rename(properties);
        };

        /**
         * Encodes the specified s2c_rename message. Does not implicitly {@link user.s2c_rename.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_rename
         * @static
         * @param {user.Is2c_rename} message s2c_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_rename.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_rename message, length delimited. Does not implicitly {@link user.s2c_rename.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_rename
         * @static
         * @param {user.Is2c_rename} message s2c_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_rename.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_rename message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_rename} s2c_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_rename.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_rename();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_rename message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_rename} s2c_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_rename.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_rename message.
         * @function verify
         * @memberof user.s2c_rename
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_rename.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_rename message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_rename
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_rename} s2c_rename
         */
        s2c_rename.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_rename)
                return object;
            var message = new $root.user.s2c_rename();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_rename message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_rename
         * @static
         * @param {user.s2c_rename} message s2c_rename
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_rename.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_rename to JSON.
         * @function toJSON
         * @memberof user.s2c_rename
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_rename.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_rename
         * @function getTypeUrl
         * @memberof user.s2c_rename
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_rename.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_rename";
        };

        return s2c_rename;
    })();

    return user;
})();

$root.world = (function() {

    /**
     * Namespace world.
     * @exports world
     * @namespace
     */
    var world = {};

    world.Role = (function() {

        /**
         * Properties of a Role.
         * @memberof world
         * @interface IRole
         * @property {number|null} [rid] Role rid
         * @property {string|null} [name] Role name
         * @property {number|null} [aid] Role aid
         */

        /**
         * Constructs a new Role.
         * @memberof world
         * @classdesc Represents a Role.
         * @implements IRole
         * @constructor
         * @param {world.IRole=} [properties] Properties to set
         */
        function Role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Role rid.
         * @member {number} rid
         * @memberof world.Role
         * @instance
         */
        Role.prototype.rid = 0;

        /**
         * Role name.
         * @member {string} name
         * @memberof world.Role
         * @instance
         */
        Role.prototype.name = "";

        /**
         * Role aid.
         * @member {number} aid
         * @memberof world.Role
         * @instance
         */
        Role.prototype.aid = 0;

        /**
         * Creates a new Role instance using the specified properties.
         * @function create
         * @memberof world.Role
         * @static
         * @param {world.IRole=} [properties] Properties to set
         * @returns {world.Role} Role instance
         */
        Role.create = function create(properties) {
            return new Role(properties);
        };

        /**
         * Encodes the specified Role message. Does not implicitly {@link world.Role.verify|verify} messages.
         * @function encode
         * @memberof world.Role
         * @static
         * @param {world.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.aid);
            return writer;
        };

        /**
         * Encodes the specified Role message, length delimited. Does not implicitly {@link world.Role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Role
         * @static
         * @param {world.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Role message from the specified reader or buffer.
         * @function decode
         * @memberof world.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.aid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Role message.
         * @function verify
         * @memberof world.Role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            return null;
        };

        /**
         * Creates a Role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Role} Role
         */
        Role.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Role)
                return object;
            var message = new $root.world.Role();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Role
         * @static
         * @param {world.Role} message Role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rid = 0;
                object.name = "";
                object.aid = 0;
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            return object;
        };

        /**
         * Converts this Role to JSON.
         * @function toJSON
         * @memberof world.Role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Role
         * @function getTypeUrl
         * @memberof world.Role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Role";
        };

        return Role;
    })();

    world.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof world
         * @interface IPosition
         * @property {number|null} [x] Position x
         * @property {number|null} [y] Position y
         */

        /**
         * Constructs a new Position.
         * @memberof world
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {world.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position x.
         * @member {number} x
         * @memberof world.Position
         * @instance
         */
        Position.prototype.x = 0;

        /**
         * Position y.
         * @member {number} y
         * @memberof world.Position
         * @instance
         */
        Position.prototype.y = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof world.Position
         * @static
         * @param {world.IPosition=} [properties] Properties to set
         * @returns {world.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link world.Position.verify|verify} messages.
         * @function encode
         * @memberof world.Position
         * @static
         * @param {world.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link world.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Position
         * @static
         * @param {world.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof world.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Position();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof world.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Position)
                return object;
            var message = new $root.world.Position();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Position
         * @static
         * @param {world.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof world.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof world.Position
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Position";
        };

        return Position;
    })();

    world.Alliance = (function() {

        /**
         * Properties of an Alliance.
         * @memberof world
         * @interface IAlliance
         * @property {number|null} [aid] Alliance aid
         * @property {string|null} [name] Alliance name
         */

        /**
         * Constructs a new Alliance.
         * @memberof world
         * @classdesc Represents an Alliance.
         * @implements IAlliance
         * @constructor
         * @param {world.IAlliance=} [properties] Properties to set
         */
        function Alliance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Alliance aid.
         * @member {number} aid
         * @memberof world.Alliance
         * @instance
         */
        Alliance.prototype.aid = 0;

        /**
         * Alliance name.
         * @member {string} name
         * @memberof world.Alliance
         * @instance
         */
        Alliance.prototype.name = "";

        /**
         * Creates a new Alliance instance using the specified properties.
         * @function create
         * @memberof world.Alliance
         * @static
         * @param {world.IAlliance=} [properties] Properties to set
         * @returns {world.Alliance} Alliance instance
         */
        Alliance.create = function create(properties) {
            return new Alliance(properties);
        };

        /**
         * Encodes the specified Alliance message. Does not implicitly {@link world.Alliance.verify|verify} messages.
         * @function encode
         * @memberof world.Alliance
         * @static
         * @param {world.IAlliance} message Alliance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Alliance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.aid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Alliance message, length delimited. Does not implicitly {@link world.Alliance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Alliance
         * @static
         * @param {world.IAlliance} message Alliance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Alliance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Alliance message from the specified reader or buffer.
         * @function decode
         * @memberof world.Alliance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Alliance} Alliance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Alliance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Alliance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.aid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Alliance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Alliance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Alliance} Alliance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Alliance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Alliance message.
         * @function verify
         * @memberof world.Alliance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Alliance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates an Alliance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Alliance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Alliance} Alliance
         */
        Alliance.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Alliance)
                return object;
            var message = new $root.world.Alliance();
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from an Alliance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Alliance
         * @static
         * @param {world.Alliance} message Alliance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Alliance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.aid = 0;
                object.name = "";
            }
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Alliance to JSON.
         * @function toJSON
         * @memberof world.Alliance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Alliance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Alliance
         * @function getTypeUrl
         * @memberof world.Alliance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Alliance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Alliance";
        };

        return Alliance;
    })();

    world.ComponentTroop = (function() {

        /**
         * Properties of a ComponentTroop.
         * @memberof world
         * @interface IComponentTroop
         * @property {number|null} [soldierId] ComponentTroop soldierId
         * @property {number|null} [cmd] ComponentTroop cmd
         * @property {number|null} [stayEid] ComponentTroop stayEid
         * @property {number|null} [homeEid] ComponentTroop homeEid
         * @property {number|null} [battleEid] ComponentTroop battleEid
         */

        /**
         * Constructs a new ComponentTroop.
         * @memberof world
         * @classdesc Represents a ComponentTroop.
         * @implements IComponentTroop
         * @constructor
         * @param {world.IComponentTroop=} [properties] Properties to set
         */
        function ComponentTroop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ComponentTroop soldierId.
         * @member {number} soldierId
         * @memberof world.ComponentTroop
         * @instance
         */
        ComponentTroop.prototype.soldierId = 0;

        /**
         * ComponentTroop cmd.
         * @member {number} cmd
         * @memberof world.ComponentTroop
         * @instance
         */
        ComponentTroop.prototype.cmd = 0;

        /**
         * ComponentTroop stayEid.
         * @member {number} stayEid
         * @memberof world.ComponentTroop
         * @instance
         */
        ComponentTroop.prototype.stayEid = 0;

        /**
         * ComponentTroop homeEid.
         * @member {number} homeEid
         * @memberof world.ComponentTroop
         * @instance
         */
        ComponentTroop.prototype.homeEid = 0;

        /**
         * ComponentTroop battleEid.
         * @member {number} battleEid
         * @memberof world.ComponentTroop
         * @instance
         */
        ComponentTroop.prototype.battleEid = 0;

        /**
         * Creates a new ComponentTroop instance using the specified properties.
         * @function create
         * @memberof world.ComponentTroop
         * @static
         * @param {world.IComponentTroop=} [properties] Properties to set
         * @returns {world.ComponentTroop} ComponentTroop instance
         */
        ComponentTroop.create = function create(properties) {
            return new ComponentTroop(properties);
        };

        /**
         * Encodes the specified ComponentTroop message. Does not implicitly {@link world.ComponentTroop.verify|verify} messages.
         * @function encode
         * @memberof world.ComponentTroop
         * @static
         * @param {world.IComponentTroop} message ComponentTroop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentTroop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.soldierId != null && Object.hasOwnProperty.call(message, "soldierId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.soldierId);
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cmd);
            if (message.stayEid != null && Object.hasOwnProperty.call(message, "stayEid"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stayEid);
            if (message.homeEid != null && Object.hasOwnProperty.call(message, "homeEid"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.homeEid);
            if (message.battleEid != null && Object.hasOwnProperty.call(message, "battleEid"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.battleEid);
            return writer;
        };

        /**
         * Encodes the specified ComponentTroop message, length delimited. Does not implicitly {@link world.ComponentTroop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ComponentTroop
         * @static
         * @param {world.IComponentTroop} message ComponentTroop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentTroop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ComponentTroop message from the specified reader or buffer.
         * @function decode
         * @memberof world.ComponentTroop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ComponentTroop} ComponentTroop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentTroop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ComponentTroop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.soldierId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.cmd = reader.uint32();
                        break;
                    }
                case 4: {
                        message.stayEid = reader.uint32();
                        break;
                    }
                case 5: {
                        message.homeEid = reader.uint32();
                        break;
                    }
                case 6: {
                        message.battleEid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ComponentTroop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ComponentTroop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ComponentTroop} ComponentTroop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentTroop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ComponentTroop message.
         * @function verify
         * @memberof world.ComponentTroop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComponentTroop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                if (!$util.isInteger(message.soldierId))
                    return "soldierId: integer expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isInteger(message.cmd))
                    return "cmd: integer expected";
            if (message.stayEid != null && message.hasOwnProperty("stayEid"))
                if (!$util.isInteger(message.stayEid))
                    return "stayEid: integer expected";
            if (message.homeEid != null && message.hasOwnProperty("homeEid"))
                if (!$util.isInteger(message.homeEid))
                    return "homeEid: integer expected";
            if (message.battleEid != null && message.hasOwnProperty("battleEid"))
                if (!$util.isInteger(message.battleEid))
                    return "battleEid: integer expected";
            return null;
        };

        /**
         * Creates a ComponentTroop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ComponentTroop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ComponentTroop} ComponentTroop
         */
        ComponentTroop.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ComponentTroop)
                return object;
            var message = new $root.world.ComponentTroop();
            if (object.soldierId != null)
                message.soldierId = object.soldierId >>> 0;
            if (object.cmd != null)
                message.cmd = object.cmd >>> 0;
            if (object.stayEid != null)
                message.stayEid = object.stayEid >>> 0;
            if (object.homeEid != null)
                message.homeEid = object.homeEid >>> 0;
            if (object.battleEid != null)
                message.battleEid = object.battleEid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ComponentTroop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ComponentTroop
         * @static
         * @param {world.ComponentTroop} message ComponentTroop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComponentTroop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.soldierId = 0;
                object.cmd = 0;
                object.stayEid = 0;
                object.homeEid = 0;
                object.battleEid = 0;
            }
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                object.soldierId = message.soldierId;
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            if (message.stayEid != null && message.hasOwnProperty("stayEid"))
                object.stayEid = message.stayEid;
            if (message.homeEid != null && message.hasOwnProperty("homeEid"))
                object.homeEid = message.homeEid;
            if (message.battleEid != null && message.hasOwnProperty("battleEid"))
                object.battleEid = message.battleEid;
            return object;
        };

        /**
         * Converts this ComponentTroop to JSON.
         * @function toJSON
         * @memberof world.ComponentTroop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComponentTroop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ComponentTroop
         * @function getTypeUrl
         * @memberof world.ComponentTroop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComponentTroop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ComponentTroop";
        };

        return ComponentTroop;
    })();

    world.ComponentOwner = (function() {

        /**
         * Properties of a ComponentOwner.
         * @memberof world
         * @interface IComponentOwner
         * @property {number|null} [rid] ComponentOwner rid
         * @property {number|null} [aid] ComponentOwner aid
         * @property {number|null} [eid] ComponentOwner eid
         * @property {boolean|null} [isRobot] ComponentOwner isRobot
         * @property {string|null} [roleName] ComponentOwner roleName
         * @property {string|null} [allianceName] ComponentOwner allianceName
         */

        /**
         * Constructs a new ComponentOwner.
         * @memberof world
         * @classdesc Represents a ComponentOwner.
         * @implements IComponentOwner
         * @constructor
         * @param {world.IComponentOwner=} [properties] Properties to set
         */
        function ComponentOwner(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ComponentOwner rid.
         * @member {number} rid
         * @memberof world.ComponentOwner
         * @instance
         */
        ComponentOwner.prototype.rid = 0;

        /**
         * ComponentOwner aid.
         * @member {number} aid
         * @memberof world.ComponentOwner
         * @instance
         */
        ComponentOwner.prototype.aid = 0;

        /**
         * ComponentOwner eid.
         * @member {number} eid
         * @memberof world.ComponentOwner
         * @instance
         */
        ComponentOwner.prototype.eid = 0;

        /**
         * ComponentOwner isRobot.
         * @member {boolean} isRobot
         * @memberof world.ComponentOwner
         * @instance
         */
        ComponentOwner.prototype.isRobot = false;

        /**
         * ComponentOwner roleName.
         * @member {string} roleName
         * @memberof world.ComponentOwner
         * @instance
         */
        ComponentOwner.prototype.roleName = "";

        /**
         * ComponentOwner allianceName.
         * @member {string} allianceName
         * @memberof world.ComponentOwner
         * @instance
         */
        ComponentOwner.prototype.allianceName = "";

        /**
         * Creates a new ComponentOwner instance using the specified properties.
         * @function create
         * @memberof world.ComponentOwner
         * @static
         * @param {world.IComponentOwner=} [properties] Properties to set
         * @returns {world.ComponentOwner} ComponentOwner instance
         */
        ComponentOwner.create = function create(properties) {
            return new ComponentOwner(properties);
        };

        /**
         * Encodes the specified ComponentOwner message. Does not implicitly {@link world.ComponentOwner.verify|verify} messages.
         * @function encode
         * @memberof world.ComponentOwner
         * @static
         * @param {world.IComponentOwner} message ComponentOwner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentOwner.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.aid);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.eid);
            if (message.isRobot != null && Object.hasOwnProperty.call(message, "isRobot"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRobot);
            if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.roleName);
            if (message.allianceName != null && Object.hasOwnProperty.call(message, "allianceName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.allianceName);
            return writer;
        };

        /**
         * Encodes the specified ComponentOwner message, length delimited. Does not implicitly {@link world.ComponentOwner.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ComponentOwner
         * @static
         * @param {world.IComponentOwner} message ComponentOwner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentOwner.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ComponentOwner message from the specified reader or buffer.
         * @function decode
         * @memberof world.ComponentOwner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ComponentOwner} ComponentOwner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentOwner.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ComponentOwner();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.aid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 4: {
                        message.isRobot = reader.bool();
                        break;
                    }
                case 5: {
                        message.roleName = reader.string();
                        break;
                    }
                case 6: {
                        message.allianceName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ComponentOwner message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ComponentOwner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ComponentOwner} ComponentOwner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentOwner.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ComponentOwner message.
         * @function verify
         * @memberof world.ComponentOwner
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComponentOwner.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.isRobot != null && message.hasOwnProperty("isRobot"))
                if (typeof message.isRobot !== "boolean")
                    return "isRobot: boolean expected";
            if (message.roleName != null && message.hasOwnProperty("roleName"))
                if (!$util.isString(message.roleName))
                    return "roleName: string expected";
            if (message.allianceName != null && message.hasOwnProperty("allianceName"))
                if (!$util.isString(message.allianceName))
                    return "allianceName: string expected";
            return null;
        };

        /**
         * Creates a ComponentOwner message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ComponentOwner
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ComponentOwner} ComponentOwner
         */
        ComponentOwner.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ComponentOwner)
                return object;
            var message = new $root.world.ComponentOwner();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.isRobot != null)
                message.isRobot = Boolean(object.isRobot);
            if (object.roleName != null)
                message.roleName = String(object.roleName);
            if (object.allianceName != null)
                message.allianceName = String(object.allianceName);
            return message;
        };

        /**
         * Creates a plain object from a ComponentOwner message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ComponentOwner
         * @static
         * @param {world.ComponentOwner} message ComponentOwner
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComponentOwner.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rid = 0;
                object.aid = 0;
                object.eid = 0;
                object.isRobot = false;
                object.roleName = "";
                object.allianceName = "";
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.isRobot != null && message.hasOwnProperty("isRobot"))
                object.isRobot = message.isRobot;
            if (message.roleName != null && message.hasOwnProperty("roleName"))
                object.roleName = message.roleName;
            if (message.allianceName != null && message.hasOwnProperty("allianceName"))
                object.allianceName = message.allianceName;
            return object;
        };

        /**
         * Converts this ComponentOwner to JSON.
         * @function toJSON
         * @memberof world.ComponentOwner
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComponentOwner.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ComponentOwner
         * @function getTypeUrl
         * @memberof world.ComponentOwner
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComponentOwner.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ComponentOwner";
        };

        return ComponentOwner;
    })();

    world.Timer = (function() {

        /**
         * Properties of a Timer.
         * @memberof world
         * @interface ITimer
         * @property {number|null} [type] Timer type
         * @property {number|null} [start] Timer start
         * @property {number|null} [expire] Timer expire
         */

        /**
         * Constructs a new Timer.
         * @memberof world
         * @classdesc Represents a Timer.
         * @implements ITimer
         * @constructor
         * @param {world.ITimer=} [properties] Properties to set
         */
        function Timer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timer type.
         * @member {number} type
         * @memberof world.Timer
         * @instance
         */
        Timer.prototype.type = 0;

        /**
         * Timer start.
         * @member {number} start
         * @memberof world.Timer
         * @instance
         */
        Timer.prototype.start = 0;

        /**
         * Timer expire.
         * @member {number} expire
         * @memberof world.Timer
         * @instance
         */
        Timer.prototype.expire = 0;

        /**
         * Creates a new Timer instance using the specified properties.
         * @function create
         * @memberof world.Timer
         * @static
         * @param {world.ITimer=} [properties] Properties to set
         * @returns {world.Timer} Timer instance
         */
        Timer.create = function create(properties) {
            return new Timer(properties);
        };

        /**
         * Encodes the specified Timer message. Does not implicitly {@link world.Timer.verify|verify} messages.
         * @function encode
         * @memberof world.Timer
         * @static
         * @param {world.ITimer} message Timer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.start);
            if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expire);
            return writer;
        };

        /**
         * Encodes the specified Timer message, length delimited. Does not implicitly {@link world.Timer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Timer
         * @static
         * @param {world.ITimer} message Timer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timer message from the specified reader or buffer.
         * @function decode
         * @memberof world.Timer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Timer} Timer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Timer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.uint32();
                        break;
                    }
                case 2: {
                        message.start = reader.uint32();
                        break;
                    }
                case 3: {
                        message.expire = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Timer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Timer} Timer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timer message.
         * @function verify
         * @memberof world.Timer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (!$util.isInteger(message.start))
                    return "start: integer expected";
            if (message.expire != null && message.hasOwnProperty("expire"))
                if (!$util.isInteger(message.expire))
                    return "expire: integer expected";
            return null;
        };

        /**
         * Creates a Timer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Timer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Timer} Timer
         */
        Timer.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Timer)
                return object;
            var message = new $root.world.Timer();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.start != null)
                message.start = object.start >>> 0;
            if (object.expire != null)
                message.expire = object.expire >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Timer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Timer
         * @static
         * @param {world.Timer} message Timer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.start = 0;
                object.expire = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = message.start;
            if (message.expire != null && message.hasOwnProperty("expire"))
                object.expire = message.expire;
            return object;
        };

        /**
         * Converts this Timer to JSON.
         * @function toJSON
         * @memberof world.Timer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Timer
         * @function getTypeUrl
         * @memberof world.Timer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Timer";
        };

        return Timer;
    })();

    world.ComponentTimer = (function() {

        /**
         * Properties of a ComponentTimer.
         * @memberof world
         * @interface IComponentTimer
         * @property {Object.<string,world.ITimer>|null} [timers] ComponentTimer timers
         */

        /**
         * Constructs a new ComponentTimer.
         * @memberof world
         * @classdesc Represents a ComponentTimer.
         * @implements IComponentTimer
         * @constructor
         * @param {world.IComponentTimer=} [properties] Properties to set
         */
        function ComponentTimer(properties) {
            this.timers = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ComponentTimer timers.
         * @member {Object.<string,world.ITimer>} timers
         * @memberof world.ComponentTimer
         * @instance
         */
        ComponentTimer.prototype.timers = $util.emptyObject;

        /**
         * Creates a new ComponentTimer instance using the specified properties.
         * @function create
         * @memberof world.ComponentTimer
         * @static
         * @param {world.IComponentTimer=} [properties] Properties to set
         * @returns {world.ComponentTimer} ComponentTimer instance
         */
        ComponentTimer.create = function create(properties) {
            return new ComponentTimer(properties);
        };

        /**
         * Encodes the specified ComponentTimer message. Does not implicitly {@link world.ComponentTimer.verify|verify} messages.
         * @function encode
         * @memberof world.ComponentTimer
         * @static
         * @param {world.IComponentTimer} message ComponentTimer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentTimer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timers != null && Object.hasOwnProperty.call(message, "timers"))
                for (var keys = Object.keys(message.timers), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.world.Timer.encode(message.timers[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified ComponentTimer message, length delimited. Does not implicitly {@link world.ComponentTimer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ComponentTimer
         * @static
         * @param {world.IComponentTimer} message ComponentTimer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentTimer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ComponentTimer message from the specified reader or buffer.
         * @function decode
         * @memberof world.ComponentTimer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ComponentTimer} ComponentTimer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentTimer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ComponentTimer(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.timers === $util.emptyObject)
                            message.timers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.world.Timer.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.timers[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ComponentTimer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ComponentTimer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ComponentTimer} ComponentTimer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentTimer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ComponentTimer message.
         * @function verify
         * @memberof world.ComponentTimer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComponentTimer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timers != null && message.hasOwnProperty("timers")) {
                if (!$util.isObject(message.timers))
                    return "timers: object expected";
                var key = Object.keys(message.timers);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "timers: integer key{k:uint32} expected";
                    {
                        var error = $root.world.Timer.verify(message.timers[key[i]]);
                        if (error)
                            return "timers." + error;
                    }
                }
            }
            return null;
        };

        /**
         * Creates a ComponentTimer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ComponentTimer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ComponentTimer} ComponentTimer
         */
        ComponentTimer.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ComponentTimer)
                return object;
            var message = new $root.world.ComponentTimer();
            if (object.timers) {
                if (typeof object.timers !== "object")
                    throw TypeError(".world.ComponentTimer.timers: object expected");
                message.timers = {};
                for (var keys = Object.keys(object.timers), i = 0; i < keys.length; ++i) {
                    if (typeof object.timers[keys[i]] !== "object")
                        throw TypeError(".world.ComponentTimer.timers: object expected");
                    message.timers[keys[i]] = $root.world.Timer.fromObject(object.timers[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ComponentTimer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ComponentTimer
         * @static
         * @param {world.ComponentTimer} message ComponentTimer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComponentTimer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.timers = {};
            var keys2;
            if (message.timers && (keys2 = Object.keys(message.timers)).length) {
                object.timers = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.timers[keys2[j]] = $root.world.Timer.toObject(message.timers[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this ComponentTimer to JSON.
         * @function toJSON
         * @memberof world.ComponentTimer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComponentTimer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ComponentTimer
         * @function getTypeUrl
         * @memberof world.ComponentTimer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComponentTimer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ComponentTimer";
        };

        return ComponentTimer;
    })();

    world.ComponentMove = (function() {

        /**
         * Properties of a ComponentMove.
         * @memberof world
         * @interface IComponentMove
         * @property {number|null} [startMs] ComponentMove startMs
         * @property {Array.<number>|null} [path] ComponentMove path
         * @property {number|null} [speed] ComponentMove speed
         * @property {number|null} [degree] ComponentMove degree
         */

        /**
         * Constructs a new ComponentMove.
         * @memberof world
         * @classdesc Represents a ComponentMove.
         * @implements IComponentMove
         * @constructor
         * @param {world.IComponentMove=} [properties] Properties to set
         */
        function ComponentMove(properties) {
            this.path = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ComponentMove startMs.
         * @member {number} startMs
         * @memberof world.ComponentMove
         * @instance
         */
        ComponentMove.prototype.startMs = 0;

        /**
         * ComponentMove path.
         * @member {Array.<number>} path
         * @memberof world.ComponentMove
         * @instance
         */
        ComponentMove.prototype.path = $util.emptyArray;

        /**
         * ComponentMove speed.
         * @member {number} speed
         * @memberof world.ComponentMove
         * @instance
         */
        ComponentMove.prototype.speed = 0;

        /**
         * ComponentMove degree.
         * @member {number} degree
         * @memberof world.ComponentMove
         * @instance
         */
        ComponentMove.prototype.degree = 0;

        /**
         * Creates a new ComponentMove instance using the specified properties.
         * @function create
         * @memberof world.ComponentMove
         * @static
         * @param {world.IComponentMove=} [properties] Properties to set
         * @returns {world.ComponentMove} ComponentMove instance
         */
        ComponentMove.create = function create(properties) {
            return new ComponentMove(properties);
        };

        /**
         * Encodes the specified ComponentMove message. Does not implicitly {@link world.ComponentMove.verify|verify} messages.
         * @function encode
         * @memberof world.ComponentMove
         * @static
         * @param {world.IComponentMove} message ComponentMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentMove.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startMs != null && Object.hasOwnProperty.call(message, "startMs"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.startMs);
            if (message.path != null && message.path.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.path.length; ++i)
                    writer.uint32(message.path[i]);
                writer.ldelim();
            }
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.speed);
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.degree);
            return writer;
        };

        /**
         * Encodes the specified ComponentMove message, length delimited. Does not implicitly {@link world.ComponentMove.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ComponentMove
         * @static
         * @param {world.IComponentMove} message ComponentMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentMove.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ComponentMove message from the specified reader or buffer.
         * @function decode
         * @memberof world.ComponentMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ComponentMove} ComponentMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentMove.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ComponentMove();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startMs = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.path && message.path.length))
                            message.path = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.path.push(reader.uint32());
                        } else
                            message.path.push(reader.uint32());
                        break;
                    }
                case 3: {
                        message.speed = reader.float();
                        break;
                    }
                case 4: {
                        message.degree = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ComponentMove message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ComponentMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ComponentMove} ComponentMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentMove.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ComponentMove message.
         * @function verify
         * @memberof world.ComponentMove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComponentMove.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                if (!$util.isInteger(message.startMs))
                    return "startMs: integer expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (var i = 0; i < message.path.length; ++i)
                    if (!$util.isInteger(message.path[i]))
                        return "path: integer[] expected";
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (typeof message.speed !== "number")
                    return "speed: number expected";
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (!$util.isInteger(message.degree))
                    return "degree: integer expected";
            return null;
        };

        /**
         * Creates a ComponentMove message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ComponentMove
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ComponentMove} ComponentMove
         */
        ComponentMove.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ComponentMove)
                return object;
            var message = new $root.world.ComponentMove();
            if (object.startMs != null)
                message.startMs = object.startMs >>> 0;
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".world.ComponentMove.path: array expected");
                message.path = [];
                for (var i = 0; i < object.path.length; ++i)
                    message.path[i] = object.path[i] >>> 0;
            }
            if (object.speed != null)
                message.speed = Number(object.speed);
            if (object.degree != null)
                message.degree = object.degree | 0;
            return message;
        };

        /**
         * Creates a plain object from a ComponentMove message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ComponentMove
         * @static
         * @param {world.ComponentMove} message ComponentMove
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComponentMove.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (options.defaults) {
                object.startMs = 0;
                object.speed = 0;
                object.degree = 0;
            }
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                object.startMs = message.startMs;
            if (message.path && message.path.length) {
                object.path = [];
                for (var j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = message.degree;
            return object;
        };

        /**
         * Converts this ComponentMove to JSON.
         * @function toJSON
         * @memberof world.ComponentMove
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComponentMove.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ComponentMove
         * @function getTypeUrl
         * @memberof world.ComponentMove
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComponentMove.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ComponentMove";
        };

        return ComponentMove;
    })();

    world.ComponentBuilding = (function() {

        /**
         * Properties of a ComponentBuilding.
         * @memberof world
         * @interface IComponentBuilding
         * @property {number|null} [bid] ComponentBuilding bid
         * @property {number|null} [hp] ComponentBuilding hp
         * @property {number|null} [maxHp] ComponentBuilding maxHp
         * @property {number|null} [autoHpMs] ComponentBuilding autoHpMs
         * @property {number|null} [autoHp] ComponentBuilding autoHp
         * @property {number|null} [autoHpInr] ComponentBuilding autoHpInr
         * @property {string|null} [name] ComponentBuilding name
         */

        /**
         * Constructs a new ComponentBuilding.
         * @memberof world
         * @classdesc Represents a ComponentBuilding.
         * @implements IComponentBuilding
         * @constructor
         * @param {world.IComponentBuilding=} [properties] Properties to set
         */
        function ComponentBuilding(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ComponentBuilding bid.
         * @member {number} bid
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.bid = 0;

        /**
         * ComponentBuilding hp.
         * @member {number} hp
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.hp = 0;

        /**
         * ComponentBuilding maxHp.
         * @member {number} maxHp
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.maxHp = 0;

        /**
         * ComponentBuilding autoHpMs.
         * @member {number} autoHpMs
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.autoHpMs = 0;

        /**
         * ComponentBuilding autoHp.
         * @member {number} autoHp
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.autoHp = 0;

        /**
         * ComponentBuilding autoHpInr.
         * @member {number} autoHpInr
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.autoHpInr = 0;

        /**
         * ComponentBuilding name.
         * @member {string} name
         * @memberof world.ComponentBuilding
         * @instance
         */
        ComponentBuilding.prototype.name = "";

        /**
         * Creates a new ComponentBuilding instance using the specified properties.
         * @function create
         * @memberof world.ComponentBuilding
         * @static
         * @param {world.IComponentBuilding=} [properties] Properties to set
         * @returns {world.ComponentBuilding} ComponentBuilding instance
         */
        ComponentBuilding.create = function create(properties) {
            return new ComponentBuilding(properties);
        };

        /**
         * Encodes the specified ComponentBuilding message. Does not implicitly {@link world.ComponentBuilding.verify|verify} messages.
         * @function encode
         * @memberof world.ComponentBuilding
         * @static
         * @param {world.IComponentBuilding} message ComponentBuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentBuilding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bid);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hp);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxHp);
            if (message.autoHpMs != null && Object.hasOwnProperty.call(message, "autoHpMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.autoHpMs);
            if (message.autoHp != null && Object.hasOwnProperty.call(message, "autoHp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.autoHp);
            if (message.autoHpInr != null && Object.hasOwnProperty.call(message, "autoHpInr"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.autoHpInr);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified ComponentBuilding message, length delimited. Does not implicitly {@link world.ComponentBuilding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ComponentBuilding
         * @static
         * @param {world.IComponentBuilding} message ComponentBuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentBuilding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ComponentBuilding message from the specified reader or buffer.
         * @function decode
         * @memberof world.ComponentBuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ComponentBuilding} ComponentBuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentBuilding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ComponentBuilding();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.autoHpMs = reader.uint32();
                        break;
                    }
                case 5: {
                        message.autoHp = reader.int32();
                        break;
                    }
                case 6: {
                        message.autoHpInr = reader.uint32();
                        break;
                    }
                case 9: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ComponentBuilding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ComponentBuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ComponentBuilding} ComponentBuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentBuilding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ComponentBuilding message.
         * @function verify
         * @memberof world.ComponentBuilding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComponentBuilding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bid != null && message.hasOwnProperty("bid"))
                if (!$util.isInteger(message.bid))
                    return "bid: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.autoHpMs != null && message.hasOwnProperty("autoHpMs"))
                if (!$util.isInteger(message.autoHpMs))
                    return "autoHpMs: integer expected";
            if (message.autoHp != null && message.hasOwnProperty("autoHp"))
                if (!$util.isInteger(message.autoHp))
                    return "autoHp: integer expected";
            if (message.autoHpInr != null && message.hasOwnProperty("autoHpInr"))
                if (!$util.isInteger(message.autoHpInr))
                    return "autoHpInr: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a ComponentBuilding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ComponentBuilding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ComponentBuilding} ComponentBuilding
         */
        ComponentBuilding.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ComponentBuilding)
                return object;
            var message = new $root.world.ComponentBuilding();
            if (object.bid != null)
                message.bid = object.bid >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.autoHpMs != null)
                message.autoHpMs = object.autoHpMs >>> 0;
            if (object.autoHp != null)
                message.autoHp = object.autoHp | 0;
            if (object.autoHpInr != null)
                message.autoHpInr = object.autoHpInr >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a ComponentBuilding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ComponentBuilding
         * @static
         * @param {world.ComponentBuilding} message ComponentBuilding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComponentBuilding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bid = 0;
                object.hp = 0;
                object.maxHp = 0;
                object.autoHpMs = 0;
                object.autoHp = 0;
                object.autoHpInr = 0;
                object.name = "";
            }
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = message.bid;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.autoHpMs != null && message.hasOwnProperty("autoHpMs"))
                object.autoHpMs = message.autoHpMs;
            if (message.autoHp != null && message.hasOwnProperty("autoHp"))
                object.autoHp = message.autoHp;
            if (message.autoHpInr != null && message.hasOwnProperty("autoHpInr"))
                object.autoHpInr = message.autoHpInr;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this ComponentBuilding to JSON.
         * @function toJSON
         * @memberof world.ComponentBuilding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComponentBuilding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ComponentBuilding
         * @function getTypeUrl
         * @memberof world.ComponentBuilding
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComponentBuilding.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ComponentBuilding";
        };

        return ComponentBuilding;
    })();

    world.ComponentBattle = (function() {

        /**
         * Properties of a ComponentBattle.
         * @memberof world
         * @interface IComponentBattle
         * @property {number|null} [battleUid] ComponentBattle battleUid
         * @property {Array.<number>|null} [fighterEids] ComponentBattle fighterEids
         * @property {number|null} [startTs] ComponentBattle startTs
         */

        /**
         * Constructs a new ComponentBattle.
         * @memberof world
         * @classdesc Represents a ComponentBattle.
         * @implements IComponentBattle
         * @constructor
         * @param {world.IComponentBattle=} [properties] Properties to set
         */
        function ComponentBattle(properties) {
            this.fighterEids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ComponentBattle battleUid.
         * @member {number} battleUid
         * @memberof world.ComponentBattle
         * @instance
         */
        ComponentBattle.prototype.battleUid = 0;

        /**
         * ComponentBattle fighterEids.
         * @member {Array.<number>} fighterEids
         * @memberof world.ComponentBattle
         * @instance
         */
        ComponentBattle.prototype.fighterEids = $util.emptyArray;

        /**
         * ComponentBattle startTs.
         * @member {number} startTs
         * @memberof world.ComponentBattle
         * @instance
         */
        ComponentBattle.prototype.startTs = 0;

        /**
         * Creates a new ComponentBattle instance using the specified properties.
         * @function create
         * @memberof world.ComponentBattle
         * @static
         * @param {world.IComponentBattle=} [properties] Properties to set
         * @returns {world.ComponentBattle} ComponentBattle instance
         */
        ComponentBattle.create = function create(properties) {
            return new ComponentBattle(properties);
        };

        /**
         * Encodes the specified ComponentBattle message. Does not implicitly {@link world.ComponentBattle.verify|verify} messages.
         * @function encode
         * @memberof world.ComponentBattle
         * @static
         * @param {world.IComponentBattle} message ComponentBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.fighterEids != null && message.fighterEids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.fighterEids.length; ++i)
                    writer.uint32(message.fighterEids[i]);
                writer.ldelim();
            }
            if (message.startTs != null && Object.hasOwnProperty.call(message, "startTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.startTs);
            return writer;
        };

        /**
         * Encodes the specified ComponentBattle message, length delimited. Does not implicitly {@link world.ComponentBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ComponentBattle
         * @static
         * @param {world.IComponentBattle} message ComponentBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ComponentBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ComponentBattle message from the specified reader or buffer.
         * @function decode
         * @memberof world.ComponentBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ComponentBattle} ComponentBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ComponentBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.fighterEids && message.fighterEids.length))
                            message.fighterEids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.fighterEids.push(reader.uint32());
                        } else
                            message.fighterEids.push(reader.uint32());
                        break;
                    }
                case 3: {
                        message.startTs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ComponentBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ComponentBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ComponentBattle} ComponentBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ComponentBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ComponentBattle message.
         * @function verify
         * @memberof world.ComponentBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ComponentBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.fighterEids != null && message.hasOwnProperty("fighterEids")) {
                if (!Array.isArray(message.fighterEids))
                    return "fighterEids: array expected";
                for (var i = 0; i < message.fighterEids.length; ++i)
                    if (!$util.isInteger(message.fighterEids[i]))
                        return "fighterEids: integer[] expected";
            }
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                if (!$util.isInteger(message.startTs))
                    return "startTs: integer expected";
            return null;
        };

        /**
         * Creates a ComponentBattle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ComponentBattle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ComponentBattle} ComponentBattle
         */
        ComponentBattle.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ComponentBattle)
                return object;
            var message = new $root.world.ComponentBattle();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.fighterEids) {
                if (!Array.isArray(object.fighterEids))
                    throw TypeError(".world.ComponentBattle.fighterEids: array expected");
                message.fighterEids = [];
                for (var i = 0; i < object.fighterEids.length; ++i)
                    message.fighterEids[i] = object.fighterEids[i] >>> 0;
            }
            if (object.startTs != null)
                message.startTs = object.startTs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ComponentBattle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ComponentBattle
         * @static
         * @param {world.ComponentBattle} message ComponentBattle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ComponentBattle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fighterEids = [];
            if (options.defaults) {
                object.battleUid = 0;
                object.startTs = 0;
            }
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.fighterEids && message.fighterEids.length) {
                object.fighterEids = [];
                for (var j = 0; j < message.fighterEids.length; ++j)
                    object.fighterEids[j] = message.fighterEids[j];
            }
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                object.startTs = message.startTs;
            return object;
        };

        /**
         * Converts this ComponentBattle to JSON.
         * @function toJSON
         * @memberof world.ComponentBattle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ComponentBattle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ComponentBattle
         * @function getTypeUrl
         * @memberof world.ComponentBattle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ComponentBattle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ComponentBattle";
        };

        return ComponentBattle;
    })();

    world.Entity = (function() {

        /**
         * Properties of an Entity.
         * @memberof world
         * @interface IEntity
         * @property {number|null} [eid] Entity eid
         * @property {number|null} [etype] Entity etype
         * @property {world.IPosition|null} [pos] Entity pos
         * @property {number|null} [state] Entity state
         * @property {world.IComponentTimer|null} [timer] Entity timer
         * @property {world.IComponentMove|null} [move] Entity move
         * @property {world.IComponentBuilding|null} [building] Entity building
         * @property {world.IComponentOwner|null} [owner] Entity owner
         * @property {world.IComponentTroop|null} [troop] Entity troop
         * @property {world.IComponentBattle|null} [battle] Entity battle
         */

        /**
         * Constructs a new Entity.
         * @memberof world
         * @classdesc Represents an Entity.
         * @implements IEntity
         * @constructor
         * @param {world.IEntity=} [properties] Properties to set
         */
        function Entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Entity eid.
         * @member {number} eid
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.eid = 0;

        /**
         * Entity etype.
         * @member {number} etype
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.etype = 0;

        /**
         * Entity pos.
         * @member {world.IPosition|null|undefined} pos
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.pos = null;

        /**
         * Entity state.
         * @member {number} state
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.state = 0;

        /**
         * Entity timer.
         * @member {world.IComponentTimer|null|undefined} timer
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.timer = null;

        /**
         * Entity move.
         * @member {world.IComponentMove|null|undefined} move
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.move = null;

        /**
         * Entity building.
         * @member {world.IComponentBuilding|null|undefined} building
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.building = null;

        /**
         * Entity owner.
         * @member {world.IComponentOwner|null|undefined} owner
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.owner = null;

        /**
         * Entity troop.
         * @member {world.IComponentTroop|null|undefined} troop
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.troop = null;

        /**
         * Entity battle.
         * @member {world.IComponentBattle|null|undefined} battle
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.battle = null;

        /**
         * Creates a new Entity instance using the specified properties.
         * @function create
         * @memberof world.Entity
         * @static
         * @param {world.IEntity=} [properties] Properties to set
         * @returns {world.Entity} Entity instance
         */
        Entity.create = function create(properties) {
            return new Entity(properties);
        };

        /**
         * Encodes the specified Entity message. Does not implicitly {@link world.Entity.verify|verify} messages.
         * @function encode
         * @memberof world.Entity
         * @static
         * @param {world.IEntity} message Entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.etype != null && Object.hasOwnProperty.call(message, "etype"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.etype);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.world.Position.encode(message.pos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.state);
            if (message.timer != null && Object.hasOwnProperty.call(message, "timer"))
                $root.world.ComponentTimer.encode(message.timer, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.move != null && Object.hasOwnProperty.call(message, "move"))
                $root.world.ComponentMove.encode(message.move, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.building != null && Object.hasOwnProperty.call(message, "building"))
                $root.world.ComponentBuilding.encode(message.building, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                $root.world.ComponentOwner.encode(message.owner, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.troop != null && Object.hasOwnProperty.call(message, "troop"))
                $root.world.ComponentTroop.encode(message.troop, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.battle != null && Object.hasOwnProperty.call(message, "battle"))
                $root.world.ComponentBattle.encode(message.battle, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Entity message, length delimited. Does not implicitly {@link world.Entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Entity
         * @static
         * @param {world.IEntity} message Entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Entity message from the specified reader or buffer.
         * @function decode
         * @memberof world.Entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Entity} Entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.etype = reader.uint32();
                        break;
                    }
                case 3: {
                        message.pos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.state = reader.uint32();
                        break;
                    }
                case 12: {
                        message.timer = $root.world.ComponentTimer.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.move = $root.world.ComponentMove.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.building = $root.world.ComponentBuilding.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.owner = $root.world.ComponentOwner.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.troop = $root.world.ComponentTroop.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.battle = $root.world.ComponentBattle.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Entity} Entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Entity message.
         * @function verify
         * @memberof world.Entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.etype != null && message.hasOwnProperty("etype"))
                if (!$util.isInteger(message.etype))
                    return "etype: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.world.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.timer != null && message.hasOwnProperty("timer")) {
                var error = $root.world.ComponentTimer.verify(message.timer);
                if (error)
                    return "timer." + error;
            }
            if (message.move != null && message.hasOwnProperty("move")) {
                var error = $root.world.ComponentMove.verify(message.move);
                if (error)
                    return "move." + error;
            }
            if (message.building != null && message.hasOwnProperty("building")) {
                var error = $root.world.ComponentBuilding.verify(message.building);
                if (error)
                    return "building." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.world.ComponentOwner.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.troop != null && message.hasOwnProperty("troop")) {
                var error = $root.world.ComponentTroop.verify(message.troop);
                if (error)
                    return "troop." + error;
            }
            if (message.battle != null && message.hasOwnProperty("battle")) {
                var error = $root.world.ComponentBattle.verify(message.battle);
                if (error)
                    return "battle." + error;
            }
            return null;
        };

        /**
         * Creates an Entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Entity} Entity
         */
        Entity.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Entity)
                return object;
            var message = new $root.world.Entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.etype != null)
                message.etype = object.etype >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".world.Entity.pos: object expected");
                message.pos = $root.world.Position.fromObject(object.pos);
            }
            if (object.state != null)
                message.state = object.state >>> 0;
            if (object.timer != null) {
                if (typeof object.timer !== "object")
                    throw TypeError(".world.Entity.timer: object expected");
                message.timer = $root.world.ComponentTimer.fromObject(object.timer);
            }
            if (object.move != null) {
                if (typeof object.move !== "object")
                    throw TypeError(".world.Entity.move: object expected");
                message.move = $root.world.ComponentMove.fromObject(object.move);
            }
            if (object.building != null) {
                if (typeof object.building !== "object")
                    throw TypeError(".world.Entity.building: object expected");
                message.building = $root.world.ComponentBuilding.fromObject(object.building);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".world.Entity.owner: object expected");
                message.owner = $root.world.ComponentOwner.fromObject(object.owner);
            }
            if (object.troop != null) {
                if (typeof object.troop !== "object")
                    throw TypeError(".world.Entity.troop: object expected");
                message.troop = $root.world.ComponentTroop.fromObject(object.troop);
            }
            if (object.battle != null) {
                if (typeof object.battle !== "object")
                    throw TypeError(".world.Entity.battle: object expected");
                message.battle = $root.world.ComponentBattle.fromObject(object.battle);
            }
            return message;
        };

        /**
         * Creates a plain object from an Entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Entity
         * @static
         * @param {world.Entity} message Entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.etype = 0;
                object.pos = null;
                object.state = 0;
                object.timer = null;
                object.move = null;
                object.building = null;
                object.owner = null;
                object.troop = null;
                object.battle = null;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.etype != null && message.hasOwnProperty("etype"))
                object.etype = message.etype;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.world.Position.toObject(message.pos, options);
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.timer != null && message.hasOwnProperty("timer"))
                object.timer = $root.world.ComponentTimer.toObject(message.timer, options);
            if (message.move != null && message.hasOwnProperty("move"))
                object.move = $root.world.ComponentMove.toObject(message.move, options);
            if (message.building != null && message.hasOwnProperty("building"))
                object.building = $root.world.ComponentBuilding.toObject(message.building, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.world.ComponentOwner.toObject(message.owner, options);
            if (message.troop != null && message.hasOwnProperty("troop"))
                object.troop = $root.world.ComponentTroop.toObject(message.troop, options);
            if (message.battle != null && message.hasOwnProperty("battle"))
                object.battle = $root.world.ComponentBattle.toObject(message.battle, options);
            return object;
        };

        /**
         * Converts this Entity to JSON.
         * @function toJSON
         * @memberof world.Entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Entity
         * @function getTypeUrl
         * @memberof world.Entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Entity";
        };

        return Entity;
    })();

    world.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof world
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof world
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {world.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof world.c2s_load
         * @static
         * @param {world.Ic2s_load=} [properties] Properties to set
         * @returns {world.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link world.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_load
         * @static
         * @param {world.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link world.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_load
         * @static
         * @param {world.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof world.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_load)
                return object;
            return new $root.world.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_load
         * @static
         * @param {world.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof world.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof world.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_load";
        };

        return c2s_load;
    })();

    world.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof world
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {number|null} [myCastleEid] s2c_load myCastleEid
         * @property {world.IPosition|null} [myCastlePos] s2c_load myCastlePos
         */

        /**
         * Constructs a new s2c_load.
         * @memberof world
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {world.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load myCastleEid.
         * @member {number} myCastleEid
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.myCastleEid = 0;

        /**
         * s2c_load myCastlePos.
         * @member {world.IPosition|null|undefined} myCastlePos
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.myCastlePos = null;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof world.s2c_load
         * @static
         * @param {world.Is2c_load=} [properties] Properties to set
         * @returns {world.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link world.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_load
         * @static
         * @param {world.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.myCastleEid != null && Object.hasOwnProperty.call(message, "myCastleEid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.myCastleEid);
            if (message.myCastlePos != null && Object.hasOwnProperty.call(message, "myCastlePos"))
                $root.world.Position.encode(message.myCastlePos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link world.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_load
         * @static
         * @param {world.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.myCastleEid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.myCastlePos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof world.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.myCastleEid != null && message.hasOwnProperty("myCastleEid"))
                if (!$util.isInteger(message.myCastleEid))
                    return "myCastleEid: integer expected";
            if (message.myCastlePos != null && message.hasOwnProperty("myCastlePos")) {
                var error = $root.world.Position.verify(message.myCastlePos);
                if (error)
                    return "myCastlePos." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_load)
                return object;
            var message = new $root.world.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.myCastleEid != null)
                message.myCastleEid = object.myCastleEid >>> 0;
            if (object.myCastlePos != null) {
                if (typeof object.myCastlePos !== "object")
                    throw TypeError(".world.s2c_load.myCastlePos: object expected");
                message.myCastlePos = $root.world.Position.fromObject(object.myCastlePos);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_load
         * @static
         * @param {world.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.myCastleEid = 0;
                object.myCastlePos = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.myCastleEid != null && message.hasOwnProperty("myCastleEid"))
                object.myCastleEid = message.myCastleEid;
            if (message.myCastlePos != null && message.hasOwnProperty("myCastlePos"))
                object.myCastlePos = $root.world.Position.toObject(message.myCastlePos, options);
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof world.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof world.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_load";
        };

        return s2c_load;
    })();

    world.c2s_change_viewport = (function() {

        /**
         * Properties of a c2s_change_viewport.
         * @memberof world
         * @interface Ic2s_change_viewport
         * @property {world.IPosition|null} [pos] c2s_change_viewport pos
         */

        /**
         * Constructs a new c2s_change_viewport.
         * @memberof world
         * @classdesc Represents a c2s_change_viewport.
         * @implements Ic2s_change_viewport
         * @constructor
         * @param {world.Ic2s_change_viewport=} [properties] Properties to set
         */
        function c2s_change_viewport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_change_viewport pos.
         * @member {world.IPosition|null|undefined} pos
         * @memberof world.c2s_change_viewport
         * @instance
         */
        c2s_change_viewport.prototype.pos = null;

        /**
         * Creates a new c2s_change_viewport instance using the specified properties.
         * @function create
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.Ic2s_change_viewport=} [properties] Properties to set
         * @returns {world.c2s_change_viewport} c2s_change_viewport instance
         */
        c2s_change_viewport.create = function create(properties) {
            return new c2s_change_viewport(properties);
        };

        /**
         * Encodes the specified c2s_change_viewport message. Does not implicitly {@link world.c2s_change_viewport.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.Ic2s_change_viewport} message c2s_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_change_viewport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.world.Position.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified c2s_change_viewport message, length delimited. Does not implicitly {@link world.c2s_change_viewport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.Ic2s_change_viewport} message c2s_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_change_viewport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_change_viewport message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_change_viewport} c2s_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_change_viewport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_change_viewport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.pos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_change_viewport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_change_viewport} c2s_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_change_viewport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_change_viewport message.
         * @function verify
         * @memberof world.c2s_change_viewport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_change_viewport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.world.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a c2s_change_viewport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_change_viewport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_change_viewport} c2s_change_viewport
         */
        c2s_change_viewport.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_change_viewport)
                return object;
            var message = new $root.world.c2s_change_viewport();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".world.c2s_change_viewport.pos: object expected");
                message.pos = $root.world.Position.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_change_viewport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.c2s_change_viewport} message c2s_change_viewport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_change_viewport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pos = null;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.world.Position.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this c2s_change_viewport to JSON.
         * @function toJSON
         * @memberof world.c2s_change_viewport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_change_viewport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_change_viewport
         * @function getTypeUrl
         * @memberof world.c2s_change_viewport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_change_viewport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_change_viewport";
        };

        return c2s_change_viewport;
    })();

    world.s2c_change_viewport = (function() {

        /**
         * Properties of a s2c_change_viewport.
         * @memberof world
         * @interface Is2c_change_viewport
         * @property {number|null} [err] s2c_change_viewport err
         */

        /**
         * Constructs a new s2c_change_viewport.
         * @memberof world
         * @classdesc Represents a s2c_change_viewport.
         * @implements Is2c_change_viewport
         * @constructor
         * @param {world.Is2c_change_viewport=} [properties] Properties to set
         */
        function s2c_change_viewport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_change_viewport err.
         * @member {number} err
         * @memberof world.s2c_change_viewport
         * @instance
         */
        s2c_change_viewport.prototype.err = 0;

        /**
         * Creates a new s2c_change_viewport instance using the specified properties.
         * @function create
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.Is2c_change_viewport=} [properties] Properties to set
         * @returns {world.s2c_change_viewport} s2c_change_viewport instance
         */
        s2c_change_viewport.create = function create(properties) {
            return new s2c_change_viewport(properties);
        };

        /**
         * Encodes the specified s2c_change_viewport message. Does not implicitly {@link world.s2c_change_viewport.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.Is2c_change_viewport} message s2c_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_change_viewport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_change_viewport message, length delimited. Does not implicitly {@link world.s2c_change_viewport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.Is2c_change_viewport} message s2c_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_change_viewport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_change_viewport message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_change_viewport} s2c_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_change_viewport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_change_viewport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_change_viewport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_change_viewport} s2c_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_change_viewport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_change_viewport message.
         * @function verify
         * @memberof world.s2c_change_viewport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_change_viewport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_change_viewport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_change_viewport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_change_viewport} s2c_change_viewport
         */
        s2c_change_viewport.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_change_viewport)
                return object;
            var message = new $root.world.s2c_change_viewport();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_change_viewport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.s2c_change_viewport} message s2c_change_viewport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_change_viewport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_change_viewport to JSON.
         * @function toJSON
         * @memberof world.s2c_change_viewport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_change_viewport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_change_viewport
         * @function getTypeUrl
         * @memberof world.s2c_change_viewport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_change_viewport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_change_viewport";
        };

        return s2c_change_viewport;
    })();

    world.c2s_giveup = (function() {

        /**
         * Properties of a c2s_giveup.
         * @memberof world
         * @interface Ic2s_giveup
         * @property {number|null} [eid] c2s_giveup eid
         */

        /**
         * Constructs a new c2s_giveup.
         * @memberof world
         * @classdesc Represents a c2s_giveup.
         * @implements Ic2s_giveup
         * @constructor
         * @param {world.Ic2s_giveup=} [properties] Properties to set
         */
        function c2s_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_giveup eid.
         * @member {number} eid
         * @memberof world.c2s_giveup
         * @instance
         */
        c2s_giveup.prototype.eid = 0;

        /**
         * Creates a new c2s_giveup instance using the specified properties.
         * @function create
         * @memberof world.c2s_giveup
         * @static
         * @param {world.Ic2s_giveup=} [properties] Properties to set
         * @returns {world.c2s_giveup} c2s_giveup instance
         */
        c2s_giveup.create = function create(properties) {
            return new c2s_giveup(properties);
        };

        /**
         * Encodes the specified c2s_giveup message. Does not implicitly {@link world.c2s_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_giveup
         * @static
         * @param {world.Ic2s_giveup} message c2s_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified c2s_giveup message, length delimited. Does not implicitly {@link world.c2s_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_giveup
         * @static
         * @param {world.Ic2s_giveup} message c2s_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_giveup} c2s_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_giveup} c2s_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_giveup message.
         * @function verify
         * @memberof world.c2s_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_giveup} c2s_giveup
         */
        c2s_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_giveup)
                return object;
            var message = new $root.world.c2s_giveup();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_giveup
         * @static
         * @param {world.c2s_giveup} message c2s_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this c2s_giveup to JSON.
         * @function toJSON
         * @memberof world.c2s_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_giveup
         * @function getTypeUrl
         * @memberof world.c2s_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_giveup";
        };

        return c2s_giveup;
    })();

    world.s2c_giveup = (function() {

        /**
         * Properties of a s2c_giveup.
         * @memberof world
         * @interface Is2c_giveup
         * @property {number|null} [err] s2c_giveup err
         */

        /**
         * Constructs a new s2c_giveup.
         * @memberof world
         * @classdesc Represents a s2c_giveup.
         * @implements Is2c_giveup
         * @constructor
         * @param {world.Is2c_giveup=} [properties] Properties to set
         */
        function s2c_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_giveup err.
         * @member {number} err
         * @memberof world.s2c_giveup
         * @instance
         */
        s2c_giveup.prototype.err = 0;

        /**
         * Creates a new s2c_giveup instance using the specified properties.
         * @function create
         * @memberof world.s2c_giveup
         * @static
         * @param {world.Is2c_giveup=} [properties] Properties to set
         * @returns {world.s2c_giveup} s2c_giveup instance
         */
        s2c_giveup.create = function create(properties) {
            return new s2c_giveup(properties);
        };

        /**
         * Encodes the specified s2c_giveup message. Does not implicitly {@link world.s2c_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_giveup
         * @static
         * @param {world.Is2c_giveup} message s2c_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_giveup message, length delimited. Does not implicitly {@link world.s2c_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_giveup
         * @static
         * @param {world.Is2c_giveup} message s2c_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_giveup} s2c_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_giveup} s2c_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_giveup message.
         * @function verify
         * @memberof world.s2c_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_giveup} s2c_giveup
         */
        s2c_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_giveup)
                return object;
            var message = new $root.world.s2c_giveup();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_giveup
         * @static
         * @param {world.s2c_giveup} message s2c_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_giveup to JSON.
         * @function toJSON
         * @memberof world.s2c_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_giveup
         * @function getTypeUrl
         * @memberof world.s2c_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_giveup";
        };

        return s2c_giveup;
    })();

    world.c2s_cancel_giveup = (function() {

        /**
         * Properties of a c2s_cancel_giveup.
         * @memberof world
         * @interface Ic2s_cancel_giveup
         * @property {number|Long|null} [eid] c2s_cancel_giveup eid
         */

        /**
         * Constructs a new c2s_cancel_giveup.
         * @memberof world
         * @classdesc Represents a c2s_cancel_giveup.
         * @implements Ic2s_cancel_giveup
         * @constructor
         * @param {world.Ic2s_cancel_giveup=} [properties] Properties to set
         */
        function c2s_cancel_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_cancel_giveup eid.
         * @member {number|Long} eid
         * @memberof world.c2s_cancel_giveup
         * @instance
         */
        c2s_cancel_giveup.prototype.eid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new c2s_cancel_giveup instance using the specified properties.
         * @function create
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.Ic2s_cancel_giveup=} [properties] Properties to set
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup instance
         */
        c2s_cancel_giveup.create = function create(properties) {
            return new c2s_cancel_giveup(properties);
        };

        /**
         * Encodes the specified c2s_cancel_giveup message. Does not implicitly {@link world.c2s_cancel_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.Ic2s_cancel_giveup} message c2s_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_cancel_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.eid);
            return writer;
        };

        /**
         * Encodes the specified c2s_cancel_giveup message, length delimited. Does not implicitly {@link world.c2s_cancel_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.Ic2s_cancel_giveup} message c2s_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_cancel_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_cancel_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_cancel_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_cancel_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_cancel_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_cancel_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_cancel_giveup message.
         * @function verify
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_cancel_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid) && !(message.eid && $util.isInteger(message.eid.low) && $util.isInteger(message.eid.high)))
                    return "eid: integer|Long expected";
            return null;
        };

        /**
         * Creates a c2s_cancel_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup
         */
        c2s_cancel_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_cancel_giveup)
                return object;
            var message = new $root.world.c2s_cancel_giveup();
            if (object.eid != null)
                if ($util.Long)
                    (message.eid = $util.Long.fromValue(object.eid)).unsigned = false;
                else if (typeof object.eid === "string")
                    message.eid = parseInt(object.eid, 10);
                else if (typeof object.eid === "number")
                    message.eid = object.eid;
                else if (typeof object.eid === "object")
                    message.eid = new $util.LongBits(object.eid.low >>> 0, object.eid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a c2s_cancel_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.c2s_cancel_giveup} message c2s_cancel_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_cancel_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.eid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.eid = options.longs === String ? "0" : 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (typeof message.eid === "number")
                    object.eid = options.longs === String ? String(message.eid) : message.eid;
                else
                    object.eid = options.longs === String ? $util.Long.prototype.toString.call(message.eid) : options.longs === Number ? new $util.LongBits(message.eid.low >>> 0, message.eid.high >>> 0).toNumber() : message.eid;
            return object;
        };

        /**
         * Converts this c2s_cancel_giveup to JSON.
         * @function toJSON
         * @memberof world.c2s_cancel_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_cancel_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_cancel_giveup
         * @function getTypeUrl
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_cancel_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_cancel_giveup";
        };

        return c2s_cancel_giveup;
    })();

    world.s2c_cancel_giveup = (function() {

        /**
         * Properties of a s2c_cancel_giveup.
         * @memberof world
         * @interface Is2c_cancel_giveup
         * @property {number|null} [err] s2c_cancel_giveup err
         */

        /**
         * Constructs a new s2c_cancel_giveup.
         * @memberof world
         * @classdesc Represents a s2c_cancel_giveup.
         * @implements Is2c_cancel_giveup
         * @constructor
         * @param {world.Is2c_cancel_giveup=} [properties] Properties to set
         */
        function s2c_cancel_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_cancel_giveup err.
         * @member {number} err
         * @memberof world.s2c_cancel_giveup
         * @instance
         */
        s2c_cancel_giveup.prototype.err = 0;

        /**
         * Creates a new s2c_cancel_giveup instance using the specified properties.
         * @function create
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.Is2c_cancel_giveup=} [properties] Properties to set
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup instance
         */
        s2c_cancel_giveup.create = function create(properties) {
            return new s2c_cancel_giveup(properties);
        };

        /**
         * Encodes the specified s2c_cancel_giveup message. Does not implicitly {@link world.s2c_cancel_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.Is2c_cancel_giveup} message s2c_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_cancel_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_cancel_giveup message, length delimited. Does not implicitly {@link world.s2c_cancel_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.Is2c_cancel_giveup} message s2c_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_cancel_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_cancel_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_cancel_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_cancel_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_cancel_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_cancel_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_cancel_giveup message.
         * @function verify
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_cancel_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_cancel_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup
         */
        s2c_cancel_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_cancel_giveup)
                return object;
            var message = new $root.world.s2c_cancel_giveup();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_cancel_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.s2c_cancel_giveup} message s2c_cancel_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_cancel_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_cancel_giveup to JSON.
         * @function toJSON
         * @memberof world.s2c_cancel_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_cancel_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_cancel_giveup
         * @function getTypeUrl
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_cancel_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_cancel_giveup";
        };

        return s2c_cancel_giveup;
    })();

    world.c2s_load_detect_info = (function() {

        /**
         * Properties of a c2s_load_detect_info.
         * @memberof world
         * @interface Ic2s_load_detect_info
         * @property {world.IPosition|null} [pos] c2s_load_detect_info pos
         */

        /**
         * Constructs a new c2s_load_detect_info.
         * @memberof world
         * @classdesc Represents a c2s_load_detect_info.
         * @implements Ic2s_load_detect_info
         * @constructor
         * @param {world.Ic2s_load_detect_info=} [properties] Properties to set
         */
        function c2s_load_detect_info(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load_detect_info pos.
         * @member {world.IPosition|null|undefined} pos
         * @memberof world.c2s_load_detect_info
         * @instance
         */
        c2s_load_detect_info.prototype.pos = null;

        /**
         * Creates a new c2s_load_detect_info instance using the specified properties.
         * @function create
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.Ic2s_load_detect_info=} [properties] Properties to set
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info instance
         */
        c2s_load_detect_info.create = function create(properties) {
            return new c2s_load_detect_info(properties);
        };

        /**
         * Encodes the specified c2s_load_detect_info message. Does not implicitly {@link world.c2s_load_detect_info.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.Ic2s_load_detect_info} message c2s_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_detect_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.world.Position.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified c2s_load_detect_info message, length delimited. Does not implicitly {@link world.c2s_load_detect_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.Ic2s_load_detect_info} message c2s_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_detect_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load_detect_info message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_detect_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_load_detect_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load_detect_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_detect_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load_detect_info message.
         * @function verify
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load_detect_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.world.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a c2s_load_detect_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info
         */
        c2s_load_detect_info.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_load_detect_info)
                return object;
            var message = new $root.world.c2s_load_detect_info();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".world.c2s_load_detect_info.pos: object expected");
                message.pos = $root.world.Position.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_load_detect_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.c2s_load_detect_info} message c2s_load_detect_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load_detect_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pos = null;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.world.Position.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this c2s_load_detect_info to JSON.
         * @function toJSON
         * @memberof world.c2s_load_detect_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load_detect_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load_detect_info
         * @function getTypeUrl
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load_detect_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_load_detect_info";
        };

        return c2s_load_detect_info;
    })();

    world.s2c_load_detect_info = (function() {

        /**
         * Properties of a s2c_load_detect_info.
         * @memberof world
         * @interface Is2c_load_detect_info
         * @property {number|null} [err] s2c_load_detect_info err
         * @property {number|null} [dungeonId] s2c_load_detect_info dungeonId
         * @property {number|null} [aliveCount] s2c_load_detect_info aliveCount
         */

        /**
         * Constructs a new s2c_load_detect_info.
         * @memberof world
         * @classdesc Represents a s2c_load_detect_info.
         * @implements Is2c_load_detect_info
         * @constructor
         * @param {world.Is2c_load_detect_info=} [properties] Properties to set
         */
        function s2c_load_detect_info(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load_detect_info err.
         * @member {number} err
         * @memberof world.s2c_load_detect_info
         * @instance
         */
        s2c_load_detect_info.prototype.err = 0;

        /**
         * s2c_load_detect_info dungeonId.
         * @member {number} dungeonId
         * @memberof world.s2c_load_detect_info
         * @instance
         */
        s2c_load_detect_info.prototype.dungeonId = 0;

        /**
         * s2c_load_detect_info aliveCount.
         * @member {number} aliveCount
         * @memberof world.s2c_load_detect_info
         * @instance
         */
        s2c_load_detect_info.prototype.aliveCount = 0;

        /**
         * Creates a new s2c_load_detect_info instance using the specified properties.
         * @function create
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.Is2c_load_detect_info=} [properties] Properties to set
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info instance
         */
        s2c_load_detect_info.create = function create(properties) {
            return new s2c_load_detect_info(properties);
        };

        /**
         * Encodes the specified s2c_load_detect_info message. Does not implicitly {@link world.s2c_load_detect_info.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.Is2c_load_detect_info} message s2c_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_detect_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.dungeonId != null && Object.hasOwnProperty.call(message, "dungeonId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dungeonId);
            if (message.aliveCount != null && Object.hasOwnProperty.call(message, "aliveCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.aliveCount);
            return writer;
        };

        /**
         * Encodes the specified s2c_load_detect_info message, length delimited. Does not implicitly {@link world.s2c_load_detect_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.Is2c_load_detect_info} message s2c_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_detect_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load_detect_info message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_detect_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_load_detect_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.dungeonId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.aliveCount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load_detect_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_detect_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load_detect_info message.
         * @function verify
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load_detect_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                if (!$util.isInteger(message.dungeonId))
                    return "dungeonId: integer expected";
            if (message.aliveCount != null && message.hasOwnProperty("aliveCount"))
                if (!$util.isInteger(message.aliveCount))
                    return "aliveCount: integer expected";
            return null;
        };

        /**
         * Creates a s2c_load_detect_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info
         */
        s2c_load_detect_info.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_load_detect_info)
                return object;
            var message = new $root.world.s2c_load_detect_info();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.dungeonId != null)
                message.dungeonId = object.dungeonId >>> 0;
            if (object.aliveCount != null)
                message.aliveCount = object.aliveCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_load_detect_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.s2c_load_detect_info} message s2c_load_detect_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load_detect_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.dungeonId = 0;
                object.aliveCount = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                object.dungeonId = message.dungeonId;
            if (message.aliveCount != null && message.hasOwnProperty("aliveCount"))
                object.aliveCount = message.aliveCount;
            return object;
        };

        /**
         * Converts this s2c_load_detect_info to JSON.
         * @function toJSON
         * @memberof world.s2c_load_detect_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load_detect_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load_detect_info
         * @function getTypeUrl
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load_detect_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_load_detect_info";
        };

        return s2c_load_detect_info;
    })();

    world.c2s_troop_move_to = (function() {

        /**
         * Properties of a c2s_troop_move_to.
         * @memberof world
         * @interface Ic2s_troop_move_to
         * @property {number|null} [troopEid] c2s_troop_move_to troopEid
         * @property {world.IPosition|null} [dstPos] c2s_troop_move_to dstPos
         */

        /**
         * Constructs a new c2s_troop_move_to.
         * @memberof world
         * @classdesc Represents a c2s_troop_move_to.
         * @implements Ic2s_troop_move_to
         * @constructor
         * @param {world.Ic2s_troop_move_to=} [properties] Properties to set
         */
        function c2s_troop_move_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_move_to troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_move_to
         * @instance
         */
        c2s_troop_move_to.prototype.troopEid = 0;

        /**
         * c2s_troop_move_to dstPos.
         * @member {world.IPosition|null|undefined} dstPos
         * @memberof world.c2s_troop_move_to
         * @instance
         */
        c2s_troop_move_to.prototype.dstPos = null;

        /**
         * Creates a new c2s_troop_move_to instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.Ic2s_troop_move_to=} [properties] Properties to set
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to instance
         */
        c2s_troop_move_to.create = function create(properties) {
            return new c2s_troop_move_to(properties);
        };

        /**
         * Encodes the specified c2s_troop_move_to message. Does not implicitly {@link world.c2s_troop_move_to.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.Ic2s_troop_move_to} message c2s_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            if (message.dstPos != null && Object.hasOwnProperty.call(message, "dstPos"))
                $root.world.Position.encode(message.dstPos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_move_to message, length delimited. Does not implicitly {@link world.c2s_troop_move_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.Ic2s_troop_move_to} message c2s_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_move_to message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_move_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.dstPos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_move_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_move_to message.
         * @function verify
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_move_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            if (message.dstPos != null && message.hasOwnProperty("dstPos")) {
                var error = $root.world.Position.verify(message.dstPos);
                if (error)
                    return "dstPos." + error;
            }
            return null;
        };

        /**
         * Creates a c2s_troop_move_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to
         */
        c2s_troop_move_to.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_move_to)
                return object;
            var message = new $root.world.c2s_troop_move_to();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            if (object.dstPos != null) {
                if (typeof object.dstPos !== "object")
                    throw TypeError(".world.c2s_troop_move_to.dstPos: object expected");
                message.dstPos = $root.world.Position.fromObject(object.dstPos);
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_move_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.c2s_troop_move_to} message c2s_troop_move_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_move_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.troopEid = 0;
                object.dstPos = null;
            }
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            if (message.dstPos != null && message.hasOwnProperty("dstPos"))
                object.dstPos = $root.world.Position.toObject(message.dstPos, options);
            return object;
        };

        /**
         * Converts this c2s_troop_move_to to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_move_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_move_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_move_to
         * @function getTypeUrl
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_move_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_move_to";
        };

        return c2s_troop_move_to;
    })();

    world.s2c_troop_move_to = (function() {

        /**
         * Properties of a s2c_troop_move_to.
         * @memberof world
         * @interface Is2c_troop_move_to
         * @property {number|null} [err] s2c_troop_move_to err
         */

        /**
         * Constructs a new s2c_troop_move_to.
         * @memberof world
         * @classdesc Represents a s2c_troop_move_to.
         * @implements Is2c_troop_move_to
         * @constructor
         * @param {world.Is2c_troop_move_to=} [properties] Properties to set
         */
        function s2c_troop_move_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_move_to err.
         * @member {number} err
         * @memberof world.s2c_troop_move_to
         * @instance
         */
        s2c_troop_move_to.prototype.err = 0;

        /**
         * Creates a new s2c_troop_move_to instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.Is2c_troop_move_to=} [properties] Properties to set
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to instance
         */
        s2c_troop_move_to.create = function create(properties) {
            return new s2c_troop_move_to(properties);
        };

        /**
         * Encodes the specified s2c_troop_move_to message. Does not implicitly {@link world.s2c_troop_move_to.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.Is2c_troop_move_to} message s2c_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_move_to message, length delimited. Does not implicitly {@link world.s2c_troop_move_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.Is2c_troop_move_to} message s2c_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_move_to message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_move_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_move_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_move_to message.
         * @function verify
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_move_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_move_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to
         */
        s2c_troop_move_to.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_move_to)
                return object;
            var message = new $root.world.s2c_troop_move_to();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_move_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.s2c_troop_move_to} message s2c_troop_move_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_move_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_move_to to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_move_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_move_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_move_to
         * @function getTypeUrl
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_move_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_move_to";
        };

        return s2c_troop_move_to;
    })();

    world.c2s_troop_move_by = (function() {

        /**
         * Properties of a c2s_troop_move_by.
         * @memberof world
         * @interface Ic2s_troop_move_by
         * @property {number|null} [troopEid] c2s_troop_move_by troopEid
         * @property {number|null} [degree] c2s_troop_move_by degree
         */

        /**
         * Constructs a new c2s_troop_move_by.
         * @memberof world
         * @classdesc Represents a c2s_troop_move_by.
         * @implements Ic2s_troop_move_by
         * @constructor
         * @param {world.Ic2s_troop_move_by=} [properties] Properties to set
         */
        function c2s_troop_move_by(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_move_by troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_move_by
         * @instance
         */
        c2s_troop_move_by.prototype.troopEid = 0;

        /**
         * c2s_troop_move_by degree.
         * @member {number} degree
         * @memberof world.c2s_troop_move_by
         * @instance
         */
        c2s_troop_move_by.prototype.degree = 0;

        /**
         * Creates a new c2s_troop_move_by instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.Ic2s_troop_move_by=} [properties] Properties to set
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by instance
         */
        c2s_troop_move_by.create = function create(properties) {
            return new c2s_troop_move_by(properties);
        };

        /**
         * Encodes the specified c2s_troop_move_by message. Does not implicitly {@link world.c2s_troop_move_by.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.Ic2s_troop_move_by} message c2s_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_by.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.degree);
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_move_by message, length delimited. Does not implicitly {@link world.c2s_troop_move_by.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.Ic2s_troop_move_by} message c2s_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_by.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_move_by message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_by.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_move_by();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.degree = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_move_by message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_by.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_move_by message.
         * @function verify
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_move_by.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (!$util.isInteger(message.degree))
                    return "degree: integer expected";
            return null;
        };

        /**
         * Creates a c2s_troop_move_by message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by
         */
        c2s_troop_move_by.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_move_by)
                return object;
            var message = new $root.world.c2s_troop_move_by();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            if (object.degree != null)
                message.degree = object.degree >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_move_by message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.c2s_troop_move_by} message c2s_troop_move_by
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_move_by.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.troopEid = 0;
                object.degree = 0;
            }
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = message.degree;
            return object;
        };

        /**
         * Converts this c2s_troop_move_by to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_move_by
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_move_by.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_move_by
         * @function getTypeUrl
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_move_by.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_move_by";
        };

        return c2s_troop_move_by;
    })();

    world.s2c_troop_move_by = (function() {

        /**
         * Properties of a s2c_troop_move_by.
         * @memberof world
         * @interface Is2c_troop_move_by
         * @property {number|null} [err] s2c_troop_move_by err
         */

        /**
         * Constructs a new s2c_troop_move_by.
         * @memberof world
         * @classdesc Represents a s2c_troop_move_by.
         * @implements Is2c_troop_move_by
         * @constructor
         * @param {world.Is2c_troop_move_by=} [properties] Properties to set
         */
        function s2c_troop_move_by(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_move_by err.
         * @member {number} err
         * @memberof world.s2c_troop_move_by
         * @instance
         */
        s2c_troop_move_by.prototype.err = 0;

        /**
         * Creates a new s2c_troop_move_by instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.Is2c_troop_move_by=} [properties] Properties to set
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by instance
         */
        s2c_troop_move_by.create = function create(properties) {
            return new s2c_troop_move_by(properties);
        };

        /**
         * Encodes the specified s2c_troop_move_by message. Does not implicitly {@link world.s2c_troop_move_by.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.Is2c_troop_move_by} message s2c_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_by.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_move_by message, length delimited. Does not implicitly {@link world.s2c_troop_move_by.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.Is2c_troop_move_by} message s2c_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_by.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_move_by message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_by.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_move_by();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_move_by message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_by.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_move_by message.
         * @function verify
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_move_by.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_move_by message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by
         */
        s2c_troop_move_by.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_move_by)
                return object;
            var message = new $root.world.s2c_troop_move_by();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_move_by message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.s2c_troop_move_by} message s2c_troop_move_by
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_move_by.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_move_by to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_move_by
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_move_by.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_move_by
         * @function getTypeUrl
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_move_by.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_move_by";
        };

        return s2c_troop_move_by;
    })();

    world.c2s_troop_move_stop = (function() {

        /**
         * Properties of a c2s_troop_move_stop.
         * @memberof world
         * @interface Ic2s_troop_move_stop
         * @property {number|null} [troopEid] c2s_troop_move_stop troopEid
         */

        /**
         * Constructs a new c2s_troop_move_stop.
         * @memberof world
         * @classdesc Represents a c2s_troop_move_stop.
         * @implements Ic2s_troop_move_stop
         * @constructor
         * @param {world.Ic2s_troop_move_stop=} [properties] Properties to set
         */
        function c2s_troop_move_stop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_move_stop troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_move_stop
         * @instance
         */
        c2s_troop_move_stop.prototype.troopEid = 0;

        /**
         * Creates a new c2s_troop_move_stop instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.Ic2s_troop_move_stop=} [properties] Properties to set
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop instance
         */
        c2s_troop_move_stop.create = function create(properties) {
            return new c2s_troop_move_stop(properties);
        };

        /**
         * Encodes the specified c2s_troop_move_stop message. Does not implicitly {@link world.c2s_troop_move_stop.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.Ic2s_troop_move_stop} message c2s_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_stop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_move_stop message, length delimited. Does not implicitly {@link world.c2s_troop_move_stop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.Ic2s_troop_move_stop} message c2s_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_stop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_move_stop message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_stop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_move_stop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_move_stop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_stop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_move_stop message.
         * @function verify
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_move_stop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_troop_move_stop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop
         */
        c2s_troop_move_stop.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_move_stop)
                return object;
            var message = new $root.world.c2s_troop_move_stop();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_move_stop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.c2s_troop_move_stop} message c2s_troop_move_stop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_move_stop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.troopEid = 0;
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            return object;
        };

        /**
         * Converts this c2s_troop_move_stop to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_move_stop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_move_stop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_move_stop
         * @function getTypeUrl
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_move_stop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_move_stop";
        };

        return c2s_troop_move_stop;
    })();

    world.s2c_troop_move_stop = (function() {

        /**
         * Properties of a s2c_troop_move_stop.
         * @memberof world
         * @interface Is2c_troop_move_stop
         * @property {number|null} [err] s2c_troop_move_stop err
         */

        /**
         * Constructs a new s2c_troop_move_stop.
         * @memberof world
         * @classdesc Represents a s2c_troop_move_stop.
         * @implements Is2c_troop_move_stop
         * @constructor
         * @param {world.Is2c_troop_move_stop=} [properties] Properties to set
         */
        function s2c_troop_move_stop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_move_stop err.
         * @member {number} err
         * @memberof world.s2c_troop_move_stop
         * @instance
         */
        s2c_troop_move_stop.prototype.err = 0;

        /**
         * Creates a new s2c_troop_move_stop instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.Is2c_troop_move_stop=} [properties] Properties to set
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop instance
         */
        s2c_troop_move_stop.create = function create(properties) {
            return new s2c_troop_move_stop(properties);
        };

        /**
         * Encodes the specified s2c_troop_move_stop message. Does not implicitly {@link world.s2c_troop_move_stop.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.Is2c_troop_move_stop} message s2c_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_stop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_move_stop message, length delimited. Does not implicitly {@link world.s2c_troop_move_stop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.Is2c_troop_move_stop} message s2c_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_stop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_move_stop message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_stop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_move_stop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_move_stop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_stop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_move_stop message.
         * @function verify
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_move_stop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_move_stop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop
         */
        s2c_troop_move_stop.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_move_stop)
                return object;
            var message = new $root.world.s2c_troop_move_stop();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_move_stop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.s2c_troop_move_stop} message s2c_troop_move_stop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_move_stop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_move_stop to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_move_stop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_move_stop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_move_stop
         * @function getTypeUrl
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_move_stop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_move_stop";
        };

        return s2c_troop_move_stop;
    })();

    world.notify_alliances = (function() {

        /**
         * Properties of a notify_alliances.
         * @memberof world
         * @interface Inotify_alliances
         * @property {Array.<world.IAlliance>|null} [alliances] notify_alliances alliances
         */

        /**
         * Constructs a new notify_alliances.
         * @memberof world
         * @classdesc Represents a notify_alliances.
         * @implements Inotify_alliances
         * @constructor
         * @param {world.Inotify_alliances=} [properties] Properties to set
         */
        function notify_alliances(properties) {
            this.alliances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_alliances alliances.
         * @member {Array.<world.IAlliance>} alliances
         * @memberof world.notify_alliances
         * @instance
         */
        notify_alliances.prototype.alliances = $util.emptyArray;

        /**
         * Creates a new notify_alliances instance using the specified properties.
         * @function create
         * @memberof world.notify_alliances
         * @static
         * @param {world.Inotify_alliances=} [properties] Properties to set
         * @returns {world.notify_alliances} notify_alliances instance
         */
        notify_alliances.create = function create(properties) {
            return new notify_alliances(properties);
        };

        /**
         * Encodes the specified notify_alliances message. Does not implicitly {@link world.notify_alliances.verify|verify} messages.
         * @function encode
         * @memberof world.notify_alliances
         * @static
         * @param {world.Inotify_alliances} message notify_alliances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_alliances.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alliances != null && message.alliances.length)
                for (var i = 0; i < message.alliances.length; ++i)
                    $root.world.Alliance.encode(message.alliances[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_alliances message, length delimited. Does not implicitly {@link world.notify_alliances.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_alliances
         * @static
         * @param {world.Inotify_alliances} message notify_alliances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_alliances.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_alliances message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_alliances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_alliances} notify_alliances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_alliances.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_alliances();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.alliances && message.alliances.length))
                            message.alliances = [];
                        message.alliances.push($root.world.Alliance.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_alliances message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_alliances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_alliances} notify_alliances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_alliances.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_alliances message.
         * @function verify
         * @memberof world.notify_alliances
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_alliances.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alliances != null && message.hasOwnProperty("alliances")) {
                if (!Array.isArray(message.alliances))
                    return "alliances: array expected";
                for (var i = 0; i < message.alliances.length; ++i) {
                    var error = $root.world.Alliance.verify(message.alliances[i]);
                    if (error)
                        return "alliances." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_alliances message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_alliances
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_alliances} notify_alliances
         */
        notify_alliances.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_alliances)
                return object;
            var message = new $root.world.notify_alliances();
            if (object.alliances) {
                if (!Array.isArray(object.alliances))
                    throw TypeError(".world.notify_alliances.alliances: array expected");
                message.alliances = [];
                for (var i = 0; i < object.alliances.length; ++i) {
                    if (typeof object.alliances[i] !== "object")
                        throw TypeError(".world.notify_alliances.alliances: object expected");
                    message.alliances[i] = $root.world.Alliance.fromObject(object.alliances[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_alliances message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_alliances
         * @static
         * @param {world.notify_alliances} message notify_alliances
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_alliances.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.alliances = [];
            if (message.alliances && message.alliances.length) {
                object.alliances = [];
                for (var j = 0; j < message.alliances.length; ++j)
                    object.alliances[j] = $root.world.Alliance.toObject(message.alliances[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_alliances to JSON.
         * @function toJSON
         * @memberof world.notify_alliances
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_alliances.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_alliances
         * @function getTypeUrl
         * @memberof world.notify_alliances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_alliances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_alliances";
        };

        return notify_alliances;
    })();

    world.notify_roles = (function() {

        /**
         * Properties of a notify_roles.
         * @memberof world
         * @interface Inotify_roles
         * @property {Array.<world.IRole>|null} [roles] notify_roles roles
         */

        /**
         * Constructs a new notify_roles.
         * @memberof world
         * @classdesc Represents a notify_roles.
         * @implements Inotify_roles
         * @constructor
         * @param {world.Inotify_roles=} [properties] Properties to set
         */
        function notify_roles(properties) {
            this.roles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_roles roles.
         * @member {Array.<world.IRole>} roles
         * @memberof world.notify_roles
         * @instance
         */
        notify_roles.prototype.roles = $util.emptyArray;

        /**
         * Creates a new notify_roles instance using the specified properties.
         * @function create
         * @memberof world.notify_roles
         * @static
         * @param {world.Inotify_roles=} [properties] Properties to set
         * @returns {world.notify_roles} notify_roles instance
         */
        notify_roles.create = function create(properties) {
            return new notify_roles(properties);
        };

        /**
         * Encodes the specified notify_roles message. Does not implicitly {@link world.notify_roles.verify|verify} messages.
         * @function encode
         * @memberof world.notify_roles
         * @static
         * @param {world.Inotify_roles} message notify_roles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_roles.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roles != null && message.roles.length)
                for (var i = 0; i < message.roles.length; ++i)
                    $root.world.Role.encode(message.roles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_roles message, length delimited. Does not implicitly {@link world.notify_roles.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_roles
         * @static
         * @param {world.Inotify_roles} message notify_roles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_roles.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_roles message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_roles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_roles} notify_roles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_roles.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_roles();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push($root.world.Role.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_roles message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_roles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_roles} notify_roles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_roles.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_roles message.
         * @function verify
         * @memberof world.notify_roles
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_roles.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (var i = 0; i < message.roles.length; ++i) {
                    var error = $root.world.Role.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_roles message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_roles
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_roles} notify_roles
         */
        notify_roles.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_roles)
                return object;
            var message = new $root.world.notify_roles();
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".world.notify_roles.roles: array expected");
                message.roles = [];
                for (var i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".world.notify_roles.roles: object expected");
                    message.roles[i] = $root.world.Role.fromObject(object.roles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_roles message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_roles
         * @static
         * @param {world.notify_roles} message notify_roles
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_roles.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.roles = [];
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (var j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.world.Role.toObject(message.roles[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_roles to JSON.
         * @function toJSON
         * @memberof world.notify_roles
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_roles.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_roles
         * @function getTypeUrl
         * @memberof world.notify_roles
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_roles.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_roles";
        };

        return notify_roles;
    })();

    world.AddEntityAction = (function() {

        /**
         * Properties of an AddEntityAction.
         * @memberof world
         * @interface IAddEntityAction
         * @property {world.IEntity|null} [entity] AddEntityAction entity
         */

        /**
         * Constructs a new AddEntityAction.
         * @memberof world
         * @classdesc Represents an AddEntityAction.
         * @implements IAddEntityAction
         * @constructor
         * @param {world.IAddEntityAction=} [properties] Properties to set
         */
        function AddEntityAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddEntityAction entity.
         * @member {world.IEntity|null|undefined} entity
         * @memberof world.AddEntityAction
         * @instance
         */
        AddEntityAction.prototype.entity = null;

        /**
         * Creates a new AddEntityAction instance using the specified properties.
         * @function create
         * @memberof world.AddEntityAction
         * @static
         * @param {world.IAddEntityAction=} [properties] Properties to set
         * @returns {world.AddEntityAction} AddEntityAction instance
         */
        AddEntityAction.create = function create(properties) {
            return new AddEntityAction(properties);
        };

        /**
         * Encodes the specified AddEntityAction message. Does not implicitly {@link world.AddEntityAction.verify|verify} messages.
         * @function encode
         * @memberof world.AddEntityAction
         * @static
         * @param {world.IAddEntityAction} message AddEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddEntityAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                $root.world.Entity.encode(message.entity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddEntityAction message, length delimited. Does not implicitly {@link world.AddEntityAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.AddEntityAction
         * @static
         * @param {world.IAddEntityAction} message AddEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddEntityAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddEntityAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.AddEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.AddEntityAction} AddEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddEntityAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.AddEntityAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entity = $root.world.Entity.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddEntityAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.AddEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.AddEntityAction} AddEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddEntityAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddEntityAction message.
         * @function verify
         * @memberof world.AddEntityAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddEntityAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity")) {
                var error = $root.world.Entity.verify(message.entity);
                if (error)
                    return "entity." + error;
            }
            return null;
        };

        /**
         * Creates an AddEntityAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.AddEntityAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.AddEntityAction} AddEntityAction
         */
        AddEntityAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.AddEntityAction)
                return object;
            var message = new $root.world.AddEntityAction();
            if (object.entity != null) {
                if (typeof object.entity !== "object")
                    throw TypeError(".world.AddEntityAction.entity: object expected");
                message.entity = $root.world.Entity.fromObject(object.entity);
            }
            return message;
        };

        /**
         * Creates a plain object from an AddEntityAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.AddEntityAction
         * @static
         * @param {world.AddEntityAction} message AddEntityAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddEntityAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.entity = null;
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = $root.world.Entity.toObject(message.entity, options);
            return object;
        };

        /**
         * Converts this AddEntityAction to JSON.
         * @function toJSON
         * @memberof world.AddEntityAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddEntityAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddEntityAction
         * @function getTypeUrl
         * @memberof world.AddEntityAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddEntityAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.AddEntityAction";
        };

        return AddEntityAction;
    })();

    world.DelEntityAction = (function() {

        /**
         * Properties of a DelEntityAction.
         * @memberof world
         * @interface IDelEntityAction
         * @property {number|Long|null} [eid] DelEntityAction eid
         */

        /**
         * Constructs a new DelEntityAction.
         * @memberof world
         * @classdesc Represents a DelEntityAction.
         * @implements IDelEntityAction
         * @constructor
         * @param {world.IDelEntityAction=} [properties] Properties to set
         */
        function DelEntityAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelEntityAction eid.
         * @member {number|Long} eid
         * @memberof world.DelEntityAction
         * @instance
         */
        DelEntityAction.prototype.eid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DelEntityAction instance using the specified properties.
         * @function create
         * @memberof world.DelEntityAction
         * @static
         * @param {world.IDelEntityAction=} [properties] Properties to set
         * @returns {world.DelEntityAction} DelEntityAction instance
         */
        DelEntityAction.create = function create(properties) {
            return new DelEntityAction(properties);
        };

        /**
         * Encodes the specified DelEntityAction message. Does not implicitly {@link world.DelEntityAction.verify|verify} messages.
         * @function encode
         * @memberof world.DelEntityAction
         * @static
         * @param {world.IDelEntityAction} message DelEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelEntityAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.eid);
            return writer;
        };

        /**
         * Encodes the specified DelEntityAction message, length delimited. Does not implicitly {@link world.DelEntityAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.DelEntityAction
         * @static
         * @param {world.IDelEntityAction} message DelEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelEntityAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelEntityAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.DelEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.DelEntityAction} DelEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelEntityAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.DelEntityAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelEntityAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.DelEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.DelEntityAction} DelEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelEntityAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelEntityAction message.
         * @function verify
         * @memberof world.DelEntityAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelEntityAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid) && !(message.eid && $util.isInteger(message.eid.low) && $util.isInteger(message.eid.high)))
                    return "eid: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelEntityAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.DelEntityAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.DelEntityAction} DelEntityAction
         */
        DelEntityAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.DelEntityAction)
                return object;
            var message = new $root.world.DelEntityAction();
            if (object.eid != null)
                if ($util.Long)
                    (message.eid = $util.Long.fromValue(object.eid)).unsigned = false;
                else if (typeof object.eid === "string")
                    message.eid = parseInt(object.eid, 10);
                else if (typeof object.eid === "number")
                    message.eid = object.eid;
                else if (typeof object.eid === "object")
                    message.eid = new $util.LongBits(object.eid.low >>> 0, object.eid.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DelEntityAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.DelEntityAction
         * @static
         * @param {world.DelEntityAction} message DelEntityAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelEntityAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.eid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.eid = options.longs === String ? "0" : 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (typeof message.eid === "number")
                    object.eid = options.longs === String ? String(message.eid) : message.eid;
                else
                    object.eid = options.longs === String ? $util.Long.prototype.toString.call(message.eid) : options.longs === Number ? new $util.LongBits(message.eid.low >>> 0, message.eid.high >>> 0).toNumber() : message.eid;
            return object;
        };

        /**
         * Converts this DelEntityAction to JSON.
         * @function toJSON
         * @memberof world.DelEntityAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelEntityAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DelEntityAction
         * @function getTypeUrl
         * @memberof world.DelEntityAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DelEntityAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.DelEntityAction";
        };

        return DelEntityAction;
    })();

    world.MoveAction = (function() {

        /**
         * Properties of a MoveAction.
         * @memberof world
         * @interface IMoveAction
         * @property {number|Long|null} [eid] MoveAction eid
         * @property {Array.<number>|null} [path] MoveAction path
         * @property {number|null} [speed] MoveAction speed
         * @property {number|null} [startMs] MoveAction startMs
         * @property {world.IPosition|null} [curPos] MoveAction curPos
         * @property {number|null} [degree] MoveAction degree
         */

        /**
         * Constructs a new MoveAction.
         * @memberof world
         * @classdesc Represents a MoveAction.
         * @implements IMoveAction
         * @constructor
         * @param {world.IMoveAction=} [properties] Properties to set
         */
        function MoveAction(properties) {
            this.path = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveAction eid.
         * @member {number|Long} eid
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.eid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MoveAction path.
         * @member {Array.<number>} path
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.path = $util.emptyArray;

        /**
         * MoveAction speed.
         * @member {number} speed
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.speed = 0;

        /**
         * MoveAction startMs.
         * @member {number} startMs
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.startMs = 0;

        /**
         * MoveAction curPos.
         * @member {world.IPosition|null|undefined} curPos
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.curPos = null;

        /**
         * MoveAction degree.
         * @member {number} degree
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.degree = 0;

        /**
         * Creates a new MoveAction instance using the specified properties.
         * @function create
         * @memberof world.MoveAction
         * @static
         * @param {world.IMoveAction=} [properties] Properties to set
         * @returns {world.MoveAction} MoveAction instance
         */
        MoveAction.create = function create(properties) {
            return new MoveAction(properties);
        };

        /**
         * Encodes the specified MoveAction message. Does not implicitly {@link world.MoveAction.verify|verify} messages.
         * @function encode
         * @memberof world.MoveAction
         * @static
         * @param {world.IMoveAction} message MoveAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.eid);
            if (message.path != null && message.path.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.path.length; ++i)
                    writer.uint32(message.path[i]);
                writer.ldelim();
            }
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.speed);
            if (message.startMs != null && Object.hasOwnProperty.call(message, "startMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.startMs);
            if (message.curPos != null && Object.hasOwnProperty.call(message, "curPos"))
                $root.world.Position.encode(message.curPos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.degree);
            return writer;
        };

        /**
         * Encodes the specified MoveAction message, length delimited. Does not implicitly {@link world.MoveAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.MoveAction
         * @static
         * @param {world.IMoveAction} message MoveAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.MoveAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.MoveAction} MoveAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.MoveAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.int64();
                        break;
                    }
                case 2: {
                        if (!(message.path && message.path.length))
                            message.path = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.path.push(reader.uint32());
                        } else
                            message.path.push(reader.uint32());
                        break;
                    }
                case 3: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 4: {
                        message.startMs = reader.uint32();
                        break;
                    }
                case 5: {
                        message.curPos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.degree = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.MoveAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.MoveAction} MoveAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveAction message.
         * @function verify
         * @memberof world.MoveAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid) && !(message.eid && $util.isInteger(message.eid.low) && $util.isInteger(message.eid.high)))
                    return "eid: integer|Long expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (var i = 0; i < message.path.length; ++i)
                    if (!$util.isInteger(message.path[i]))
                        return "path: integer[] expected";
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                if (!$util.isInteger(message.startMs))
                    return "startMs: integer expected";
            if (message.curPos != null && message.hasOwnProperty("curPos")) {
                var error = $root.world.Position.verify(message.curPos);
                if (error)
                    return "curPos." + error;
            }
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (!$util.isInteger(message.degree))
                    return "degree: integer expected";
            return null;
        };

        /**
         * Creates a MoveAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.MoveAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.MoveAction} MoveAction
         */
        MoveAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.MoveAction)
                return object;
            var message = new $root.world.MoveAction();
            if (object.eid != null)
                if ($util.Long)
                    (message.eid = $util.Long.fromValue(object.eid)).unsigned = false;
                else if (typeof object.eid === "string")
                    message.eid = parseInt(object.eid, 10);
                else if (typeof object.eid === "number")
                    message.eid = object.eid;
                else if (typeof object.eid === "object")
                    message.eid = new $util.LongBits(object.eid.low >>> 0, object.eid.high >>> 0).toNumber();
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".world.MoveAction.path: array expected");
                message.path = [];
                for (var i = 0; i < object.path.length; ++i)
                    message.path[i] = object.path[i] >>> 0;
            }
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.startMs != null)
                message.startMs = object.startMs >>> 0;
            if (object.curPos != null) {
                if (typeof object.curPos !== "object")
                    throw TypeError(".world.MoveAction.curPos: object expected");
                message.curPos = $root.world.Position.fromObject(object.curPos);
            }
            if (object.degree != null)
                message.degree = object.degree >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MoveAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.MoveAction
         * @static
         * @param {world.MoveAction} message MoveAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoveAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.eid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.eid = options.longs === String ? "0" : 0;
                object.speed = 0;
                object.startMs = 0;
                object.curPos = null;
                object.degree = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (typeof message.eid === "number")
                    object.eid = options.longs === String ? String(message.eid) : message.eid;
                else
                    object.eid = options.longs === String ? $util.Long.prototype.toString.call(message.eid) : options.longs === Number ? new $util.LongBits(message.eid.low >>> 0, message.eid.high >>> 0).toNumber() : message.eid;
            if (message.path && message.path.length) {
                object.path = [];
                for (var j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                object.startMs = message.startMs;
            if (message.curPos != null && message.hasOwnProperty("curPos"))
                object.curPos = $root.world.Position.toObject(message.curPos, options);
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = message.degree;
            return object;
        };

        /**
         * Converts this MoveAction to JSON.
         * @function toJSON
         * @memberof world.MoveAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoveAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MoveAction
         * @function getTypeUrl
         * @memberof world.MoveAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MoveAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.MoveAction";
        };

        return MoveAction;
    })();

    world.EntityAction = (function() {

        /**
         * Properties of an EntityAction.
         * @memberof world
         * @interface IEntityAction
         * @property {number|null} [action] EntityAction action
         * @property {world.IAddEntityAction|null} [addEntity] EntityAction addEntity
         * @property {world.IDelEntityAction|null} [delEntity] EntityAction delEntity
         * @property {world.IMoveAction|null} [move] EntityAction move
         */

        /**
         * Constructs a new EntityAction.
         * @memberof world
         * @classdesc Represents an EntityAction.
         * @implements IEntityAction
         * @constructor
         * @param {world.IEntityAction=} [properties] Properties to set
         */
        function EntityAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EntityAction action.
         * @member {number} action
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.action = 0;

        /**
         * EntityAction addEntity.
         * @member {world.IAddEntityAction|null|undefined} addEntity
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.addEntity = null;

        /**
         * EntityAction delEntity.
         * @member {world.IDelEntityAction|null|undefined} delEntity
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.delEntity = null;

        /**
         * EntityAction move.
         * @member {world.IMoveAction|null|undefined} move
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.move = null;

        /**
         * Creates a new EntityAction instance using the specified properties.
         * @function create
         * @memberof world.EntityAction
         * @static
         * @param {world.IEntityAction=} [properties] Properties to set
         * @returns {world.EntityAction} EntityAction instance
         */
        EntityAction.create = function create(properties) {
            return new EntityAction(properties);
        };

        /**
         * Encodes the specified EntityAction message. Does not implicitly {@link world.EntityAction.verify|verify} messages.
         * @function encode
         * @memberof world.EntityAction
         * @static
         * @param {world.IEntityAction} message EntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.action);
            if (message.addEntity != null && Object.hasOwnProperty.call(message, "addEntity"))
                $root.world.AddEntityAction.encode(message.addEntity, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.delEntity != null && Object.hasOwnProperty.call(message, "delEntity"))
                $root.world.DelEntityAction.encode(message.delEntity, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.move != null && Object.hasOwnProperty.call(message, "move"))
                $root.world.MoveAction.encode(message.move, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EntityAction message, length delimited. Does not implicitly {@link world.EntityAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.EntityAction
         * @static
         * @param {world.IEntityAction} message EntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EntityAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.EntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.EntityAction} EntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.EntityAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.action = reader.uint32();
                        break;
                    }
                case 10: {
                        message.addEntity = $root.world.AddEntityAction.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.delEntity = $root.world.DelEntityAction.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.move = $root.world.MoveAction.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EntityAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.EntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.EntityAction} EntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EntityAction message.
         * @function verify
         * @memberof world.EntityAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EntityAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isInteger(message.action))
                    return "action: integer expected";
            if (message.addEntity != null && message.hasOwnProperty("addEntity")) {
                var error = $root.world.AddEntityAction.verify(message.addEntity);
                if (error)
                    return "addEntity." + error;
            }
            if (message.delEntity != null && message.hasOwnProperty("delEntity")) {
                var error = $root.world.DelEntityAction.verify(message.delEntity);
                if (error)
                    return "delEntity." + error;
            }
            if (message.move != null && message.hasOwnProperty("move")) {
                var error = $root.world.MoveAction.verify(message.move);
                if (error)
                    return "move." + error;
            }
            return null;
        };

        /**
         * Creates an EntityAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.EntityAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.EntityAction} EntityAction
         */
        EntityAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.EntityAction)
                return object;
            var message = new $root.world.EntityAction();
            if (object.action != null)
                message.action = object.action >>> 0;
            if (object.addEntity != null) {
                if (typeof object.addEntity !== "object")
                    throw TypeError(".world.EntityAction.addEntity: object expected");
                message.addEntity = $root.world.AddEntityAction.fromObject(object.addEntity);
            }
            if (object.delEntity != null) {
                if (typeof object.delEntity !== "object")
                    throw TypeError(".world.EntityAction.delEntity: object expected");
                message.delEntity = $root.world.DelEntityAction.fromObject(object.delEntity);
            }
            if (object.move != null) {
                if (typeof object.move !== "object")
                    throw TypeError(".world.EntityAction.move: object expected");
                message.move = $root.world.MoveAction.fromObject(object.move);
            }
            return message;
        };

        /**
         * Creates a plain object from an EntityAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.EntityAction
         * @static
         * @param {world.EntityAction} message EntityAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EntityAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = 0;
                object.addEntity = null;
                object.delEntity = null;
                object.move = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            if (message.addEntity != null && message.hasOwnProperty("addEntity"))
                object.addEntity = $root.world.AddEntityAction.toObject(message.addEntity, options);
            if (message.delEntity != null && message.hasOwnProperty("delEntity"))
                object.delEntity = $root.world.DelEntityAction.toObject(message.delEntity, options);
            if (message.move != null && message.hasOwnProperty("move"))
                object.move = $root.world.MoveAction.toObject(message.move, options);
            return object;
        };

        /**
         * Converts this EntityAction to JSON.
         * @function toJSON
         * @memberof world.EntityAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EntityAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EntityAction
         * @function getTypeUrl
         * @memberof world.EntityAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.EntityAction";
        };

        return EntityAction;
    })();

    world.notify_entities = (function() {

        /**
         * Properties of a notify_entities.
         * @memberof world
         * @interface Inotify_entities
         * @property {Array.<world.IEntity>|null} [enterList] notify_entities enterList
         * @property {Array.<number>|null} [leaveList] notify_entities leaveList
         */

        /**
         * Constructs a new notify_entities.
         * @memberof world
         * @classdesc Represents a notify_entities.
         * @implements Inotify_entities
         * @constructor
         * @param {world.Inotify_entities=} [properties] Properties to set
         */
        function notify_entities(properties) {
            this.enterList = [];
            this.leaveList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_entities enterList.
         * @member {Array.<world.IEntity>} enterList
         * @memberof world.notify_entities
         * @instance
         */
        notify_entities.prototype.enterList = $util.emptyArray;

        /**
         * notify_entities leaveList.
         * @member {Array.<number>} leaveList
         * @memberof world.notify_entities
         * @instance
         */
        notify_entities.prototype.leaveList = $util.emptyArray;

        /**
         * Creates a new notify_entities instance using the specified properties.
         * @function create
         * @memberof world.notify_entities
         * @static
         * @param {world.Inotify_entities=} [properties] Properties to set
         * @returns {world.notify_entities} notify_entities instance
         */
        notify_entities.create = function create(properties) {
            return new notify_entities(properties);
        };

        /**
         * Encodes the specified notify_entities message. Does not implicitly {@link world.notify_entities.verify|verify} messages.
         * @function encode
         * @memberof world.notify_entities
         * @static
         * @param {world.Inotify_entities} message notify_entities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_entities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterList != null && message.enterList.length)
                for (var i = 0; i < message.enterList.length; ++i)
                    $root.world.Entity.encode(message.enterList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.leaveList != null && message.leaveList.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.leaveList.length; ++i)
                    writer.uint32(message.leaveList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified notify_entities message, length delimited. Does not implicitly {@link world.notify_entities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_entities
         * @static
         * @param {world.Inotify_entities} message notify_entities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_entities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_entities message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_entities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_entities} notify_entities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_entities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_entities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        if (!(message.enterList && message.enterList.length))
                            message.enterList = [];
                        message.enterList.push($root.world.Entity.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.leaveList && message.leaveList.length))
                            message.leaveList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.leaveList.push(reader.uint32());
                        } else
                            message.leaveList.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_entities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_entities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_entities} notify_entities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_entities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_entities message.
         * @function verify
         * @memberof world.notify_entities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_entities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterList != null && message.hasOwnProperty("enterList")) {
                if (!Array.isArray(message.enterList))
                    return "enterList: array expected";
                for (var i = 0; i < message.enterList.length; ++i) {
                    var error = $root.world.Entity.verify(message.enterList[i]);
                    if (error)
                        return "enterList." + error;
                }
            }
            if (message.leaveList != null && message.hasOwnProperty("leaveList")) {
                if (!Array.isArray(message.leaveList))
                    return "leaveList: array expected";
                for (var i = 0; i < message.leaveList.length; ++i)
                    if (!$util.isInteger(message.leaveList[i]))
                        return "leaveList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_entities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_entities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_entities} notify_entities
         */
        notify_entities.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_entities)
                return object;
            var message = new $root.world.notify_entities();
            if (object.enterList) {
                if (!Array.isArray(object.enterList))
                    throw TypeError(".world.notify_entities.enterList: array expected");
                message.enterList = [];
                for (var i = 0; i < object.enterList.length; ++i) {
                    if (typeof object.enterList[i] !== "object")
                        throw TypeError(".world.notify_entities.enterList: object expected");
                    message.enterList[i] = $root.world.Entity.fromObject(object.enterList[i]);
                }
            }
            if (object.leaveList) {
                if (!Array.isArray(object.leaveList))
                    throw TypeError(".world.notify_entities.leaveList: array expected");
                message.leaveList = [];
                for (var i = 0; i < object.leaveList.length; ++i)
                    message.leaveList[i] = object.leaveList[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_entities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_entities
         * @static
         * @param {world.notify_entities} message notify_entities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_entities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.enterList = [];
                object.leaveList = [];
            }
            if (message.enterList && message.enterList.length) {
                object.enterList = [];
                for (var j = 0; j < message.enterList.length; ++j)
                    object.enterList[j] = $root.world.Entity.toObject(message.enterList[j], options);
            }
            if (message.leaveList && message.leaveList.length) {
                object.leaveList = [];
                for (var j = 0; j < message.leaveList.length; ++j)
                    object.leaveList[j] = message.leaveList[j];
            }
            return object;
        };

        /**
         * Converts this notify_entities to JSON.
         * @function toJSON
         * @memberof world.notify_entities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_entities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_entities
         * @function getTypeUrl
         * @memberof world.notify_entities
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_entities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_entities";
        };

        return notify_entities;
    })();

    world.notify_actions = (function() {

        /**
         * Properties of a notify_actions.
         * @memberof world
         * @interface Inotify_actions
         * @property {Array.<world.IEntityAction>|null} [actions] notify_actions actions
         */

        /**
         * Constructs a new notify_actions.
         * @memberof world
         * @classdesc Represents a notify_actions.
         * @implements Inotify_actions
         * @constructor
         * @param {world.Inotify_actions=} [properties] Properties to set
         */
        function notify_actions(properties) {
            this.actions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_actions actions.
         * @member {Array.<world.IEntityAction>} actions
         * @memberof world.notify_actions
         * @instance
         */
        notify_actions.prototype.actions = $util.emptyArray;

        /**
         * Creates a new notify_actions instance using the specified properties.
         * @function create
         * @memberof world.notify_actions
         * @static
         * @param {world.Inotify_actions=} [properties] Properties to set
         * @returns {world.notify_actions} notify_actions instance
         */
        notify_actions.create = function create(properties) {
            return new notify_actions(properties);
        };

        /**
         * Encodes the specified notify_actions message. Does not implicitly {@link world.notify_actions.verify|verify} messages.
         * @function encode
         * @memberof world.notify_actions
         * @static
         * @param {world.Inotify_actions} message notify_actions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_actions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (var i = 0; i < message.actions.length; ++i)
                    $root.world.EntityAction.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_actions message, length delimited. Does not implicitly {@link world.notify_actions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_actions
         * @static
         * @param {world.Inotify_actions} message notify_actions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_actions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_actions message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_actions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_actions} notify_actions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_actions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_actions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.world.EntityAction.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_actions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_actions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_actions} notify_actions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_actions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_actions message.
         * @function verify
         * @memberof world.notify_actions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_actions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (var i = 0; i < message.actions.length; ++i) {
                    var error = $root.world.EntityAction.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_actions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_actions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_actions} notify_actions
         */
        notify_actions.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_actions)
                return object;
            var message = new $root.world.notify_actions();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".world.notify_actions.actions: array expected");
                message.actions = [];
                for (var i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".world.notify_actions.actions: object expected");
                    message.actions[i] = $root.world.EntityAction.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_actions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_actions
         * @static
         * @param {world.notify_actions} message notify_actions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_actions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (var j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.world.EntityAction.toObject(message.actions[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_actions to JSON.
         * @function toJSON
         * @memberof world.notify_actions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_actions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_actions
         * @function getTypeUrl
         * @memberof world.notify_actions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_actions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_actions";
        };

        return notify_actions;
    })();

    world.notify_battle_result = (function() {

        /**
         * Properties of a notify_battle_result.
         * @memberof world
         * @interface Inotify_battle_result
         * @property {number|null} [srcEid] notify_battle_result srcEid
         * @property {number|null} [dstEid] notify_battle_result dstEid
         * @property {number|null} [result] notify_battle_result result
         */

        /**
         * Constructs a new notify_battle_result.
         * @memberof world
         * @classdesc Represents a notify_battle_result.
         * @implements Inotify_battle_result
         * @constructor
         * @param {world.Inotify_battle_result=} [properties] Properties to set
         */
        function notify_battle_result(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_battle_result srcEid.
         * @member {number} srcEid
         * @memberof world.notify_battle_result
         * @instance
         */
        notify_battle_result.prototype.srcEid = 0;

        /**
         * notify_battle_result dstEid.
         * @member {number} dstEid
         * @memberof world.notify_battle_result
         * @instance
         */
        notify_battle_result.prototype.dstEid = 0;

        /**
         * notify_battle_result result.
         * @member {number} result
         * @memberof world.notify_battle_result
         * @instance
         */
        notify_battle_result.prototype.result = 0;

        /**
         * Creates a new notify_battle_result instance using the specified properties.
         * @function create
         * @memberof world.notify_battle_result
         * @static
         * @param {world.Inotify_battle_result=} [properties] Properties to set
         * @returns {world.notify_battle_result} notify_battle_result instance
         */
        notify_battle_result.create = function create(properties) {
            return new notify_battle_result(properties);
        };

        /**
         * Encodes the specified notify_battle_result message. Does not implicitly {@link world.notify_battle_result.verify|verify} messages.
         * @function encode
         * @memberof world.notify_battle_result
         * @static
         * @param {world.Inotify_battle_result} message notify_battle_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_battle_result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.srcEid != null && Object.hasOwnProperty.call(message, "srcEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.srcEid);
            if (message.dstEid != null && Object.hasOwnProperty.call(message, "dstEid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dstEid);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.result);
            return writer;
        };

        /**
         * Encodes the specified notify_battle_result message, length delimited. Does not implicitly {@link world.notify_battle_result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_battle_result
         * @static
         * @param {world.Inotify_battle_result} message notify_battle_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_battle_result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_battle_result message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_battle_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_battle_result} notify_battle_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_battle_result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_battle_result();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.srcEid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.dstEid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.result = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_battle_result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_battle_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_battle_result} notify_battle_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_battle_result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_battle_result message.
         * @function verify
         * @memberof world.notify_battle_result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_battle_result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.srcEid != null && message.hasOwnProperty("srcEid"))
                if (!$util.isInteger(message.srcEid))
                    return "srcEid: integer expected";
            if (message.dstEid != null && message.hasOwnProperty("dstEid"))
                if (!$util.isInteger(message.dstEid))
                    return "dstEid: integer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            return null;
        };

        /**
         * Creates a notify_battle_result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_battle_result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_battle_result} notify_battle_result
         */
        notify_battle_result.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_battle_result)
                return object;
            var message = new $root.world.notify_battle_result();
            if (object.srcEid != null)
                message.srcEid = object.srcEid >>> 0;
            if (object.dstEid != null)
                message.dstEid = object.dstEid >>> 0;
            if (object.result != null)
                message.result = object.result >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a notify_battle_result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_battle_result
         * @static
         * @param {world.notify_battle_result} message notify_battle_result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_battle_result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.srcEid = 0;
                object.dstEid = 0;
                object.result = 0;
            }
            if (message.srcEid != null && message.hasOwnProperty("srcEid"))
                object.srcEid = message.srcEid;
            if (message.dstEid != null && message.hasOwnProperty("dstEid"))
                object.dstEid = message.dstEid;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };

        /**
         * Converts this notify_battle_result to JSON.
         * @function toJSON
         * @memberof world.notify_battle_result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_battle_result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_battle_result
         * @function getTypeUrl
         * @memberof world.notify_battle_result
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_battle_result.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_battle_result";
        };

        return notify_battle_result;
    })();

    world.notify_occupy_result = (function() {

        /**
         * Properties of a notify_occupy_result.
         * @memberof world
         * @interface Inotify_occupy_result
         * @property {number|null} [type] notify_occupy_result type
         * @property {number|null} [aid] notify_occupy_result aid
         * @property {number|null} [bid] notify_occupy_result bid
         * @property {number|null} [eid] notify_occupy_result eid
         */

        /**
         * Constructs a new notify_occupy_result.
         * @memberof world
         * @classdesc Represents a notify_occupy_result.
         * @implements Inotify_occupy_result
         * @constructor
         * @param {world.Inotify_occupy_result=} [properties] Properties to set
         */
        function notify_occupy_result(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_occupy_result type.
         * @member {number} type
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.type = 0;

        /**
         * notify_occupy_result aid.
         * @member {number} aid
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.aid = 0;

        /**
         * notify_occupy_result bid.
         * @member {number} bid
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.bid = 0;

        /**
         * notify_occupy_result eid.
         * @member {number} eid
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.eid = 0;

        /**
         * Creates a new notify_occupy_result instance using the specified properties.
         * @function create
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.Inotify_occupy_result=} [properties] Properties to set
         * @returns {world.notify_occupy_result} notify_occupy_result instance
         */
        notify_occupy_result.create = function create(properties) {
            return new notify_occupy_result(properties);
        };

        /**
         * Encodes the specified notify_occupy_result message. Does not implicitly {@link world.notify_occupy_result.verify|verify} messages.
         * @function encode
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.Inotify_occupy_result} message notify_occupy_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_occupy_result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.aid);
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.bid);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified notify_occupy_result message, length delimited. Does not implicitly {@link world.notify_occupy_result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.Inotify_occupy_result} message notify_occupy_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_occupy_result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_occupy_result message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_occupy_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_occupy_result} notify_occupy_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_occupy_result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_occupy_result();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.uint32();
                        break;
                    }
                case 2: {
                        message.aid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.bid = reader.uint32();
                        break;
                    }
                case 4: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_occupy_result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_occupy_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_occupy_result} notify_occupy_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_occupy_result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_occupy_result message.
         * @function verify
         * @memberof world.notify_occupy_result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_occupy_result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            if (message.bid != null && message.hasOwnProperty("bid"))
                if (!$util.isInteger(message.bid))
                    return "bid: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a notify_occupy_result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_occupy_result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_occupy_result} notify_occupy_result
         */
        notify_occupy_result.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_occupy_result)
                return object;
            var message = new $root.world.notify_occupy_result();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            if (object.bid != null)
                message.bid = object.bid >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a notify_occupy_result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.notify_occupy_result} message notify_occupy_result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_occupy_result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.aid = 0;
                object.bid = 0;
                object.eid = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = message.bid;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this notify_occupy_result to JSON.
         * @function toJSON
         * @memberof world.notify_occupy_result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_occupy_result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_occupy_result
         * @function getTypeUrl
         * @memberof world.notify_occupy_result
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_occupy_result.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_occupy_result";
        };

        return notify_occupy_result;
    })();

    return world;
})();

module.exports = $root;
