/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.alliance = (function() {

    /**
     * Namespace alliance.
     * @exports alliance
     * @namespace
     */
    var alliance = {};

    alliance.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof alliance
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof alliance
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {alliance.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.Ic2s_load=} [properties] Properties to set
         * @returns {alliance.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link alliance.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link alliance.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof alliance.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {alliance.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.alliance.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof alliance.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {alliance.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof alliance.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof alliance.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {alliance.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.alliance.c2s_load)
                return object;
            return new $root.alliance.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof alliance.c2s_load
         * @static
         * @param {alliance.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof alliance.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof alliance.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/alliance.c2s_load";
        };

        return c2s_load;
    })();

    alliance.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof alliance
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {number|null} [aid] s2c_load aid
         */

        /**
         * Constructs a new s2c_load.
         * @memberof alliance
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {alliance.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof alliance.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load aid.
         * @member {number} aid
         * @memberof alliance.s2c_load
         * @instance
         */
        s2c_load.prototype.aid = 0;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.Is2c_load=} [properties] Properties to set
         * @returns {alliance.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link alliance.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.aid);
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link alliance.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof alliance.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {alliance.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.alliance.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.aid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof alliance.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {alliance.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof alliance.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof alliance.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {alliance.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.alliance.s2c_load)
                return object;
            var message = new $root.alliance.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof alliance.s2c_load
         * @static
         * @param {alliance.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.aid = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof alliance.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof alliance.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/alliance.s2c_load";
        };

        return s2c_load;
    })();

    return alliance;
})();

$root.bag = (function() {

    /**
     * Namespace bag.
     * @exports bag
     * @namespace
     */
    var bag = {};

    bag.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof bag
         * @interface IItem
         * @property {number|null} [id] Item id
         * @property {number|null} [uid] Item uid
         * @property {number|null} [num] Item num
         * @property {number|null} [expireTs] Item expireTs
         */

        /**
         * Constructs a new Item.
         * @memberof bag
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {bag.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item id.
         * @member {number} id
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.id = 0;

        /**
         * Item uid.
         * @member {number} uid
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.uid = 0;

        /**
         * Item num.
         * @member {number} num
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.num = 0;

        /**
         * Item expireTs.
         * @member {number} expireTs
         * @memberof bag.Item
         * @instance
         */
        Item.prototype.expireTs = 0;

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof bag.Item
         * @static
         * @param {bag.IItem=} [properties] Properties to set
         * @returns {bag.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link bag.Item.verify|verify} messages.
         * @function encode
         * @memberof bag.Item
         * @static
         * @param {bag.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.uid);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num);
            if (message.expireTs != null && Object.hasOwnProperty.call(message, "expireTs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expireTs);
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link bag.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.Item
         * @static
         * @param {bag.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.Item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.uid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.num = reader.uint32();
                        break;
                    }
                case 4: {
                        message.expireTs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof bag.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.expireTs != null && message.hasOwnProperty("expireTs"))
                if (!$util.isInteger(message.expireTs))
                    return "expireTs: integer expected";
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.Item)
                return object;
            var message = new $root.bag.Item();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.expireTs != null)
                message.expireTs = object.expireTs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.Item
         * @static
         * @param {bag.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.uid = 0;
                object.num = 0;
                object.expireTs = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.expireTs != null && message.hasOwnProperty("expireTs"))
                object.expireTs = message.expireTs;
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof bag.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Item
         * @function getTypeUrl
         * @memberof bag.Item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.Item";
        };

        return Item;
    })();

    bag.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof bag
         * @interface Ic2s_load
         * @property {number|null} [bagId] c2s_load bagId
         */

        /**
         * Constructs a new c2s_load.
         * @memberof bag
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {bag.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load bagId.
         * @member {number} bagId
         * @memberof bag.c2s_load
         * @instance
         */
        c2s_load.prototype.bagId = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof bag.c2s_load
         * @static
         * @param {bag.Ic2s_load=} [properties] Properties to set
         * @returns {bag.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link bag.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_load
         * @static
         * @param {bag.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bagId != null && Object.hasOwnProperty.call(message, "bagId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bagId);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link bag.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_load
         * @static
         * @param {bag.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bagId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof bag.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bagId != null && message.hasOwnProperty("bagId"))
                if (!$util.isInteger(message.bagId))
                    return "bagId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_load)
                return object;
            var message = new $root.bag.c2s_load();
            if (object.bagId != null)
                message.bagId = object.bagId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_load
         * @static
         * @param {bag.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bagId = 0;
            if (message.bagId != null && message.hasOwnProperty("bagId"))
                object.bagId = message.bagId;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof bag.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof bag.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_load";
        };

        return c2s_load;
    })();

    bag.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof bag
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<bag.IItem>|null} [items] s2c_load items
         */

        /**
         * Constructs a new s2c_load.
         * @memberof bag
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {bag.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof bag.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load items.
         * @member {Array.<bag.IItem>} items
         * @memberof bag.s2c_load
         * @instance
         */
        s2c_load.prototype.items = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof bag.s2c_load
         * @static
         * @param {bag.Is2c_load=} [properties] Properties to set
         * @returns {bag.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link bag.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_load
         * @static
         * @param {bag.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.bag.Item.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link bag.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_load
         * @static
         * @param {bag.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof bag.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.bag.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_load)
                return object;
            var message = new $root.bag.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".bag.s2c_load.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".bag.s2c_load.items: object expected");
                    message.items[i] = $root.bag.Item.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_load
         * @static
         * @param {bag.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.bag.Item.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof bag.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof bag.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_load";
        };

        return s2c_load;
    })();

    bag.c2s_use_item = (function() {

        /**
         * Properties of a c2s_use_item.
         * @memberof bag
         * @interface Ic2s_use_item
         * @property {number|null} [itemId] c2s_use_item itemId
         * @property {number|null} [num] c2s_use_item num
         */

        /**
         * Constructs a new c2s_use_item.
         * @memberof bag
         * @classdesc Represents a c2s_use_item.
         * @implements Ic2s_use_item
         * @constructor
         * @param {bag.Ic2s_use_item=} [properties] Properties to set
         */
        function c2s_use_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_use_item itemId.
         * @member {number} itemId
         * @memberof bag.c2s_use_item
         * @instance
         */
        c2s_use_item.prototype.itemId = 0;

        /**
         * c2s_use_item num.
         * @member {number} num
         * @memberof bag.c2s_use_item
         * @instance
         */
        c2s_use_item.prototype.num = 0;

        /**
         * Creates a new c2s_use_item instance using the specified properties.
         * @function create
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.Ic2s_use_item=} [properties] Properties to set
         * @returns {bag.c2s_use_item} c2s_use_item instance
         */
        c2s_use_item.create = function create(properties) {
            return new c2s_use_item(properties);
        };

        /**
         * Encodes the specified c2s_use_item message. Does not implicitly {@link bag.c2s_use_item.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.Ic2s_use_item} message c2s_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_use_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified c2s_use_item message, length delimited. Does not implicitly {@link bag.c2s_use_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.Ic2s_use_item} message c2s_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_use_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_use_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_use_item} c2s_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_use_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_use_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_use_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_use_item} c2s_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_use_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_use_item message.
         * @function verify
         * @memberof bag.c2s_use_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_use_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a c2s_use_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_use_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_use_item} c2s_use_item
         */
        c2s_use_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_use_item)
                return object;
            var message = new $root.bag.c2s_use_item();
            if (object.itemId != null)
                message.itemId = object.itemId >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_use_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_use_item
         * @static
         * @param {bag.c2s_use_item} message c2s_use_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_use_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.num = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this c2s_use_item to JSON.
         * @function toJSON
         * @memberof bag.c2s_use_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_use_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_use_item
         * @function getTypeUrl
         * @memberof bag.c2s_use_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_use_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_use_item";
        };

        return c2s_use_item;
    })();

    bag.s2c_use_item = (function() {

        /**
         * Properties of a s2c_use_item.
         * @memberof bag
         * @interface Is2c_use_item
         * @property {number|null} [err] s2c_use_item err
         */

        /**
         * Constructs a new s2c_use_item.
         * @memberof bag
         * @classdesc Represents a s2c_use_item.
         * @implements Is2c_use_item
         * @constructor
         * @param {bag.Is2c_use_item=} [properties] Properties to set
         */
        function s2c_use_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_use_item err.
         * @member {number} err
         * @memberof bag.s2c_use_item
         * @instance
         */
        s2c_use_item.prototype.err = 0;

        /**
         * Creates a new s2c_use_item instance using the specified properties.
         * @function create
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.Is2c_use_item=} [properties] Properties to set
         * @returns {bag.s2c_use_item} s2c_use_item instance
         */
        s2c_use_item.create = function create(properties) {
            return new s2c_use_item(properties);
        };

        /**
         * Encodes the specified s2c_use_item message. Does not implicitly {@link bag.s2c_use_item.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.Is2c_use_item} message s2c_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_use_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_use_item message, length delimited. Does not implicitly {@link bag.s2c_use_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.Is2c_use_item} message s2c_use_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_use_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_use_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_use_item} s2c_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_use_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_use_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_use_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_use_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_use_item} s2c_use_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_use_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_use_item message.
         * @function verify
         * @memberof bag.s2c_use_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_use_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_use_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_use_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_use_item} s2c_use_item
         */
        s2c_use_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_use_item)
                return object;
            var message = new $root.bag.s2c_use_item();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_use_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_use_item
         * @static
         * @param {bag.s2c_use_item} message s2c_use_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_use_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_use_item to JSON.
         * @function toJSON
         * @memberof bag.s2c_use_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_use_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_use_item
         * @function getTypeUrl
         * @memberof bag.s2c_use_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_use_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_use_item";
        };

        return s2c_use_item;
    })();

    bag.c2s_composite_item = (function() {

        /**
         * Properties of a c2s_composite_item.
         * @memberof bag
         * @interface Ic2s_composite_item
         * @property {number|null} [itemId] c2s_composite_item itemId
         * @property {number|null} [num] c2s_composite_item num
         */

        /**
         * Constructs a new c2s_composite_item.
         * @memberof bag
         * @classdesc Represents a c2s_composite_item.
         * @implements Ic2s_composite_item
         * @constructor
         * @param {bag.Ic2s_composite_item=} [properties] Properties to set
         */
        function c2s_composite_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_composite_item itemId.
         * @member {number} itemId
         * @memberof bag.c2s_composite_item
         * @instance
         */
        c2s_composite_item.prototype.itemId = 0;

        /**
         * c2s_composite_item num.
         * @member {number} num
         * @memberof bag.c2s_composite_item
         * @instance
         */
        c2s_composite_item.prototype.num = 0;

        /**
         * Creates a new c2s_composite_item instance using the specified properties.
         * @function create
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.Ic2s_composite_item=} [properties] Properties to set
         * @returns {bag.c2s_composite_item} c2s_composite_item instance
         */
        c2s_composite_item.create = function create(properties) {
            return new c2s_composite_item(properties);
        };

        /**
         * Encodes the specified c2s_composite_item message. Does not implicitly {@link bag.c2s_composite_item.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.Ic2s_composite_item} message c2s_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_composite_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified c2s_composite_item message, length delimited. Does not implicitly {@link bag.c2s_composite_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.Ic2s_composite_item} message c2s_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_composite_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_composite_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_composite_item} c2s_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_composite_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_composite_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_composite_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_composite_item} c2s_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_composite_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_composite_item message.
         * @function verify
         * @memberof bag.c2s_composite_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_composite_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a c2s_composite_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_composite_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_composite_item} c2s_composite_item
         */
        c2s_composite_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_composite_item)
                return object;
            var message = new $root.bag.c2s_composite_item();
            if (object.itemId != null)
                message.itemId = object.itemId >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_composite_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_composite_item
         * @static
         * @param {bag.c2s_composite_item} message c2s_composite_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_composite_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.num = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this c2s_composite_item to JSON.
         * @function toJSON
         * @memberof bag.c2s_composite_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_composite_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_composite_item
         * @function getTypeUrl
         * @memberof bag.c2s_composite_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_composite_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_composite_item";
        };

        return c2s_composite_item;
    })();

    bag.s2c_composite_item = (function() {

        /**
         * Properties of a s2c_composite_item.
         * @memberof bag
         * @interface Is2c_composite_item
         * @property {number|null} [err] s2c_composite_item err
         */

        /**
         * Constructs a new s2c_composite_item.
         * @memberof bag
         * @classdesc Represents a s2c_composite_item.
         * @implements Is2c_composite_item
         * @constructor
         * @param {bag.Is2c_composite_item=} [properties] Properties to set
         */
        function s2c_composite_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_composite_item err.
         * @member {number} err
         * @memberof bag.s2c_composite_item
         * @instance
         */
        s2c_composite_item.prototype.err = 0;

        /**
         * Creates a new s2c_composite_item instance using the specified properties.
         * @function create
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.Is2c_composite_item=} [properties] Properties to set
         * @returns {bag.s2c_composite_item} s2c_composite_item instance
         */
        s2c_composite_item.create = function create(properties) {
            return new s2c_composite_item(properties);
        };

        /**
         * Encodes the specified s2c_composite_item message. Does not implicitly {@link bag.s2c_composite_item.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.Is2c_composite_item} message s2c_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_composite_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_composite_item message, length delimited. Does not implicitly {@link bag.s2c_composite_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.Is2c_composite_item} message s2c_composite_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_composite_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_composite_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_composite_item} s2c_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_composite_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_composite_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_composite_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_composite_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_composite_item} s2c_composite_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_composite_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_composite_item message.
         * @function verify
         * @memberof bag.s2c_composite_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_composite_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_composite_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_composite_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_composite_item} s2c_composite_item
         */
        s2c_composite_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_composite_item)
                return object;
            var message = new $root.bag.s2c_composite_item();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_composite_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_composite_item
         * @static
         * @param {bag.s2c_composite_item} message s2c_composite_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_composite_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_composite_item to JSON.
         * @function toJSON
         * @memberof bag.s2c_composite_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_composite_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_composite_item
         * @function getTypeUrl
         * @memberof bag.s2c_composite_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_composite_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_composite_item";
        };

        return s2c_composite_item;
    })();

    bag.c2s_discard_item = (function() {

        /**
         * Properties of a c2s_discard_item.
         * @memberof bag
         * @interface Ic2s_discard_item
         * @property {number|null} [itemId] c2s_discard_item itemId
         * @property {number|null} [itemUid] c2s_discard_item itemUid
         */

        /**
         * Constructs a new c2s_discard_item.
         * @memberof bag
         * @classdesc Represents a c2s_discard_item.
         * @implements Ic2s_discard_item
         * @constructor
         * @param {bag.Ic2s_discard_item=} [properties] Properties to set
         */
        function c2s_discard_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_discard_item itemId.
         * @member {number} itemId
         * @memberof bag.c2s_discard_item
         * @instance
         */
        c2s_discard_item.prototype.itemId = 0;

        /**
         * c2s_discard_item itemUid.
         * @member {number} itemUid
         * @memberof bag.c2s_discard_item
         * @instance
         */
        c2s_discard_item.prototype.itemUid = 0;

        /**
         * Creates a new c2s_discard_item instance using the specified properties.
         * @function create
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.Ic2s_discard_item=} [properties] Properties to set
         * @returns {bag.c2s_discard_item} c2s_discard_item instance
         */
        c2s_discard_item.create = function create(properties) {
            return new c2s_discard_item(properties);
        };

        /**
         * Encodes the specified c2s_discard_item message. Does not implicitly {@link bag.c2s_discard_item.verify|verify} messages.
         * @function encode
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.Ic2s_discard_item} message c2s_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_discard_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemId);
            if (message.itemUid != null && Object.hasOwnProperty.call(message, "itemUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.itemUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_discard_item message, length delimited. Does not implicitly {@link bag.c2s_discard_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.Ic2s_discard_item} message c2s_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_discard_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_discard_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.c2s_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.c2s_discard_item} c2s_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_discard_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.c2s_discard_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.itemId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.itemUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_discard_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.c2s_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.c2s_discard_item} c2s_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_discard_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_discard_item message.
         * @function verify
         * @memberof bag.c2s_discard_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_discard_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.itemUid != null && message.hasOwnProperty("itemUid"))
                if (!$util.isInteger(message.itemUid))
                    return "itemUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_discard_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.c2s_discard_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.c2s_discard_item} c2s_discard_item
         */
        c2s_discard_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.c2s_discard_item)
                return object;
            var message = new $root.bag.c2s_discard_item();
            if (object.itemId != null)
                message.itemId = object.itemId >>> 0;
            if (object.itemUid != null)
                message.itemUid = object.itemUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_discard_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.c2s_discard_item
         * @static
         * @param {bag.c2s_discard_item} message c2s_discard_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_discard_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.itemUid = 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.itemUid != null && message.hasOwnProperty("itemUid"))
                object.itemUid = message.itemUid;
            return object;
        };

        /**
         * Converts this c2s_discard_item to JSON.
         * @function toJSON
         * @memberof bag.c2s_discard_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_discard_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_discard_item
         * @function getTypeUrl
         * @memberof bag.c2s_discard_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_discard_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.c2s_discard_item";
        };

        return c2s_discard_item;
    })();

    bag.s2c_discard_item = (function() {

        /**
         * Properties of a s2c_discard_item.
         * @memberof bag
         * @interface Is2c_discard_item
         * @property {number|null} [err] s2c_discard_item err
         */

        /**
         * Constructs a new s2c_discard_item.
         * @memberof bag
         * @classdesc Represents a s2c_discard_item.
         * @implements Is2c_discard_item
         * @constructor
         * @param {bag.Is2c_discard_item=} [properties] Properties to set
         */
        function s2c_discard_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_discard_item err.
         * @member {number} err
         * @memberof bag.s2c_discard_item
         * @instance
         */
        s2c_discard_item.prototype.err = 0;

        /**
         * Creates a new s2c_discard_item instance using the specified properties.
         * @function create
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.Is2c_discard_item=} [properties] Properties to set
         * @returns {bag.s2c_discard_item} s2c_discard_item instance
         */
        s2c_discard_item.create = function create(properties) {
            return new s2c_discard_item(properties);
        };

        /**
         * Encodes the specified s2c_discard_item message. Does not implicitly {@link bag.s2c_discard_item.verify|verify} messages.
         * @function encode
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.Is2c_discard_item} message s2c_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_discard_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_discard_item message, length delimited. Does not implicitly {@link bag.s2c_discard_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.Is2c_discard_item} message s2c_discard_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_discard_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_discard_item message from the specified reader or buffer.
         * @function decode
         * @memberof bag.s2c_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.s2c_discard_item} s2c_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_discard_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.s2c_discard_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_discard_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.s2c_discard_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.s2c_discard_item} s2c_discard_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_discard_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_discard_item message.
         * @function verify
         * @memberof bag.s2c_discard_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_discard_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_discard_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.s2c_discard_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.s2c_discard_item} s2c_discard_item
         */
        s2c_discard_item.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.s2c_discard_item)
                return object;
            var message = new $root.bag.s2c_discard_item();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_discard_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.s2c_discard_item
         * @static
         * @param {bag.s2c_discard_item} message s2c_discard_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_discard_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_discard_item to JSON.
         * @function toJSON
         * @memberof bag.s2c_discard_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_discard_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_discard_item
         * @function getTypeUrl
         * @memberof bag.s2c_discard_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_discard_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.s2c_discard_item";
        };

        return s2c_discard_item;
    })();

    bag.notify_items = (function() {

        /**
         * Properties of a notify_items.
         * @memberof bag
         * @interface Inotify_items
         * @property {Array.<bag.IItem>|null} [items] notify_items items
         */

        /**
         * Constructs a new notify_items.
         * @memberof bag
         * @classdesc Represents a notify_items.
         * @implements Inotify_items
         * @constructor
         * @param {bag.Inotify_items=} [properties] Properties to set
         */
        function notify_items(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_items items.
         * @member {Array.<bag.IItem>} items
         * @memberof bag.notify_items
         * @instance
         */
        notify_items.prototype.items = $util.emptyArray;

        /**
         * Creates a new notify_items instance using the specified properties.
         * @function create
         * @memberof bag.notify_items
         * @static
         * @param {bag.Inotify_items=} [properties] Properties to set
         * @returns {bag.notify_items} notify_items instance
         */
        notify_items.create = function create(properties) {
            return new notify_items(properties);
        };

        /**
         * Encodes the specified notify_items message. Does not implicitly {@link bag.notify_items.verify|verify} messages.
         * @function encode
         * @memberof bag.notify_items
         * @static
         * @param {bag.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.bag.Item.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_items message, length delimited. Does not implicitly {@link bag.notify_items.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bag.notify_items
         * @static
         * @param {bag.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer.
         * @function decode
         * @memberof bag.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bag.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bag.notify_items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bag.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bag.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_items message.
         * @function verify
         * @memberof bag.notify_items
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.bag.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_items message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bag.notify_items
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bag.notify_items} notify_items
         */
        notify_items.fromObject = function fromObject(object) {
            if (object instanceof $root.bag.notify_items)
                return object;
            var message = new $root.bag.notify_items();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".bag.notify_items.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".bag.notify_items.items: object expected");
                    message.items[i] = $root.bag.Item.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_items message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bag.notify_items
         * @static
         * @param {bag.notify_items} message notify_items
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.bag.Item.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_items to JSON.
         * @function toJSON
         * @memberof bag.notify_items
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_items
         * @function getTypeUrl
         * @memberof bag.notify_items
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/bag.notify_items";
        };

        return notify_items;
    })();

    return bag;
})();

$root.battle = (function() {

    /**
     * Namespace battle.
     * @exports battle
     * @namespace
     */
    var battle = {};

    battle.BattleHero = (function() {

        /**
         * Properties of a BattleHero.
         * @memberof battle
         * @interface IBattleHero
         * @property {number|null} [heroId] BattleHero heroId
         * @property {number|null} [eid] BattleHero eid
         */

        /**
         * Constructs a new BattleHero.
         * @memberof battle
         * @classdesc Represents a BattleHero.
         * @implements IBattleHero
         * @constructor
         * @param {battle.IBattleHero=} [properties] Properties to set
         */
        function BattleHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleHero heroId.
         * @member {number} heroId
         * @memberof battle.BattleHero
         * @instance
         */
        BattleHero.prototype.heroId = 0;

        /**
         * BattleHero eid.
         * @member {number} eid
         * @memberof battle.BattleHero
         * @instance
         */
        BattleHero.prototype.eid = 0;

        /**
         * Creates a new BattleHero instance using the specified properties.
         * @function create
         * @memberof battle.BattleHero
         * @static
         * @param {battle.IBattleHero=} [properties] Properties to set
         * @returns {battle.BattleHero} BattleHero instance
         */
        BattleHero.create = function create(properties) {
            return new BattleHero(properties);
        };

        /**
         * Encodes the specified BattleHero message. Does not implicitly {@link battle.BattleHero.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleHero
         * @static
         * @param {battle.IBattleHero} message BattleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.heroId);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified BattleHero message, length delimited. Does not implicitly {@link battle.BattleHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleHero
         * @static
         * @param {battle.IBattleHero} message BattleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleHero message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleHero} BattleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.heroId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleHero} BattleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleHero message.
         * @function verify
         * @memberof battle.BattleHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a BattleHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleHero} BattleHero
         */
        BattleHero.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleHero)
                return object;
            var message = new $root.battle.BattleHero();
            if (object.heroId != null)
                message.heroId = object.heroId >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BattleHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleHero
         * @static
         * @param {battle.BattleHero} message BattleHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleHero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroId = 0;
                object.eid = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this BattleHero to JSON.
         * @function toJSON
         * @memberof battle.BattleHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleHero
         * @function getTypeUrl
         * @memberof battle.BattleHero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleHero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleHero";
        };

        return BattleHero;
    })();

    battle.BattleRole = (function() {

        /**
         * Properties of a BattleRole.
         * @memberof battle
         * @interface IBattleRole
         * @property {number|null} [rid] BattleRole rid
         * @property {string|null} [name] BattleRole name
         * @property {Array.<battle.IBattleHero>|null} [heros] BattleRole heros
         */

        /**
         * Constructs a new BattleRole.
         * @memberof battle
         * @classdesc Represents a BattleRole.
         * @implements IBattleRole
         * @constructor
         * @param {battle.IBattleRole=} [properties] Properties to set
         */
        function BattleRole(properties) {
            this.heros = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleRole rid.
         * @member {number} rid
         * @memberof battle.BattleRole
         * @instance
         */
        BattleRole.prototype.rid = 0;

        /**
         * BattleRole name.
         * @member {string} name
         * @memberof battle.BattleRole
         * @instance
         */
        BattleRole.prototype.name = "";

        /**
         * BattleRole heros.
         * @member {Array.<battle.IBattleHero>} heros
         * @memberof battle.BattleRole
         * @instance
         */
        BattleRole.prototype.heros = $util.emptyArray;

        /**
         * Creates a new BattleRole instance using the specified properties.
         * @function create
         * @memberof battle.BattleRole
         * @static
         * @param {battle.IBattleRole=} [properties] Properties to set
         * @returns {battle.BattleRole} BattleRole instance
         */
        BattleRole.create = function create(properties) {
            return new BattleRole(properties);
        };

        /**
         * Encodes the specified BattleRole message. Does not implicitly {@link battle.BattleRole.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleRole
         * @static
         * @param {battle.IBattleRole} message BattleRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleRole.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.heros != null && message.heros.length)
                for (var i = 0; i < message.heros.length; ++i)
                    $root.battle.BattleHero.encode(message.heros[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BattleRole message, length delimited. Does not implicitly {@link battle.BattleRole.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleRole
         * @static
         * @param {battle.IBattleRole} message BattleRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleRole.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleRole message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleRole} BattleRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleRole.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleRole();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.heros && message.heros.length))
                            message.heros = [];
                        message.heros.push($root.battle.BattleHero.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleRole message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleRole} BattleRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleRole.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleRole message.
         * @function verify
         * @memberof battle.BattleRole
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleRole.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.heros != null && message.hasOwnProperty("heros")) {
                if (!Array.isArray(message.heros))
                    return "heros: array expected";
                for (var i = 0; i < message.heros.length; ++i) {
                    var error = $root.battle.BattleHero.verify(message.heros[i]);
                    if (error)
                        return "heros." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BattleRole message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleRole
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleRole} BattleRole
         */
        BattleRole.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleRole)
                return object;
            var message = new $root.battle.BattleRole();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.heros) {
                if (!Array.isArray(object.heros))
                    throw TypeError(".battle.BattleRole.heros: array expected");
                message.heros = [];
                for (var i = 0; i < object.heros.length; ++i) {
                    if (typeof object.heros[i] !== "object")
                        throw TypeError(".battle.BattleRole.heros: object expected");
                    message.heros[i] = $root.battle.BattleHero.fromObject(object.heros[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BattleRole message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleRole
         * @static
         * @param {battle.BattleRole} message BattleRole
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleRole.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heros = [];
            if (options.defaults) {
                object.rid = 0;
                object.name = "";
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.heros && message.heros.length) {
                object.heros = [];
                for (var j = 0; j < message.heros.length; ++j)
                    object.heros[j] = $root.battle.BattleHero.toObject(message.heros[j], options);
            }
            return object;
        };

        /**
         * Converts this BattleRole to JSON.
         * @function toJSON
         * @memberof battle.BattleRole
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleRole.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleRole
         * @function getTypeUrl
         * @memberof battle.BattleRole
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleRole.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleRole";
        };

        return BattleRole;
    })();

    battle.BattleEntity = (function() {

        /**
         * Properties of a BattleEntity.
         * @memberof battle
         * @interface IBattleEntity
         * @property {number|null} [eid] BattleEntity eid
         * @property {number|null} [rid] BattleEntity rid
         * @property {number|null} [entityId] BattleEntity entityId
         * @property {number|null} [maxHp] BattleEntity maxHp
         * @property {number|null} [hp] BattleEntity hp
         * @property {number|null} [x] BattleEntity x
         * @property {number|null} [y] BattleEntity y
         * @property {number|null} [z] BattleEntity z
         * @property {number|null} [maxMp] BattleEntity maxMp
         * @property {number|null} [mp] BattleEntity mp
         */

        /**
         * Constructs a new BattleEntity.
         * @memberof battle
         * @classdesc Represents a BattleEntity.
         * @implements IBattleEntity
         * @constructor
         * @param {battle.IBattleEntity=} [properties] Properties to set
         */
        function BattleEntity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleEntity eid.
         * @member {number} eid
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.eid = 0;

        /**
         * BattleEntity rid.
         * @member {number} rid
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.rid = 0;

        /**
         * BattleEntity entityId.
         * @member {number} entityId
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.entityId = 0;

        /**
         * BattleEntity maxHp.
         * @member {number} maxHp
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.maxHp = 0;

        /**
         * BattleEntity hp.
         * @member {number} hp
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.hp = 0;

        /**
         * BattleEntity x.
         * @member {number} x
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.x = 0;

        /**
         * BattleEntity y.
         * @member {number} y
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.y = 0;

        /**
         * BattleEntity z.
         * @member {number} z
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.z = 0;

        /**
         * BattleEntity maxMp.
         * @member {number} maxMp
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.maxMp = 0;

        /**
         * BattleEntity mp.
         * @member {number} mp
         * @memberof battle.BattleEntity
         * @instance
         */
        BattleEntity.prototype.mp = 0;

        /**
         * Creates a new BattleEntity instance using the specified properties.
         * @function create
         * @memberof battle.BattleEntity
         * @static
         * @param {battle.IBattleEntity=} [properties] Properties to set
         * @returns {battle.BattleEntity} BattleEntity instance
         */
        BattleEntity.create = function create(properties) {
            return new BattleEntity(properties);
        };

        /**
         * Encodes the specified BattleEntity message. Does not implicitly {@link battle.BattleEntity.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleEntity
         * @static
         * @param {battle.IBattleEntity} message BattleEntity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleEntity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.rid);
            if (message.entityId != null && Object.hasOwnProperty.call(message, "entityId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.entityId);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxHp);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.hp);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.z);
            if (message.maxMp != null && Object.hasOwnProperty.call(message, "maxMp"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.maxMp);
            if (message.mp != null && Object.hasOwnProperty.call(message, "mp"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.mp);
            return writer;
        };

        /**
         * Encodes the specified BattleEntity message, length delimited. Does not implicitly {@link battle.BattleEntity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleEntity
         * @static
         * @param {battle.IBattleEntity} message BattleEntity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleEntity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleEntity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleEntity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleEntity} BattleEntity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleEntity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleEntity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.entityId = reader.uint32();
                        break;
                    }
                case 5: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 6: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 10: {
                        message.x = reader.uint32();
                        break;
                    }
                case 11: {
                        message.y = reader.uint32();
                        break;
                    }
                case 12: {
                        message.z = reader.uint32();
                        break;
                    }
                case 13: {
                        message.maxMp = reader.uint32();
                        break;
                    }
                case 14: {
                        message.mp = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleEntity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleEntity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleEntity} BattleEntity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleEntity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleEntity message.
         * @function verify
         * @memberof battle.BattleEntity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleEntity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.entityId != null && message.hasOwnProperty("entityId"))
                if (!$util.isInteger(message.entityId))
                    return "entityId: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            if (message.maxMp != null && message.hasOwnProperty("maxMp"))
                if (!$util.isInteger(message.maxMp))
                    return "maxMp: integer expected";
            if (message.mp != null && message.hasOwnProperty("mp"))
                if (!$util.isInteger(message.mp))
                    return "mp: integer expected";
            return null;
        };

        /**
         * Creates a BattleEntity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleEntity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleEntity} BattleEntity
         */
        BattleEntity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleEntity)
                return object;
            var message = new $root.battle.BattleEntity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.entityId != null)
                message.entityId = object.entityId >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.x != null)
                message.x = object.x >>> 0;
            if (object.y != null)
                message.y = object.y >>> 0;
            if (object.z != null)
                message.z = object.z >>> 0;
            if (object.maxMp != null)
                message.maxMp = object.maxMp >>> 0;
            if (object.mp != null)
                message.mp = object.mp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BattleEntity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleEntity
         * @static
         * @param {battle.BattleEntity} message BattleEntity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleEntity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.rid = 0;
                object.entityId = 0;
                object.maxHp = 0;
                object.hp = 0;
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.maxMp = 0;
                object.mp = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.entityId != null && message.hasOwnProperty("entityId"))
                object.entityId = message.entityId;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            if (message.maxMp != null && message.hasOwnProperty("maxMp"))
                object.maxMp = message.maxMp;
            if (message.mp != null && message.hasOwnProperty("mp"))
                object.mp = message.mp;
            return object;
        };

        /**
         * Converts this BattleEntity to JSON.
         * @function toJSON
         * @memberof battle.BattleEntity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleEntity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleEntity
         * @function getTypeUrl
         * @memberof battle.BattleEntity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleEntity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleEntity";
        };

        return BattleEntity;
    })();

    battle.cmd_add_entity = (function() {

        /**
         * Properties of a cmd_add_entity.
         * @memberof battle
         * @interface Icmd_add_entity
         * @property {battle.IBattleEntity|null} [entity] cmd_add_entity entity
         */

        /**
         * Constructs a new cmd_add_entity.
         * @memberof battle
         * @classdesc Represents a cmd_add_entity.
         * @implements Icmd_add_entity
         * @constructor
         * @param {battle.Icmd_add_entity=} [properties] Properties to set
         */
        function cmd_add_entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_add_entity entity.
         * @member {battle.IBattleEntity|null|undefined} entity
         * @memberof battle.cmd_add_entity
         * @instance
         */
        cmd_add_entity.prototype.entity = null;

        /**
         * Creates a new cmd_add_entity instance using the specified properties.
         * @function create
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.Icmd_add_entity=} [properties] Properties to set
         * @returns {battle.cmd_add_entity} cmd_add_entity instance
         */
        cmd_add_entity.create = function create(properties) {
            return new cmd_add_entity(properties);
        };

        /**
         * Encodes the specified cmd_add_entity message. Does not implicitly {@link battle.cmd_add_entity.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.Icmd_add_entity} message cmd_add_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                $root.battle.BattleEntity.encode(message.entity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified cmd_add_entity message, length delimited. Does not implicitly {@link battle.cmd_add_entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.Icmd_add_entity} message cmd_add_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_add_entity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_add_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_add_entity} cmd_add_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_add_entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entity = $root.battle.BattleEntity.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_add_entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_add_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_add_entity} cmd_add_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_add_entity message.
         * @function verify
         * @memberof battle.cmd_add_entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_add_entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity")) {
                var error = $root.battle.BattleEntity.verify(message.entity);
                if (error)
                    return "entity." + error;
            }
            return null;
        };

        /**
         * Creates a cmd_add_entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_add_entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_add_entity} cmd_add_entity
         */
        cmd_add_entity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_add_entity)
                return object;
            var message = new $root.battle.cmd_add_entity();
            if (object.entity != null) {
                if (typeof object.entity !== "object")
                    throw TypeError(".battle.cmd_add_entity.entity: object expected");
                message.entity = $root.battle.BattleEntity.fromObject(object.entity);
            }
            return message;
        };

        /**
         * Creates a plain object from a cmd_add_entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_add_entity
         * @static
         * @param {battle.cmd_add_entity} message cmd_add_entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_add_entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.entity = null;
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = $root.battle.BattleEntity.toObject(message.entity, options);
            return object;
        };

        /**
         * Converts this cmd_add_entity to JSON.
         * @function toJSON
         * @memberof battle.cmd_add_entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_add_entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_add_entity
         * @function getTypeUrl
         * @memberof battle.cmd_add_entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_add_entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_add_entity";
        };

        return cmd_add_entity;
    })();

    battle.cmd_update_entity = (function() {

        /**
         * Properties of a cmd_update_entity.
         * @memberof battle
         * @interface Icmd_update_entity
         * @property {number|null} [eid] cmd_update_entity eid
         * @property {number|null} [maxHp] cmd_update_entity maxHp
         * @property {number|null} [hp] cmd_update_entity hp
         * @property {number|null} [x] cmd_update_entity x
         * @property {number|null} [y] cmd_update_entity y
         * @property {number|null} [z] cmd_update_entity z
         */

        /**
         * Constructs a new cmd_update_entity.
         * @memberof battle
         * @classdesc Represents a cmd_update_entity.
         * @implements Icmd_update_entity
         * @constructor
         * @param {battle.Icmd_update_entity=} [properties] Properties to set
         */
        function cmd_update_entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_update_entity eid.
         * @member {number} eid
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.eid = 0;

        /**
         * cmd_update_entity maxHp.
         * @member {number} maxHp
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.maxHp = 0;

        /**
         * cmd_update_entity hp.
         * @member {number} hp
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.hp = 0;

        /**
         * cmd_update_entity x.
         * @member {number} x
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.x = 0;

        /**
         * cmd_update_entity y.
         * @member {number} y
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.y = 0;

        /**
         * cmd_update_entity z.
         * @member {number} z
         * @memberof battle.cmd_update_entity
         * @instance
         */
        cmd_update_entity.prototype.z = 0;

        /**
         * Creates a new cmd_update_entity instance using the specified properties.
         * @function create
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.Icmd_update_entity=} [properties] Properties to set
         * @returns {battle.cmd_update_entity} cmd_update_entity instance
         */
        cmd_update_entity.create = function create(properties) {
            return new cmd_update_entity(properties);
        };

        /**
         * Encodes the specified cmd_update_entity message. Does not implicitly {@link battle.cmd_update_entity.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.Icmd_update_entity} message cmd_update_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_update_entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxHp);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hp);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.z);
            return writer;
        };

        /**
         * Encodes the specified cmd_update_entity message, length delimited. Does not implicitly {@link battle.cmd_update_entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.Icmd_update_entity} message cmd_update_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_update_entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_update_entity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_update_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_update_entity} cmd_update_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_update_entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_update_entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 5: {
                        message.x = reader.uint32();
                        break;
                    }
                case 6: {
                        message.y = reader.uint32();
                        break;
                    }
                case 7: {
                        message.z = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_update_entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_update_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_update_entity} cmd_update_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_update_entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_update_entity message.
         * @function verify
         * @memberof battle.cmd_update_entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_update_entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            return null;
        };

        /**
         * Creates a cmd_update_entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_update_entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_update_entity} cmd_update_entity
         */
        cmd_update_entity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_update_entity)
                return object;
            var message = new $root.battle.cmd_update_entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.x != null)
                message.x = object.x >>> 0;
            if (object.y != null)
                message.y = object.y >>> 0;
            if (object.z != null)
                message.z = object.z >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_update_entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_update_entity
         * @static
         * @param {battle.cmd_update_entity} message cmd_update_entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_update_entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.maxHp = 0;
                object.hp = 0;
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            return object;
        };

        /**
         * Converts this cmd_update_entity to JSON.
         * @function toJSON
         * @memberof battle.cmd_update_entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_update_entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_update_entity
         * @function getTypeUrl
         * @memberof battle.cmd_update_entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_update_entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_update_entity";
        };

        return cmd_update_entity;
    })();

    battle.cmd_del_entity = (function() {

        /**
         * Properties of a cmd_del_entity.
         * @memberof battle
         * @interface Icmd_del_entity
         * @property {number|null} [eid] cmd_del_entity eid
         */

        /**
         * Constructs a new cmd_del_entity.
         * @memberof battle
         * @classdesc Represents a cmd_del_entity.
         * @implements Icmd_del_entity
         * @constructor
         * @param {battle.Icmd_del_entity=} [properties] Properties to set
         */
        function cmd_del_entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_del_entity eid.
         * @member {number} eid
         * @memberof battle.cmd_del_entity
         * @instance
         */
        cmd_del_entity.prototype.eid = 0;

        /**
         * Creates a new cmd_del_entity instance using the specified properties.
         * @function create
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.Icmd_del_entity=} [properties] Properties to set
         * @returns {battle.cmd_del_entity} cmd_del_entity instance
         */
        cmd_del_entity.create = function create(properties) {
            return new cmd_del_entity(properties);
        };

        /**
         * Encodes the specified cmd_del_entity message. Does not implicitly {@link battle.cmd_del_entity.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.Icmd_del_entity} message cmd_del_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified cmd_del_entity message, length delimited. Does not implicitly {@link battle.cmd_del_entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.Icmd_del_entity} message cmd_del_entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_del_entity message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_del_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_del_entity} cmd_del_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_del_entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_del_entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_del_entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_del_entity} cmd_del_entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_del_entity message.
         * @function verify
         * @memberof battle.cmd_del_entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_del_entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a cmd_del_entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_del_entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_del_entity} cmd_del_entity
         */
        cmd_del_entity.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_del_entity)
                return object;
            var message = new $root.battle.cmd_del_entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_del_entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_del_entity
         * @static
         * @param {battle.cmd_del_entity} message cmd_del_entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_del_entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this cmd_del_entity to JSON.
         * @function toJSON
         * @memberof battle.cmd_del_entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_del_entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_del_entity
         * @function getTypeUrl
         * @memberof battle.cmd_del_entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_del_entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_del_entity";
        };

        return cmd_del_entity;
    })();

    battle.cmd_move_to = (function() {

        /**
         * Properties of a cmd_move_to.
         * @memberof battle
         * @interface Icmd_move_to
         * @property {number|null} [eid] cmd_move_to eid
         * @property {number|null} [speed] cmd_move_to speed
         * @property {number|null} [targetX] cmd_move_to targetX
         * @property {number|null} [targetY] cmd_move_to targetY
         * @property {number|null} [targetZ] cmd_move_to targetZ
         */

        /**
         * Constructs a new cmd_move_to.
         * @memberof battle
         * @classdesc Represents a cmd_move_to.
         * @implements Icmd_move_to
         * @constructor
         * @param {battle.Icmd_move_to=} [properties] Properties to set
         */
        function cmd_move_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_move_to eid.
         * @member {number} eid
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.eid = 0;

        /**
         * cmd_move_to speed.
         * @member {number} speed
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.speed = 0;

        /**
         * cmd_move_to targetX.
         * @member {number} targetX
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.targetX = 0;

        /**
         * cmd_move_to targetY.
         * @member {number} targetY
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.targetY = 0;

        /**
         * cmd_move_to targetZ.
         * @member {number} targetZ
         * @memberof battle.cmd_move_to
         * @instance
         */
        cmd_move_to.prototype.targetZ = 0;

        /**
         * Creates a new cmd_move_to instance using the specified properties.
         * @function create
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.Icmd_move_to=} [properties] Properties to set
         * @returns {battle.cmd_move_to} cmd_move_to instance
         */
        cmd_move_to.create = function create(properties) {
            return new cmd_move_to(properties);
        };

        /**
         * Encodes the specified cmd_move_to message. Does not implicitly {@link battle.cmd_move_to.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.Icmd_move_to} message cmd_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.speed);
            if (message.targetX != null && Object.hasOwnProperty.call(message, "targetX"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.targetX);
            if (message.targetY != null && Object.hasOwnProperty.call(message, "targetY"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.targetY);
            if (message.targetZ != null && Object.hasOwnProperty.call(message, "targetZ"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.targetZ);
            return writer;
        };

        /**
         * Encodes the specified cmd_move_to message, length delimited. Does not implicitly {@link battle.cmd_move_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.Icmd_move_to} message cmd_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_move_to message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_move_to} cmd_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_move_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 10: {
                        message.targetX = reader.uint32();
                        break;
                    }
                case 11: {
                        message.targetY = reader.uint32();
                        break;
                    }
                case 12: {
                        message.targetZ = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_move_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_move_to} cmd_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_move_to message.
         * @function verify
         * @memberof battle.cmd_move_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_move_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.targetX != null && message.hasOwnProperty("targetX"))
                if (!$util.isInteger(message.targetX))
                    return "targetX: integer expected";
            if (message.targetY != null && message.hasOwnProperty("targetY"))
                if (!$util.isInteger(message.targetY))
                    return "targetY: integer expected";
            if (message.targetZ != null && message.hasOwnProperty("targetZ"))
                if (!$util.isInteger(message.targetZ))
                    return "targetZ: integer expected";
            return null;
        };

        /**
         * Creates a cmd_move_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_move_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_move_to} cmd_move_to
         */
        cmd_move_to.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_move_to)
                return object;
            var message = new $root.battle.cmd_move_to();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.targetX != null)
                message.targetX = object.targetX >>> 0;
            if (object.targetY != null)
                message.targetY = object.targetY >>> 0;
            if (object.targetZ != null)
                message.targetZ = object.targetZ >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_move_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_move_to
         * @static
         * @param {battle.cmd_move_to} message cmd_move_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_move_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.targetX = 0;
                object.targetY = 0;
                object.targetZ = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.targetX != null && message.hasOwnProperty("targetX"))
                object.targetX = message.targetX;
            if (message.targetY != null && message.hasOwnProperty("targetY"))
                object.targetY = message.targetY;
            if (message.targetZ != null && message.hasOwnProperty("targetZ"))
                object.targetZ = message.targetZ;
            return object;
        };

        /**
         * Converts this cmd_move_to to JSON.
         * @function toJSON
         * @memberof battle.cmd_move_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_move_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_move_to
         * @function getTypeUrl
         * @memberof battle.cmd_move_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_move_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_move_to";
        };

        return cmd_move_to;
    })();

    battle.cmd_force_to = (function() {

        /**
         * Properties of a cmd_force_to.
         * @memberof battle
         * @interface Icmd_force_to
         * @property {number|null} [eid] cmd_force_to eid
         * @property {number|null} [speed] cmd_force_to speed
         * @property {number|null} [targetX] cmd_force_to targetX
         * @property {number|null} [targetY] cmd_force_to targetY
         * @property {number|null} [targetZ] cmd_force_to targetZ
         */

        /**
         * Constructs a new cmd_force_to.
         * @memberof battle
         * @classdesc Represents a cmd_force_to.
         * @implements Icmd_force_to
         * @constructor
         * @param {battle.Icmd_force_to=} [properties] Properties to set
         */
        function cmd_force_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_force_to eid.
         * @member {number} eid
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.eid = 0;

        /**
         * cmd_force_to speed.
         * @member {number} speed
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.speed = 0;

        /**
         * cmd_force_to targetX.
         * @member {number} targetX
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.targetX = 0;

        /**
         * cmd_force_to targetY.
         * @member {number} targetY
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.targetY = 0;

        /**
         * cmd_force_to targetZ.
         * @member {number} targetZ
         * @memberof battle.cmd_force_to
         * @instance
         */
        cmd_force_to.prototype.targetZ = 0;

        /**
         * Creates a new cmd_force_to instance using the specified properties.
         * @function create
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.Icmd_force_to=} [properties] Properties to set
         * @returns {battle.cmd_force_to} cmd_force_to instance
         */
        cmd_force_to.create = function create(properties) {
            return new cmd_force_to(properties);
        };

        /**
         * Encodes the specified cmd_force_to message. Does not implicitly {@link battle.cmd_force_to.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.Icmd_force_to} message cmd_force_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_force_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.speed);
            if (message.targetX != null && Object.hasOwnProperty.call(message, "targetX"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.targetX);
            if (message.targetY != null && Object.hasOwnProperty.call(message, "targetY"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.targetY);
            if (message.targetZ != null && Object.hasOwnProperty.call(message, "targetZ"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.targetZ);
            return writer;
        };

        /**
         * Encodes the specified cmd_force_to message, length delimited. Does not implicitly {@link battle.cmd_force_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.Icmd_force_to} message cmd_force_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_force_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_force_to message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_force_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_force_to} cmd_force_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_force_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_force_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 10: {
                        message.targetX = reader.uint32();
                        break;
                    }
                case 11: {
                        message.targetY = reader.uint32();
                        break;
                    }
                case 12: {
                        message.targetZ = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_force_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_force_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_force_to} cmd_force_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_force_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_force_to message.
         * @function verify
         * @memberof battle.cmd_force_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_force_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.targetX != null && message.hasOwnProperty("targetX"))
                if (!$util.isInteger(message.targetX))
                    return "targetX: integer expected";
            if (message.targetY != null && message.hasOwnProperty("targetY"))
                if (!$util.isInteger(message.targetY))
                    return "targetY: integer expected";
            if (message.targetZ != null && message.hasOwnProperty("targetZ"))
                if (!$util.isInteger(message.targetZ))
                    return "targetZ: integer expected";
            return null;
        };

        /**
         * Creates a cmd_force_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_force_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_force_to} cmd_force_to
         */
        cmd_force_to.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_force_to)
                return object;
            var message = new $root.battle.cmd_force_to();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.targetX != null)
                message.targetX = object.targetX >>> 0;
            if (object.targetY != null)
                message.targetY = object.targetY >>> 0;
            if (object.targetZ != null)
                message.targetZ = object.targetZ >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_force_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_force_to
         * @static
         * @param {battle.cmd_force_to} message cmd_force_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_force_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.targetX = 0;
                object.targetY = 0;
                object.targetZ = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.targetX != null && message.hasOwnProperty("targetX"))
                object.targetX = message.targetX;
            if (message.targetY != null && message.hasOwnProperty("targetY"))
                object.targetY = message.targetY;
            if (message.targetZ != null && message.hasOwnProperty("targetZ"))
                object.targetZ = message.targetZ;
            return object;
        };

        /**
         * Converts this cmd_force_to to JSON.
         * @function toJSON
         * @memberof battle.cmd_force_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_force_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_force_to
         * @function getTypeUrl
         * @memberof battle.cmd_force_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_force_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_force_to";
        };

        return cmd_force_to;
    })();

    battle.cmd_move_start = (function() {

        /**
         * Properties of a cmd_move_start.
         * @memberof battle
         * @interface Icmd_move_start
         * @property {number|null} [eid] cmd_move_start eid
         * @property {number|null} [speed] cmd_move_start speed
         * @property {number|null} [dir] cmd_move_start dir
         */

        /**
         * Constructs a new cmd_move_start.
         * @memberof battle
         * @classdesc Represents a cmd_move_start.
         * @implements Icmd_move_start
         * @constructor
         * @param {battle.Icmd_move_start=} [properties] Properties to set
         */
        function cmd_move_start(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_move_start eid.
         * @member {number} eid
         * @memberof battle.cmd_move_start
         * @instance
         */
        cmd_move_start.prototype.eid = 0;

        /**
         * cmd_move_start speed.
         * @member {number} speed
         * @memberof battle.cmd_move_start
         * @instance
         */
        cmd_move_start.prototype.speed = 0;

        /**
         * cmd_move_start dir.
         * @member {number} dir
         * @memberof battle.cmd_move_start
         * @instance
         */
        cmd_move_start.prototype.dir = 0;

        /**
         * Creates a new cmd_move_start instance using the specified properties.
         * @function create
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.Icmd_move_start=} [properties] Properties to set
         * @returns {battle.cmd_move_start} cmd_move_start instance
         */
        cmd_move_start.create = function create(properties) {
            return new cmd_move_start(properties);
        };

        /**
         * Encodes the specified cmd_move_start message. Does not implicitly {@link battle.cmd_move_start.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.Icmd_move_start} message cmd_move_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_start.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.speed);
            if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dir);
            return writer;
        };

        /**
         * Encodes the specified cmd_move_start message, length delimited. Does not implicitly {@link battle.cmd_move_start.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.Icmd_move_start} message cmd_move_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_start.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_move_start message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_move_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_move_start} cmd_move_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_start.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_move_start();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 3: {
                        message.dir = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_move_start message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_move_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_move_start} cmd_move_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_start.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_move_start message.
         * @function verify
         * @memberof battle.cmd_move_start
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_move_start.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.dir != null && message.hasOwnProperty("dir"))
                if (!$util.isInteger(message.dir))
                    return "dir: integer expected";
            return null;
        };

        /**
         * Creates a cmd_move_start message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_move_start
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_move_start} cmd_move_start
         */
        cmd_move_start.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_move_start)
                return object;
            var message = new $root.battle.cmd_move_start();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.dir != null)
                message.dir = object.dir >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_move_start message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_move_start
         * @static
         * @param {battle.cmd_move_start} message cmd_move_start
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_move_start.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.dir = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.dir != null && message.hasOwnProperty("dir"))
                object.dir = message.dir;
            return object;
        };

        /**
         * Converts this cmd_move_start to JSON.
         * @function toJSON
         * @memberof battle.cmd_move_start
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_move_start.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_move_start
         * @function getTypeUrl
         * @memberof battle.cmd_move_start
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_move_start.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_move_start";
        };

        return cmd_move_start;
    })();

    battle.cmd_move_stop = (function() {

        /**
         * Properties of a cmd_move_stop.
         * @memberof battle
         * @interface Icmd_move_stop
         * @property {number|null} [eid] cmd_move_stop eid
         * @property {number|null} [face] cmd_move_stop face
         * @property {number|null} [x] cmd_move_stop x
         * @property {number|null} [y] cmd_move_stop y
         * @property {number|null} [z] cmd_move_stop z
         */

        /**
         * Constructs a new cmd_move_stop.
         * @memberof battle
         * @classdesc Represents a cmd_move_stop.
         * @implements Icmd_move_stop
         * @constructor
         * @param {battle.Icmd_move_stop=} [properties] Properties to set
         */
        function cmd_move_stop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_move_stop eid.
         * @member {number} eid
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.eid = 0;

        /**
         * cmd_move_stop face.
         * @member {number} face
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.face = 0;

        /**
         * cmd_move_stop x.
         * @member {number} x
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.x = 0;

        /**
         * cmd_move_stop y.
         * @member {number} y
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.y = 0;

        /**
         * cmd_move_stop z.
         * @member {number} z
         * @memberof battle.cmd_move_stop
         * @instance
         */
        cmd_move_stop.prototype.z = 0;

        /**
         * Creates a new cmd_move_stop instance using the specified properties.
         * @function create
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.Icmd_move_stop=} [properties] Properties to set
         * @returns {battle.cmd_move_stop} cmd_move_stop instance
         */
        cmd_move_stop.create = function create(properties) {
            return new cmd_move_stop(properties);
        };

        /**
         * Encodes the specified cmd_move_stop message. Does not implicitly {@link battle.cmd_move_stop.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.Icmd_move_stop} message cmd_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_stop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.face);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.z);
            return writer;
        };

        /**
         * Encodes the specified cmd_move_stop message, length delimited. Does not implicitly {@link battle.cmd_move_stop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.Icmd_move_stop} message cmd_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_move_stop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_move_stop message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_move_stop} cmd_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_stop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_move_stop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.face = reader.int32();
                        break;
                    }
                case 10: {
                        message.x = reader.uint32();
                        break;
                    }
                case 11: {
                        message.y = reader.uint32();
                        break;
                    }
                case 12: {
                        message.z = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_move_stop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_move_stop} cmd_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_move_stop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_move_stop message.
         * @function verify
         * @memberof battle.cmd_move_stop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_move_stop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.face != null && message.hasOwnProperty("face"))
                if (!$util.isInteger(message.face))
                    return "face: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            return null;
        };

        /**
         * Creates a cmd_move_stop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_move_stop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_move_stop} cmd_move_stop
         */
        cmd_move_stop.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_move_stop)
                return object;
            var message = new $root.battle.cmd_move_stop();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.face != null)
                message.face = object.face | 0;
            if (object.x != null)
                message.x = object.x >>> 0;
            if (object.y != null)
                message.y = object.y >>> 0;
            if (object.z != null)
                message.z = object.z >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_move_stop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_move_stop
         * @static
         * @param {battle.cmd_move_stop} message cmd_move_stop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_move_stop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.face = 0;
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.face != null && message.hasOwnProperty("face"))
                object.face = message.face;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            return object;
        };

        /**
         * Converts this cmd_move_stop to JSON.
         * @function toJSON
         * @memberof battle.cmd_move_stop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_move_stop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_move_stop
         * @function getTypeUrl
         * @memberof battle.cmd_move_stop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_move_stop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_move_stop";
        };

        return cmd_move_stop;
    })();

    battle.cmd_add_buff = (function() {

        /**
         * Properties of a cmd_add_buff.
         * @memberof battle
         * @interface Icmd_add_buff
         * @property {number|null} [eid] cmd_add_buff eid
         * @property {number|null} [id] cmd_add_buff id
         * @property {number|null} [stack] cmd_add_buff stack
         * @property {number|null} [expired] cmd_add_buff expired
         */

        /**
         * Constructs a new cmd_add_buff.
         * @memberof battle
         * @classdesc Represents a cmd_add_buff.
         * @implements Icmd_add_buff
         * @constructor
         * @param {battle.Icmd_add_buff=} [properties] Properties to set
         */
        function cmd_add_buff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_add_buff eid.
         * @member {number} eid
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.eid = 0;

        /**
         * cmd_add_buff id.
         * @member {number} id
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.id = 0;

        /**
         * cmd_add_buff stack.
         * @member {number} stack
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.stack = 0;

        /**
         * cmd_add_buff expired.
         * @member {number} expired
         * @memberof battle.cmd_add_buff
         * @instance
         */
        cmd_add_buff.prototype.expired = 0;

        /**
         * Creates a new cmd_add_buff instance using the specified properties.
         * @function create
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.Icmd_add_buff=} [properties] Properties to set
         * @returns {battle.cmd_add_buff} cmd_add_buff instance
         */
        cmd_add_buff.create = function create(properties) {
            return new cmd_add_buff(properties);
        };

        /**
         * Encodes the specified cmd_add_buff message. Does not implicitly {@link battle.cmd_add_buff.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.Icmd_add_buff} message cmd_add_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_buff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            if (message.stack != null && Object.hasOwnProperty.call(message, "stack"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stack);
            if (message.expired != null && Object.hasOwnProperty.call(message, "expired"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expired);
            return writer;
        };

        /**
         * Encodes the specified cmd_add_buff message, length delimited. Does not implicitly {@link battle.cmd_add_buff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.Icmd_add_buff} message cmd_add_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_add_buff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_add_buff message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_add_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_add_buff} cmd_add_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_buff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_add_buff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                case 3: {
                        message.stack = reader.uint32();
                        break;
                    }
                case 4: {
                        message.expired = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_add_buff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_add_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_add_buff} cmd_add_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_add_buff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_add_buff message.
         * @function verify
         * @memberof battle.cmd_add_buff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_add_buff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.stack != null && message.hasOwnProperty("stack"))
                if (!$util.isInteger(message.stack))
                    return "stack: integer expected";
            if (message.expired != null && message.hasOwnProperty("expired"))
                if (!$util.isInteger(message.expired))
                    return "expired: integer expected";
            return null;
        };

        /**
         * Creates a cmd_add_buff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_add_buff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_add_buff} cmd_add_buff
         */
        cmd_add_buff.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_add_buff)
                return object;
            var message = new $root.battle.cmd_add_buff();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.stack != null)
                message.stack = object.stack >>> 0;
            if (object.expired != null)
                message.expired = object.expired >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_add_buff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_add_buff
         * @static
         * @param {battle.cmd_add_buff} message cmd_add_buff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_add_buff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.id = 0;
                object.stack = 0;
                object.expired = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.stack != null && message.hasOwnProperty("stack"))
                object.stack = message.stack;
            if (message.expired != null && message.hasOwnProperty("expired"))
                object.expired = message.expired;
            return object;
        };

        /**
         * Converts this cmd_add_buff to JSON.
         * @function toJSON
         * @memberof battle.cmd_add_buff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_add_buff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_add_buff
         * @function getTypeUrl
         * @memberof battle.cmd_add_buff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_add_buff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_add_buff";
        };

        return cmd_add_buff;
    })();

    battle.cmd_del_buff = (function() {

        /**
         * Properties of a cmd_del_buff.
         * @memberof battle
         * @interface Icmd_del_buff
         * @property {number|null} [eid] cmd_del_buff eid
         * @property {number|null} [id] cmd_del_buff id
         */

        /**
         * Constructs a new cmd_del_buff.
         * @memberof battle
         * @classdesc Represents a cmd_del_buff.
         * @implements Icmd_del_buff
         * @constructor
         * @param {battle.Icmd_del_buff=} [properties] Properties to set
         */
        function cmd_del_buff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_del_buff eid.
         * @member {number} eid
         * @memberof battle.cmd_del_buff
         * @instance
         */
        cmd_del_buff.prototype.eid = 0;

        /**
         * cmd_del_buff id.
         * @member {number} id
         * @memberof battle.cmd_del_buff
         * @instance
         */
        cmd_del_buff.prototype.id = 0;

        /**
         * Creates a new cmd_del_buff instance using the specified properties.
         * @function create
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.Icmd_del_buff=} [properties] Properties to set
         * @returns {battle.cmd_del_buff} cmd_del_buff instance
         */
        cmd_del_buff.create = function create(properties) {
            return new cmd_del_buff(properties);
        };

        /**
         * Encodes the specified cmd_del_buff message. Does not implicitly {@link battle.cmd_del_buff.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.Icmd_del_buff} message cmd_del_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_buff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified cmd_del_buff message, length delimited. Does not implicitly {@link battle.cmd_del_buff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.Icmd_del_buff} message cmd_del_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_del_buff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_del_buff message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_del_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_del_buff} cmd_del_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_buff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_del_buff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_del_buff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_del_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_del_buff} cmd_del_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_del_buff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_del_buff message.
         * @function verify
         * @memberof battle.cmd_del_buff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_del_buff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a cmd_del_buff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_del_buff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_del_buff} cmd_del_buff
         */
        cmd_del_buff.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_del_buff)
                return object;
            var message = new $root.battle.cmd_del_buff();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_del_buff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_del_buff
         * @static
         * @param {battle.cmd_del_buff} message cmd_del_buff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_del_buff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.id = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this cmd_del_buff to JSON.
         * @function toJSON
         * @memberof battle.cmd_del_buff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_del_buff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_del_buff
         * @function getTypeUrl
         * @memberof battle.cmd_del_buff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_del_buff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_del_buff";
        };

        return cmd_del_buff;
    })();

    battle.cmd_attack = (function() {

        /**
         * Properties of a cmd_attack.
         * @memberof battle
         * @interface Icmd_attack
         * @property {number|null} [eid] cmd_attack eid
         * @property {number|null} [skillId] cmd_attack skillId
         * @property {number|null} [curMp] cmd_attack curMp
         */

        /**
         * Constructs a new cmd_attack.
         * @memberof battle
         * @classdesc Represents a cmd_attack.
         * @implements Icmd_attack
         * @constructor
         * @param {battle.Icmd_attack=} [properties] Properties to set
         */
        function cmd_attack(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_attack eid.
         * @member {number} eid
         * @memberof battle.cmd_attack
         * @instance
         */
        cmd_attack.prototype.eid = 0;

        /**
         * cmd_attack skillId.
         * @member {number} skillId
         * @memberof battle.cmd_attack
         * @instance
         */
        cmd_attack.prototype.skillId = 0;

        /**
         * cmd_attack curMp.
         * @member {number} curMp
         * @memberof battle.cmd_attack
         * @instance
         */
        cmd_attack.prototype.curMp = 0;

        /**
         * Creates a new cmd_attack instance using the specified properties.
         * @function create
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.Icmd_attack=} [properties] Properties to set
         * @returns {battle.cmd_attack} cmd_attack instance
         */
        cmd_attack.create = function create(properties) {
            return new cmd_attack(properties);
        };

        /**
         * Encodes the specified cmd_attack message. Does not implicitly {@link battle.cmd_attack.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.Icmd_attack} message cmd_attack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_attack.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.skillId != null && Object.hasOwnProperty.call(message, "skillId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.skillId);
            if (message.curMp != null && Object.hasOwnProperty.call(message, "curMp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.curMp);
            return writer;
        };

        /**
         * Encodes the specified cmd_attack message, length delimited. Does not implicitly {@link battle.cmd_attack.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.Icmd_attack} message cmd_attack message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_attack.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_attack message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_attack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_attack} cmd_attack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_attack.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_attack();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.skillId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.curMp = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_attack message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_attack
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_attack} cmd_attack
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_attack.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_attack message.
         * @function verify
         * @memberof battle.cmd_attack
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_attack.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                if (!$util.isInteger(message.skillId))
                    return "skillId: integer expected";
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                if (!$util.isInteger(message.curMp))
                    return "curMp: integer expected";
            return null;
        };

        /**
         * Creates a cmd_attack message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_attack
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_attack} cmd_attack
         */
        cmd_attack.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_attack)
                return object;
            var message = new $root.battle.cmd_attack();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.skillId != null)
                message.skillId = object.skillId >>> 0;
            if (object.curMp != null)
                message.curMp = object.curMp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_attack message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_attack
         * @static
         * @param {battle.cmd_attack} message cmd_attack
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_attack.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.skillId = 0;
                object.curMp = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                object.skillId = message.skillId;
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                object.curMp = message.curMp;
            return object;
        };

        /**
         * Converts this cmd_attack to JSON.
         * @function toJSON
         * @memberof battle.cmd_attack
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_attack.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_attack
         * @function getTypeUrl
         * @memberof battle.cmd_attack
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_attack.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_attack";
        };

        return cmd_attack;
    })();

    battle.cmd_under_atk = (function() {

        /**
         * Properties of a cmd_under_atk.
         * @memberof battle
         * @interface Icmd_under_atk
         * @property {number|null} [eid] cmd_under_atk eid
         * @property {number|null} [skillId] cmd_under_atk skillId
         * @property {number|null} [subHp] cmd_under_atk subHp
         * @property {number|null} [curMp] cmd_under_atk curMp
         * @property {boolean|null} [critical] cmd_under_atk critical
         * @property {boolean|null} [dodge] cmd_under_atk dodge
         */

        /**
         * Constructs a new cmd_under_atk.
         * @memberof battle
         * @classdesc Represents a cmd_under_atk.
         * @implements Icmd_under_atk
         * @constructor
         * @param {battle.Icmd_under_atk=} [properties] Properties to set
         */
        function cmd_under_atk(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_under_atk eid.
         * @member {number} eid
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.eid = 0;

        /**
         * cmd_under_atk skillId.
         * @member {number} skillId
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.skillId = 0;

        /**
         * cmd_under_atk subHp.
         * @member {number} subHp
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.subHp = 0;

        /**
         * cmd_under_atk curMp.
         * @member {number} curMp
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.curMp = 0;

        /**
         * cmd_under_atk critical.
         * @member {boolean} critical
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.critical = false;

        /**
         * cmd_under_atk dodge.
         * @member {boolean} dodge
         * @memberof battle.cmd_under_atk
         * @instance
         */
        cmd_under_atk.prototype.dodge = false;

        /**
         * Creates a new cmd_under_atk instance using the specified properties.
         * @function create
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.Icmd_under_atk=} [properties] Properties to set
         * @returns {battle.cmd_under_atk} cmd_under_atk instance
         */
        cmd_under_atk.create = function create(properties) {
            return new cmd_under_atk(properties);
        };

        /**
         * Encodes the specified cmd_under_atk message. Does not implicitly {@link battle.cmd_under_atk.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.Icmd_under_atk} message cmd_under_atk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_under_atk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.skillId != null && Object.hasOwnProperty.call(message, "skillId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.skillId);
            if (message.subHp != null && Object.hasOwnProperty.call(message, "subHp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.subHp);
            if (message.curMp != null && Object.hasOwnProperty.call(message, "curMp"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.curMp);
            if (message.critical != null && Object.hasOwnProperty.call(message, "critical"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.critical);
            if (message.dodge != null && Object.hasOwnProperty.call(message, "dodge"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.dodge);
            return writer;
        };

        /**
         * Encodes the specified cmd_under_atk message, length delimited. Does not implicitly {@link battle.cmd_under_atk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.Icmd_under_atk} message cmd_under_atk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_under_atk.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_under_atk message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_under_atk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_under_atk} cmd_under_atk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_under_atk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_under_atk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.skillId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.subHp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.curMp = reader.uint32();
                        break;
                    }
                case 5: {
                        message.critical = reader.bool();
                        break;
                    }
                case 6: {
                        message.dodge = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_under_atk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_under_atk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_under_atk} cmd_under_atk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_under_atk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_under_atk message.
         * @function verify
         * @memberof battle.cmd_under_atk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_under_atk.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                if (!$util.isInteger(message.skillId))
                    return "skillId: integer expected";
            if (message.subHp != null && message.hasOwnProperty("subHp"))
                if (!$util.isInteger(message.subHp))
                    return "subHp: integer expected";
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                if (!$util.isInteger(message.curMp))
                    return "curMp: integer expected";
            if (message.critical != null && message.hasOwnProperty("critical"))
                if (typeof message.critical !== "boolean")
                    return "critical: boolean expected";
            if (message.dodge != null && message.hasOwnProperty("dodge"))
                if (typeof message.dodge !== "boolean")
                    return "dodge: boolean expected";
            return null;
        };

        /**
         * Creates a cmd_under_atk message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_under_atk
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_under_atk} cmd_under_atk
         */
        cmd_under_atk.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_under_atk)
                return object;
            var message = new $root.battle.cmd_under_atk();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.skillId != null)
                message.skillId = object.skillId >>> 0;
            if (object.subHp != null)
                message.subHp = object.subHp >>> 0;
            if (object.curMp != null)
                message.curMp = object.curMp >>> 0;
            if (object.critical != null)
                message.critical = Boolean(object.critical);
            if (object.dodge != null)
                message.dodge = Boolean(object.dodge);
            return message;
        };

        /**
         * Creates a plain object from a cmd_under_atk message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_under_atk
         * @static
         * @param {battle.cmd_under_atk} message cmd_under_atk
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_under_atk.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.skillId = 0;
                object.subHp = 0;
                object.curMp = 0;
                object.critical = false;
                object.dodge = false;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.skillId != null && message.hasOwnProperty("skillId"))
                object.skillId = message.skillId;
            if (message.subHp != null && message.hasOwnProperty("subHp"))
                object.subHp = message.subHp;
            if (message.curMp != null && message.hasOwnProperty("curMp"))
                object.curMp = message.curMp;
            if (message.critical != null && message.hasOwnProperty("critical"))
                object.critical = message.critical;
            if (message.dodge != null && message.hasOwnProperty("dodge"))
                object.dodge = message.dodge;
            return object;
        };

        /**
         * Converts this cmd_under_atk to JSON.
         * @function toJSON
         * @memberof battle.cmd_under_atk
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_under_atk.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_under_atk
         * @function getTypeUrl
         * @memberof battle.cmd_under_atk
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_under_atk.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_under_atk";
        };

        return cmd_under_atk;
    })();

    battle.cmd_recover_hp = (function() {

        /**
         * Properties of a cmd_recover_hp.
         * @memberof battle
         * @interface Icmd_recover_hp
         * @property {number|null} [eid] cmd_recover_hp eid
         * @property {number|null} [addHp] cmd_recover_hp addHp
         */

        /**
         * Constructs a new cmd_recover_hp.
         * @memberof battle
         * @classdesc Represents a cmd_recover_hp.
         * @implements Icmd_recover_hp
         * @constructor
         * @param {battle.Icmd_recover_hp=} [properties] Properties to set
         */
        function cmd_recover_hp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cmd_recover_hp eid.
         * @member {number} eid
         * @memberof battle.cmd_recover_hp
         * @instance
         */
        cmd_recover_hp.prototype.eid = 0;

        /**
         * cmd_recover_hp addHp.
         * @member {number} addHp
         * @memberof battle.cmd_recover_hp
         * @instance
         */
        cmd_recover_hp.prototype.addHp = 0;

        /**
         * Creates a new cmd_recover_hp instance using the specified properties.
         * @function create
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.Icmd_recover_hp=} [properties] Properties to set
         * @returns {battle.cmd_recover_hp} cmd_recover_hp instance
         */
        cmd_recover_hp.create = function create(properties) {
            return new cmd_recover_hp(properties);
        };

        /**
         * Encodes the specified cmd_recover_hp message. Does not implicitly {@link battle.cmd_recover_hp.verify|verify} messages.
         * @function encode
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.Icmd_recover_hp} message cmd_recover_hp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_recover_hp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.addHp != null && Object.hasOwnProperty.call(message, "addHp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.addHp);
            return writer;
        };

        /**
         * Encodes the specified cmd_recover_hp message, length delimited. Does not implicitly {@link battle.cmd_recover_hp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.Icmd_recover_hp} message cmd_recover_hp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        cmd_recover_hp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a cmd_recover_hp message from the specified reader or buffer.
         * @function decode
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.cmd_recover_hp} cmd_recover_hp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_recover_hp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.cmd_recover_hp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.addHp = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a cmd_recover_hp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.cmd_recover_hp} cmd_recover_hp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        cmd_recover_hp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a cmd_recover_hp message.
         * @function verify
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        cmd_recover_hp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.addHp != null && message.hasOwnProperty("addHp"))
                if (!$util.isInteger(message.addHp))
                    return "addHp: integer expected";
            return null;
        };

        /**
         * Creates a cmd_recover_hp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.cmd_recover_hp} cmd_recover_hp
         */
        cmd_recover_hp.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.cmd_recover_hp)
                return object;
            var message = new $root.battle.cmd_recover_hp();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.addHp != null)
                message.addHp = object.addHp >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a cmd_recover_hp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {battle.cmd_recover_hp} message cmd_recover_hp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        cmd_recover_hp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.addHp = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.addHp != null && message.hasOwnProperty("addHp"))
                object.addHp = message.addHp;
            return object;
        };

        /**
         * Converts this cmd_recover_hp to JSON.
         * @function toJSON
         * @memberof battle.cmd_recover_hp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        cmd_recover_hp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for cmd_recover_hp
         * @function getTypeUrl
         * @memberof battle.cmd_recover_hp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        cmd_recover_hp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.cmd_recover_hp";
        };

        return cmd_recover_hp;
    })();

    battle.BattleCmd = (function() {

        /**
         * Properties of a BattleCmd.
         * @memberof battle
         * @interface IBattleCmd
         * @property {number|null} [cmdType] BattleCmd cmdType
         * @property {battle.Icmd_add_entity|null} [addEntity] BattleCmd addEntity
         * @property {battle.Icmd_update_entity|null} [updateEntity] BattleCmd updateEntity
         * @property {battle.Icmd_del_entity|null} [delEntity] BattleCmd delEntity
         * @property {battle.Icmd_move_start|null} [moveStart] BattleCmd moveStart
         * @property {battle.Icmd_move_stop|null} [moveStop] BattleCmd moveStop
         * @property {battle.Icmd_add_buff|null} [addBuff] BattleCmd addBuff
         * @property {battle.Icmd_del_buff|null} [delBuff] BattleCmd delBuff
         * @property {battle.Icmd_attack|null} [attack] BattleCmd attack
         * @property {battle.Icmd_under_atk|null} [underAtk] BattleCmd underAtk
         * @property {battle.Icmd_force_to|null} [forceTo] BattleCmd forceTo
         * @property {battle.Icmd_move_to|null} [moveTo] BattleCmd moveTo
         * @property {battle.Icmd_recover_hp|null} [recoverHp] BattleCmd recoverHp
         */

        /**
         * Constructs a new BattleCmd.
         * @memberof battle
         * @classdesc Represents a BattleCmd.
         * @implements IBattleCmd
         * @constructor
         * @param {battle.IBattleCmd=} [properties] Properties to set
         */
        function BattleCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleCmd cmdType.
         * @member {number} cmdType
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.cmdType = 0;

        /**
         * BattleCmd addEntity.
         * @member {battle.Icmd_add_entity|null|undefined} addEntity
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.addEntity = null;

        /**
         * BattleCmd updateEntity.
         * @member {battle.Icmd_update_entity|null|undefined} updateEntity
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.updateEntity = null;

        /**
         * BattleCmd delEntity.
         * @member {battle.Icmd_del_entity|null|undefined} delEntity
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.delEntity = null;

        /**
         * BattleCmd moveStart.
         * @member {battle.Icmd_move_start|null|undefined} moveStart
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.moveStart = null;

        /**
         * BattleCmd moveStop.
         * @member {battle.Icmd_move_stop|null|undefined} moveStop
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.moveStop = null;

        /**
         * BattleCmd addBuff.
         * @member {battle.Icmd_add_buff|null|undefined} addBuff
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.addBuff = null;

        /**
         * BattleCmd delBuff.
         * @member {battle.Icmd_del_buff|null|undefined} delBuff
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.delBuff = null;

        /**
         * BattleCmd attack.
         * @member {battle.Icmd_attack|null|undefined} attack
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.attack = null;

        /**
         * BattleCmd underAtk.
         * @member {battle.Icmd_under_atk|null|undefined} underAtk
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.underAtk = null;

        /**
         * BattleCmd forceTo.
         * @member {battle.Icmd_force_to|null|undefined} forceTo
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.forceTo = null;

        /**
         * BattleCmd moveTo.
         * @member {battle.Icmd_move_to|null|undefined} moveTo
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.moveTo = null;

        /**
         * BattleCmd recoverHp.
         * @member {battle.Icmd_recover_hp|null|undefined} recoverHp
         * @memberof battle.BattleCmd
         * @instance
         */
        BattleCmd.prototype.recoverHp = null;

        /**
         * Creates a new BattleCmd instance using the specified properties.
         * @function create
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.IBattleCmd=} [properties] Properties to set
         * @returns {battle.BattleCmd} BattleCmd instance
         */
        BattleCmd.create = function create(properties) {
            return new BattleCmd(properties);
        };

        /**
         * Encodes the specified BattleCmd message. Does not implicitly {@link battle.BattleCmd.verify|verify} messages.
         * @function encode
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.IBattleCmd} message BattleCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmdType != null && Object.hasOwnProperty.call(message, "cmdType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cmdType);
            if (message.addEntity != null && Object.hasOwnProperty.call(message, "addEntity"))
                $root.battle.cmd_add_entity.encode(message.addEntity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.updateEntity != null && Object.hasOwnProperty.call(message, "updateEntity"))
                $root.battle.cmd_update_entity.encode(message.updateEntity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.delEntity != null && Object.hasOwnProperty.call(message, "delEntity"))
                $root.battle.cmd_del_entity.encode(message.delEntity, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.moveStart != null && Object.hasOwnProperty.call(message, "moveStart"))
                $root.battle.cmd_move_start.encode(message.moveStart, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.moveStop != null && Object.hasOwnProperty.call(message, "moveStop"))
                $root.battle.cmd_move_stop.encode(message.moveStop, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.addBuff != null && Object.hasOwnProperty.call(message, "addBuff"))
                $root.battle.cmd_add_buff.encode(message.addBuff, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.delBuff != null && Object.hasOwnProperty.call(message, "delBuff"))
                $root.battle.cmd_del_buff.encode(message.delBuff, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.attack != null && Object.hasOwnProperty.call(message, "attack"))
                $root.battle.cmd_attack.encode(message.attack, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.underAtk != null && Object.hasOwnProperty.call(message, "underAtk"))
                $root.battle.cmd_under_atk.encode(message.underAtk, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.forceTo != null && Object.hasOwnProperty.call(message, "forceTo"))
                $root.battle.cmd_force_to.encode(message.forceTo, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.moveTo != null && Object.hasOwnProperty.call(message, "moveTo"))
                $root.battle.cmd_move_to.encode(message.moveTo, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.recoverHp != null && Object.hasOwnProperty.call(message, "recoverHp"))
                $root.battle.cmd_recover_hp.encode(message.recoverHp, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BattleCmd message, length delimited. Does not implicitly {@link battle.BattleCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.IBattleCmd} message BattleCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleCmd message from the specified reader or buffer.
         * @function decode
         * @memberof battle.BattleCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.BattleCmd} BattleCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.BattleCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmdType = reader.uint32();
                        break;
                    }
                case 2: {
                        message.addEntity = $root.battle.cmd_add_entity.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.updateEntity = $root.battle.cmd_update_entity.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.delEntity = $root.battle.cmd_del_entity.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.moveStart = $root.battle.cmd_move_start.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.moveStop = $root.battle.cmd_move_stop.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.addBuff = $root.battle.cmd_add_buff.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.delBuff = $root.battle.cmd_del_buff.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.attack = $root.battle.cmd_attack.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.underAtk = $root.battle.cmd_under_atk.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.forceTo = $root.battle.cmd_force_to.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.moveTo = $root.battle.cmd_move_to.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.recoverHp = $root.battle.cmd_recover_hp.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.BattleCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.BattleCmd} BattleCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleCmd message.
         * @function verify
         * @memberof battle.BattleCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmdType != null && message.hasOwnProperty("cmdType"))
                if (!$util.isInteger(message.cmdType))
                    return "cmdType: integer expected";
            if (message.addEntity != null && message.hasOwnProperty("addEntity")) {
                var error = $root.battle.cmd_add_entity.verify(message.addEntity);
                if (error)
                    return "addEntity." + error;
            }
            if (message.updateEntity != null && message.hasOwnProperty("updateEntity")) {
                var error = $root.battle.cmd_update_entity.verify(message.updateEntity);
                if (error)
                    return "updateEntity." + error;
            }
            if (message.delEntity != null && message.hasOwnProperty("delEntity")) {
                var error = $root.battle.cmd_del_entity.verify(message.delEntity);
                if (error)
                    return "delEntity." + error;
            }
            if (message.moveStart != null && message.hasOwnProperty("moveStart")) {
                var error = $root.battle.cmd_move_start.verify(message.moveStart);
                if (error)
                    return "moveStart." + error;
            }
            if (message.moveStop != null && message.hasOwnProperty("moveStop")) {
                var error = $root.battle.cmd_move_stop.verify(message.moveStop);
                if (error)
                    return "moveStop." + error;
            }
            if (message.addBuff != null && message.hasOwnProperty("addBuff")) {
                var error = $root.battle.cmd_add_buff.verify(message.addBuff);
                if (error)
                    return "addBuff." + error;
            }
            if (message.delBuff != null && message.hasOwnProperty("delBuff")) {
                var error = $root.battle.cmd_del_buff.verify(message.delBuff);
                if (error)
                    return "delBuff." + error;
            }
            if (message.attack != null && message.hasOwnProperty("attack")) {
                var error = $root.battle.cmd_attack.verify(message.attack);
                if (error)
                    return "attack." + error;
            }
            if (message.underAtk != null && message.hasOwnProperty("underAtk")) {
                var error = $root.battle.cmd_under_atk.verify(message.underAtk);
                if (error)
                    return "underAtk." + error;
            }
            if (message.forceTo != null && message.hasOwnProperty("forceTo")) {
                var error = $root.battle.cmd_force_to.verify(message.forceTo);
                if (error)
                    return "forceTo." + error;
            }
            if (message.moveTo != null && message.hasOwnProperty("moveTo")) {
                var error = $root.battle.cmd_move_to.verify(message.moveTo);
                if (error)
                    return "moveTo." + error;
            }
            if (message.recoverHp != null && message.hasOwnProperty("recoverHp")) {
                var error = $root.battle.cmd_recover_hp.verify(message.recoverHp);
                if (error)
                    return "recoverHp." + error;
            }
            return null;
        };

        /**
         * Creates a BattleCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.BattleCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.BattleCmd} BattleCmd
         */
        BattleCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.BattleCmd)
                return object;
            var message = new $root.battle.BattleCmd();
            if (object.cmdType != null)
                message.cmdType = object.cmdType >>> 0;
            if (object.addEntity != null) {
                if (typeof object.addEntity !== "object")
                    throw TypeError(".battle.BattleCmd.addEntity: object expected");
                message.addEntity = $root.battle.cmd_add_entity.fromObject(object.addEntity);
            }
            if (object.updateEntity != null) {
                if (typeof object.updateEntity !== "object")
                    throw TypeError(".battle.BattleCmd.updateEntity: object expected");
                message.updateEntity = $root.battle.cmd_update_entity.fromObject(object.updateEntity);
            }
            if (object.delEntity != null) {
                if (typeof object.delEntity !== "object")
                    throw TypeError(".battle.BattleCmd.delEntity: object expected");
                message.delEntity = $root.battle.cmd_del_entity.fromObject(object.delEntity);
            }
            if (object.moveStart != null) {
                if (typeof object.moveStart !== "object")
                    throw TypeError(".battle.BattleCmd.moveStart: object expected");
                message.moveStart = $root.battle.cmd_move_start.fromObject(object.moveStart);
            }
            if (object.moveStop != null) {
                if (typeof object.moveStop !== "object")
                    throw TypeError(".battle.BattleCmd.moveStop: object expected");
                message.moveStop = $root.battle.cmd_move_stop.fromObject(object.moveStop);
            }
            if (object.addBuff != null) {
                if (typeof object.addBuff !== "object")
                    throw TypeError(".battle.BattleCmd.addBuff: object expected");
                message.addBuff = $root.battle.cmd_add_buff.fromObject(object.addBuff);
            }
            if (object.delBuff != null) {
                if (typeof object.delBuff !== "object")
                    throw TypeError(".battle.BattleCmd.delBuff: object expected");
                message.delBuff = $root.battle.cmd_del_buff.fromObject(object.delBuff);
            }
            if (object.attack != null) {
                if (typeof object.attack !== "object")
                    throw TypeError(".battle.BattleCmd.attack: object expected");
                message.attack = $root.battle.cmd_attack.fromObject(object.attack);
            }
            if (object.underAtk != null) {
                if (typeof object.underAtk !== "object")
                    throw TypeError(".battle.BattleCmd.underAtk: object expected");
                message.underAtk = $root.battle.cmd_under_atk.fromObject(object.underAtk);
            }
            if (object.forceTo != null) {
                if (typeof object.forceTo !== "object")
                    throw TypeError(".battle.BattleCmd.forceTo: object expected");
                message.forceTo = $root.battle.cmd_force_to.fromObject(object.forceTo);
            }
            if (object.moveTo != null) {
                if (typeof object.moveTo !== "object")
                    throw TypeError(".battle.BattleCmd.moveTo: object expected");
                message.moveTo = $root.battle.cmd_move_to.fromObject(object.moveTo);
            }
            if (object.recoverHp != null) {
                if (typeof object.recoverHp !== "object")
                    throw TypeError(".battle.BattleCmd.recoverHp: object expected");
                message.recoverHp = $root.battle.cmd_recover_hp.fromObject(object.recoverHp);
            }
            return message;
        };

        /**
         * Creates a plain object from a BattleCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.BattleCmd
         * @static
         * @param {battle.BattleCmd} message BattleCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cmdType = 0;
                object.addEntity = null;
                object.updateEntity = null;
                object.delEntity = null;
                object.moveStart = null;
                object.moveStop = null;
                object.addBuff = null;
                object.delBuff = null;
                object.attack = null;
                object.underAtk = null;
                object.forceTo = null;
                object.moveTo = null;
                object.recoverHp = null;
            }
            if (message.cmdType != null && message.hasOwnProperty("cmdType"))
                object.cmdType = message.cmdType;
            if (message.addEntity != null && message.hasOwnProperty("addEntity"))
                object.addEntity = $root.battle.cmd_add_entity.toObject(message.addEntity, options);
            if (message.updateEntity != null && message.hasOwnProperty("updateEntity"))
                object.updateEntity = $root.battle.cmd_update_entity.toObject(message.updateEntity, options);
            if (message.delEntity != null && message.hasOwnProperty("delEntity"))
                object.delEntity = $root.battle.cmd_del_entity.toObject(message.delEntity, options);
            if (message.moveStart != null && message.hasOwnProperty("moveStart"))
                object.moveStart = $root.battle.cmd_move_start.toObject(message.moveStart, options);
            if (message.moveStop != null && message.hasOwnProperty("moveStop"))
                object.moveStop = $root.battle.cmd_move_stop.toObject(message.moveStop, options);
            if (message.addBuff != null && message.hasOwnProperty("addBuff"))
                object.addBuff = $root.battle.cmd_add_buff.toObject(message.addBuff, options);
            if (message.delBuff != null && message.hasOwnProperty("delBuff"))
                object.delBuff = $root.battle.cmd_del_buff.toObject(message.delBuff, options);
            if (message.attack != null && message.hasOwnProperty("attack"))
                object.attack = $root.battle.cmd_attack.toObject(message.attack, options);
            if (message.underAtk != null && message.hasOwnProperty("underAtk"))
                object.underAtk = $root.battle.cmd_under_atk.toObject(message.underAtk, options);
            if (message.forceTo != null && message.hasOwnProperty("forceTo"))
                object.forceTo = $root.battle.cmd_force_to.toObject(message.forceTo, options);
            if (message.moveTo != null && message.hasOwnProperty("moveTo"))
                object.moveTo = $root.battle.cmd_move_to.toObject(message.moveTo, options);
            if (message.recoverHp != null && message.hasOwnProperty("recoverHp"))
                object.recoverHp = $root.battle.cmd_recover_hp.toObject(message.recoverHp, options);
            return object;
        };

        /**
         * Converts this BattleCmd to JSON.
         * @function toJSON
         * @memberof battle.BattleCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleCmd
         * @function getTypeUrl
         * @memberof battle.BattleCmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleCmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.BattleCmd";
        };

        return BattleCmd;
    })();

    battle.Battle = (function() {

        /**
         * Properties of a Battle.
         * @memberof battle
         * @interface IBattle
         * @property {number|null} [battleId] Battle battleId
         * @property {number|null} [battleUid] Battle battleUid
         * @property {Array.<battle.IBattleRole>|null} [roles] Battle roles
         */

        /**
         * Constructs a new Battle.
         * @memberof battle
         * @classdesc Represents a Battle.
         * @implements IBattle
         * @constructor
         * @param {battle.IBattle=} [properties] Properties to set
         */
        function Battle(properties) {
            this.roles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Battle battleId.
         * @member {number} battleId
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.battleId = 0;

        /**
         * Battle battleUid.
         * @member {number} battleUid
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.battleUid = 0;

        /**
         * Battle roles.
         * @member {Array.<battle.IBattleRole>} roles
         * @memberof battle.Battle
         * @instance
         */
        Battle.prototype.roles = $util.emptyArray;

        /**
         * Creates a new Battle instance using the specified properties.
         * @function create
         * @memberof battle.Battle
         * @static
         * @param {battle.IBattle=} [properties] Properties to set
         * @returns {battle.Battle} Battle instance
         */
        Battle.create = function create(properties) {
            return new Battle(properties);
        };

        /**
         * Encodes the specified Battle message. Does not implicitly {@link battle.Battle.verify|verify} messages.
         * @function encode
         * @memberof battle.Battle
         * @static
         * @param {battle.IBattle} message Battle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Battle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleId != null && Object.hasOwnProperty.call(message, "battleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleId);
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.battleUid);
            if (message.roles != null && message.roles.length)
                for (var i = 0; i < message.roles.length; ++i)
                    $root.battle.BattleRole.encode(message.roles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Battle message, length delimited. Does not implicitly {@link battle.Battle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.Battle
         * @static
         * @param {battle.IBattle} message Battle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Battle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Battle message from the specified reader or buffer.
         * @function decode
         * @memberof battle.Battle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.Battle} Battle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Battle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.Battle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 3: {
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push($root.battle.BattleRole.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Battle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.Battle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.Battle} Battle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Battle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Battle message.
         * @function verify
         * @memberof battle.Battle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Battle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleId != null && message.hasOwnProperty("battleId"))
                if (!$util.isInteger(message.battleId))
                    return "battleId: integer expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (var i = 0; i < message.roles.length; ++i) {
                    var error = $root.battle.BattleRole.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Battle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.Battle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.Battle} Battle
         */
        Battle.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.Battle)
                return object;
            var message = new $root.battle.Battle();
            if (object.battleId != null)
                message.battleId = object.battleId >>> 0;
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".battle.Battle.roles: array expected");
                message.roles = [];
                for (var i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".battle.Battle.roles: object expected");
                    message.roles[i] = $root.battle.BattleRole.fromObject(object.roles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Battle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.Battle
         * @static
         * @param {battle.Battle} message Battle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Battle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.roles = [];
            if (options.defaults) {
                object.battleId = 0;
                object.battleUid = 0;
            }
            if (message.battleId != null && message.hasOwnProperty("battleId"))
                object.battleId = message.battleId;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (var j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.battle.BattleRole.toObject(message.roles[j], options);
            }
            return object;
        };

        /**
         * Converts this Battle to JSON.
         * @function toJSON
         * @memberof battle.Battle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Battle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Battle
         * @function getTypeUrl
         * @memberof battle.Battle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Battle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.Battle";
        };

        return Battle;
    })();

    battle.c2s_enter = (function() {

        /**
         * Properties of a c2s_enter.
         * @memberof battle
         * @interface Ic2s_enter
         * @property {number|null} [battleUid] c2s_enter battleUid
         */

        /**
         * Constructs a new c2s_enter.
         * @memberof battle
         * @classdesc Represents a c2s_enter.
         * @implements Ic2s_enter
         * @constructor
         * @param {battle.Ic2s_enter=} [properties] Properties to set
         */
        function c2s_enter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_enter battleUid.
         * @member {number} battleUid
         * @memberof battle.c2s_enter
         * @instance
         */
        c2s_enter.prototype.battleUid = 0;

        /**
         * Creates a new c2s_enter instance using the specified properties.
         * @function create
         * @memberof battle.c2s_enter
         * @static
         * @param {battle.Ic2s_enter=} [properties] Properties to set
         * @returns {battle.c2s_enter} c2s_enter instance
         */
        c2s_enter.create = function create(properties) {
            return new c2s_enter(properties);
        };

        /**
         * Encodes the specified c2s_enter message. Does not implicitly {@link battle.c2s_enter.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_enter
         * @static
         * @param {battle.Ic2s_enter} message c2s_enter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_enter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_enter message, length delimited. Does not implicitly {@link battle.c2s_enter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_enter
         * @static
         * @param {battle.Ic2s_enter} message c2s_enter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_enter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_enter message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_enter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_enter} c2s_enter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_enter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_enter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_enter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_enter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_enter} c2s_enter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_enter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_enter message.
         * @function verify
         * @memberof battle.c2s_enter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_enter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_enter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_enter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_enter} c2s_enter
         */
        c2s_enter.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_enter)
                return object;
            var message = new $root.battle.c2s_enter();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_enter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_enter
         * @static
         * @param {battle.c2s_enter} message c2s_enter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_enter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            return object;
        };

        /**
         * Converts this c2s_enter to JSON.
         * @function toJSON
         * @memberof battle.c2s_enter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_enter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_enter
         * @function getTypeUrl
         * @memberof battle.c2s_enter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_enter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_enter";
        };

        return c2s_enter;
    })();

    battle.s2c_enter = (function() {

        /**
         * Properties of a s2c_enter.
         * @memberof battle
         * @interface Is2c_enter
         * @property {number|null} [err] s2c_enter err
         * @property {Array.<battle.IBattleRole>|null} [roles] s2c_enter roles
         * @property {Array.<battle.IBattleEntity>|null} [entities] s2c_enter entities
         */

        /**
         * Constructs a new s2c_enter.
         * @memberof battle
         * @classdesc Represents a s2c_enter.
         * @implements Is2c_enter
         * @constructor
         * @param {battle.Is2c_enter=} [properties] Properties to set
         */
        function s2c_enter(properties) {
            this.roles = [];
            this.entities = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_enter err.
         * @member {number} err
         * @memberof battle.s2c_enter
         * @instance
         */
        s2c_enter.prototype.err = 0;

        /**
         * s2c_enter roles.
         * @member {Array.<battle.IBattleRole>} roles
         * @memberof battle.s2c_enter
         * @instance
         */
        s2c_enter.prototype.roles = $util.emptyArray;

        /**
         * s2c_enter entities.
         * @member {Array.<battle.IBattleEntity>} entities
         * @memberof battle.s2c_enter
         * @instance
         */
        s2c_enter.prototype.entities = $util.emptyArray;

        /**
         * Creates a new s2c_enter instance using the specified properties.
         * @function create
         * @memberof battle.s2c_enter
         * @static
         * @param {battle.Is2c_enter=} [properties] Properties to set
         * @returns {battle.s2c_enter} s2c_enter instance
         */
        s2c_enter.create = function create(properties) {
            return new s2c_enter(properties);
        };

        /**
         * Encodes the specified s2c_enter message. Does not implicitly {@link battle.s2c_enter.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_enter
         * @static
         * @param {battle.Is2c_enter} message s2c_enter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_enter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.roles != null && message.roles.length)
                for (var i = 0; i < message.roles.length; ++i)
                    $root.battle.BattleRole.encode(message.roles[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.entities != null && message.entities.length)
                for (var i = 0; i < message.entities.length; ++i)
                    $root.battle.BattleEntity.encode(message.entities[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_enter message, length delimited. Does not implicitly {@link battle.s2c_enter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_enter
         * @static
         * @param {battle.Is2c_enter} message s2c_enter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_enter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_enter message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_enter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_enter} s2c_enter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_enter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_enter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push($root.battle.BattleRole.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.entities && message.entities.length))
                            message.entities = [];
                        message.entities.push($root.battle.BattleEntity.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_enter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_enter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_enter} s2c_enter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_enter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_enter message.
         * @function verify
         * @memberof battle.s2c_enter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_enter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (var i = 0; i < message.roles.length; ++i) {
                    var error = $root.battle.BattleRole.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            if (message.entities != null && message.hasOwnProperty("entities")) {
                if (!Array.isArray(message.entities))
                    return "entities: array expected";
                for (var i = 0; i < message.entities.length; ++i) {
                    var error = $root.battle.BattleEntity.verify(message.entities[i]);
                    if (error)
                        return "entities." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_enter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_enter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_enter} s2c_enter
         */
        s2c_enter.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_enter)
                return object;
            var message = new $root.battle.s2c_enter();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".battle.s2c_enter.roles: array expected");
                message.roles = [];
                for (var i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".battle.s2c_enter.roles: object expected");
                    message.roles[i] = $root.battle.BattleRole.fromObject(object.roles[i]);
                }
            }
            if (object.entities) {
                if (!Array.isArray(object.entities))
                    throw TypeError(".battle.s2c_enter.entities: array expected");
                message.entities = [];
                for (var i = 0; i < object.entities.length; ++i) {
                    if (typeof object.entities[i] !== "object")
                        throw TypeError(".battle.s2c_enter.entities: object expected");
                    message.entities[i] = $root.battle.BattleEntity.fromObject(object.entities[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_enter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_enter
         * @static
         * @param {battle.s2c_enter} message s2c_enter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_enter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.roles = [];
                object.entities = [];
            }
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (var j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.battle.BattleRole.toObject(message.roles[j], options);
            }
            if (message.entities && message.entities.length) {
                object.entities = [];
                for (var j = 0; j < message.entities.length; ++j)
                    object.entities[j] = $root.battle.BattleEntity.toObject(message.entities[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_enter to JSON.
         * @function toJSON
         * @memberof battle.s2c_enter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_enter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_enter
         * @function getTypeUrl
         * @memberof battle.s2c_enter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_enter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_enter";
        };

        return s2c_enter;
    })();

    battle.notify_cmd = (function() {

        /**
         * Properties of a notify_cmd.
         * @memberof battle
         * @interface Inotify_cmd
         * @property {number|null} [frame] notify_cmd frame
         * @property {Array.<battle.IBattleCmd>|null} [cmds] notify_cmd cmds
         */

        /**
         * Constructs a new notify_cmd.
         * @memberof battle
         * @classdesc Represents a notify_cmd.
         * @implements Inotify_cmd
         * @constructor
         * @param {battle.Inotify_cmd=} [properties] Properties to set
         */
        function notify_cmd(properties) {
            this.cmds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_cmd frame.
         * @member {number} frame
         * @memberof battle.notify_cmd
         * @instance
         */
        notify_cmd.prototype.frame = 0;

        /**
         * notify_cmd cmds.
         * @member {Array.<battle.IBattleCmd>} cmds
         * @memberof battle.notify_cmd
         * @instance
         */
        notify_cmd.prototype.cmds = $util.emptyArray;

        /**
         * Creates a new notify_cmd instance using the specified properties.
         * @function create
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.Inotify_cmd=} [properties] Properties to set
         * @returns {battle.notify_cmd} notify_cmd instance
         */
        notify_cmd.create = function create(properties) {
            return new notify_cmd(properties);
        };

        /**
         * Encodes the specified notify_cmd message. Does not implicitly {@link battle.notify_cmd.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.Inotify_cmd} message notify_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_cmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frame != null && Object.hasOwnProperty.call(message, "frame"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.frame);
            if (message.cmds != null && message.cmds.length)
                for (var i = 0; i < message.cmds.length; ++i)
                    $root.battle.BattleCmd.encode(message.cmds[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_cmd message, length delimited. Does not implicitly {@link battle.notify_cmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.Inotify_cmd} message notify_cmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_cmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_cmd message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_cmd} notify_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_cmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_cmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.frame = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.cmds && message.cmds.length))
                            message.cmds = [];
                        message.cmds.push($root.battle.BattleCmd.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_cmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_cmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_cmd} notify_cmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_cmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_cmd message.
         * @function verify
         * @memberof battle.notify_cmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_cmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frame != null && message.hasOwnProperty("frame"))
                if (!$util.isInteger(message.frame))
                    return "frame: integer expected";
            if (message.cmds != null && message.hasOwnProperty("cmds")) {
                if (!Array.isArray(message.cmds))
                    return "cmds: array expected";
                for (var i = 0; i < message.cmds.length; ++i) {
                    var error = $root.battle.BattleCmd.verify(message.cmds[i]);
                    if (error)
                        return "cmds." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_cmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_cmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_cmd} notify_cmd
         */
        notify_cmd.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_cmd)
                return object;
            var message = new $root.battle.notify_cmd();
            if (object.frame != null)
                message.frame = object.frame >>> 0;
            if (object.cmds) {
                if (!Array.isArray(object.cmds))
                    throw TypeError(".battle.notify_cmd.cmds: array expected");
                message.cmds = [];
                for (var i = 0; i < object.cmds.length; ++i) {
                    if (typeof object.cmds[i] !== "object")
                        throw TypeError(".battle.notify_cmd.cmds: object expected");
                    message.cmds[i] = $root.battle.BattleCmd.fromObject(object.cmds[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_cmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_cmd
         * @static
         * @param {battle.notify_cmd} message notify_cmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_cmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.cmds = [];
            if (options.defaults)
                object.frame = 0;
            if (message.frame != null && message.hasOwnProperty("frame"))
                object.frame = message.frame;
            if (message.cmds && message.cmds.length) {
                object.cmds = [];
                for (var j = 0; j < message.cmds.length; ++j)
                    object.cmds[j] = $root.battle.BattleCmd.toObject(message.cmds[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_cmd to JSON.
         * @function toJSON
         * @memberof battle.notify_cmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_cmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_cmd
         * @function getTypeUrl
         * @memberof battle.notify_cmd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_cmd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_cmd";
        };

        return notify_cmd;
    })();

    battle.c2s_launch_skill = (function() {

        /**
         * Properties of a c2s_launch_skill.
         * @memberof battle
         * @interface Ic2s_launch_skill
         * @property {number|null} [eid] c2s_launch_skill eid
         */

        /**
         * Constructs a new c2s_launch_skill.
         * @memberof battle
         * @classdesc Represents a c2s_launch_skill.
         * @implements Ic2s_launch_skill
         * @constructor
         * @param {battle.Ic2s_launch_skill=} [properties] Properties to set
         */
        function c2s_launch_skill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_launch_skill eid.
         * @member {number} eid
         * @memberof battle.c2s_launch_skill
         * @instance
         */
        c2s_launch_skill.prototype.eid = 0;

        /**
         * Creates a new c2s_launch_skill instance using the specified properties.
         * @function create
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.Ic2s_launch_skill=} [properties] Properties to set
         * @returns {battle.c2s_launch_skill} c2s_launch_skill instance
         */
        c2s_launch_skill.create = function create(properties) {
            return new c2s_launch_skill(properties);
        };

        /**
         * Encodes the specified c2s_launch_skill message. Does not implicitly {@link battle.c2s_launch_skill.verify|verify} messages.
         * @function encode
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.Ic2s_launch_skill} message c2s_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_launch_skill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified c2s_launch_skill message, length delimited. Does not implicitly {@link battle.c2s_launch_skill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.Ic2s_launch_skill} message c2s_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_launch_skill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_launch_skill message from the specified reader or buffer.
         * @function decode
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.c2s_launch_skill} c2s_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_launch_skill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.c2s_launch_skill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_launch_skill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.c2s_launch_skill} c2s_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_launch_skill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_launch_skill message.
         * @function verify
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_launch_skill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_launch_skill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.c2s_launch_skill} c2s_launch_skill
         */
        c2s_launch_skill.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.c2s_launch_skill)
                return object;
            var message = new $root.battle.c2s_launch_skill();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_launch_skill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {battle.c2s_launch_skill} message c2s_launch_skill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_launch_skill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this c2s_launch_skill to JSON.
         * @function toJSON
         * @memberof battle.c2s_launch_skill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_launch_skill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_launch_skill
         * @function getTypeUrl
         * @memberof battle.c2s_launch_skill
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_launch_skill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.c2s_launch_skill";
        };

        return c2s_launch_skill;
    })();

    battle.s2c_launch_skill = (function() {

        /**
         * Properties of a s2c_launch_skill.
         * @memberof battle
         * @interface Is2c_launch_skill
         * @property {number|null} [err] s2c_launch_skill err
         */

        /**
         * Constructs a new s2c_launch_skill.
         * @memberof battle
         * @classdesc Represents a s2c_launch_skill.
         * @implements Is2c_launch_skill
         * @constructor
         * @param {battle.Is2c_launch_skill=} [properties] Properties to set
         */
        function s2c_launch_skill(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_launch_skill err.
         * @member {number} err
         * @memberof battle.s2c_launch_skill
         * @instance
         */
        s2c_launch_skill.prototype.err = 0;

        /**
         * Creates a new s2c_launch_skill instance using the specified properties.
         * @function create
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.Is2c_launch_skill=} [properties] Properties to set
         * @returns {battle.s2c_launch_skill} s2c_launch_skill instance
         */
        s2c_launch_skill.create = function create(properties) {
            return new s2c_launch_skill(properties);
        };

        /**
         * Encodes the specified s2c_launch_skill message. Does not implicitly {@link battle.s2c_launch_skill.verify|verify} messages.
         * @function encode
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.Is2c_launch_skill} message s2c_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_launch_skill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_launch_skill message, length delimited. Does not implicitly {@link battle.s2c_launch_skill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.Is2c_launch_skill} message s2c_launch_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_launch_skill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_launch_skill message from the specified reader or buffer.
         * @function decode
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.s2c_launch_skill} s2c_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_launch_skill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.s2c_launch_skill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_launch_skill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.s2c_launch_skill} s2c_launch_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_launch_skill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_launch_skill message.
         * @function verify
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_launch_skill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_launch_skill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.s2c_launch_skill} s2c_launch_skill
         */
        s2c_launch_skill.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.s2c_launch_skill)
                return object;
            var message = new $root.battle.s2c_launch_skill();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_launch_skill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {battle.s2c_launch_skill} message s2c_launch_skill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_launch_skill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_launch_skill to JSON.
         * @function toJSON
         * @memberof battle.s2c_launch_skill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_launch_skill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_launch_skill
         * @function getTypeUrl
         * @memberof battle.s2c_launch_skill
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_launch_skill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.s2c_launch_skill";
        };

        return s2c_launch_skill;
    })();

    battle.notify_start = (function() {

        /**
         * Properties of a notify_start.
         * @memberof battle
         * @interface Inotify_start
         */

        /**
         * Constructs a new notify_start.
         * @memberof battle
         * @classdesc Represents a notify_start.
         * @implements Inotify_start
         * @constructor
         * @param {battle.Inotify_start=} [properties] Properties to set
         */
        function notify_start(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new notify_start instance using the specified properties.
         * @function create
         * @memberof battle.notify_start
         * @static
         * @param {battle.Inotify_start=} [properties] Properties to set
         * @returns {battle.notify_start} notify_start instance
         */
        notify_start.create = function create(properties) {
            return new notify_start(properties);
        };

        /**
         * Encodes the specified notify_start message. Does not implicitly {@link battle.notify_start.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_start
         * @static
         * @param {battle.Inotify_start} message notify_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_start.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified notify_start message, length delimited. Does not implicitly {@link battle.notify_start.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_start
         * @static
         * @param {battle.Inotify_start} message notify_start message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_start.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_start message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_start} notify_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_start.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_start();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_start message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_start
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_start} notify_start
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_start.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_start message.
         * @function verify
         * @memberof battle.notify_start
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_start.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a notify_start message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_start
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_start} notify_start
         */
        notify_start.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_start)
                return object;
            return new $root.battle.notify_start();
        };

        /**
         * Creates a plain object from a notify_start message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_start
         * @static
         * @param {battle.notify_start} message notify_start
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_start.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this notify_start to JSON.
         * @function toJSON
         * @memberof battle.notify_start
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_start.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_start
         * @function getTypeUrl
         * @memberof battle.notify_start
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_start.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_start";
        };

        return notify_start;
    })();

    battle.notify_end = (function() {

        /**
         * Properties of a notify_end.
         * @memberof battle
         * @interface Inotify_end
         */

        /**
         * Constructs a new notify_end.
         * @memberof battle
         * @classdesc Represents a notify_end.
         * @implements Inotify_end
         * @constructor
         * @param {battle.Inotify_end=} [properties] Properties to set
         */
        function notify_end(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new notify_end instance using the specified properties.
         * @function create
         * @memberof battle.notify_end
         * @static
         * @param {battle.Inotify_end=} [properties] Properties to set
         * @returns {battle.notify_end} notify_end instance
         */
        notify_end.create = function create(properties) {
            return new notify_end(properties);
        };

        /**
         * Encodes the specified notify_end message. Does not implicitly {@link battle.notify_end.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_end
         * @static
         * @param {battle.Inotify_end} message notify_end message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_end.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified notify_end message, length delimited. Does not implicitly {@link battle.notify_end.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_end
         * @static
         * @param {battle.Inotify_end} message notify_end message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_end.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_end message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_end
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_end} notify_end
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_end.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_end();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_end message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_end
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_end} notify_end
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_end.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_end message.
         * @function verify
         * @memberof battle.notify_end
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_end.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a notify_end message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_end
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_end} notify_end
         */
        notify_end.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_end)
                return object;
            return new $root.battle.notify_end();
        };

        /**
         * Creates a plain object from a notify_end message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_end
         * @static
         * @param {battle.notify_end} message notify_end
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_end.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this notify_end to JSON.
         * @function toJSON
         * @memberof battle.notify_end
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_end.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_end
         * @function getTypeUrl
         * @memberof battle.notify_end
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_end.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_end";
        };

        return notify_end;
    })();

    battle.DebugInfo = (function() {

        /**
         * Properties of a DebugInfo.
         * @memberof battle
         * @interface IDebugInfo
         * @property {number|null} [x] DebugInfo x
         * @property {number|null} [y] DebugInfo y
         * @property {number|null} [z] DebugInfo z
         * @property {number|null} [color] DebugInfo color
         * @property {number|null} [size] DebugInfo size
         */

        /**
         * Constructs a new DebugInfo.
         * @memberof battle
         * @classdesc Represents a DebugInfo.
         * @implements IDebugInfo
         * @constructor
         * @param {battle.IDebugInfo=} [properties] Properties to set
         */
        function DebugInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugInfo x.
         * @member {number} x
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.x = 0;

        /**
         * DebugInfo y.
         * @member {number} y
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.y = 0;

        /**
         * DebugInfo z.
         * @member {number} z
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.z = 0;

        /**
         * DebugInfo color.
         * @member {number} color
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.color = 0;

        /**
         * DebugInfo size.
         * @member {number} size
         * @memberof battle.DebugInfo
         * @instance
         */
        DebugInfo.prototype.size = 0;

        /**
         * Creates a new DebugInfo instance using the specified properties.
         * @function create
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.IDebugInfo=} [properties] Properties to set
         * @returns {battle.DebugInfo} DebugInfo instance
         */
        DebugInfo.create = function create(properties) {
            return new DebugInfo(properties);
        };

        /**
         * Encodes the specified DebugInfo message. Does not implicitly {@link battle.DebugInfo.verify|verify} messages.
         * @function encode
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.IDebugInfo} message DebugInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.z);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.color);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.size);
            return writer;
        };

        /**
         * Encodes the specified DebugInfo message, length delimited. Does not implicitly {@link battle.DebugInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.IDebugInfo} message DebugInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugInfo message from the specified reader or buffer.
         * @function decode
         * @memberof battle.DebugInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.DebugInfo} DebugInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.DebugInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.uint32();
                        break;
                    }
                case 2: {
                        message.y = reader.uint32();
                        break;
                    }
                case 3: {
                        message.z = reader.uint32();
                        break;
                    }
                case 4: {
                        message.color = reader.uint32();
                        break;
                    }
                case 5: {
                        message.size = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.DebugInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.DebugInfo} DebugInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugInfo message.
         * @function verify
         * @memberof battle.DebugInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (!$util.isInteger(message.x))
                    return "x: integer expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (!$util.isInteger(message.y))
                    return "y: integer expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (!$util.isInteger(message.z))
                    return "z: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            return null;
        };

        /**
         * Creates a DebugInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.DebugInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.DebugInfo} DebugInfo
         */
        DebugInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.DebugInfo)
                return object;
            var message = new $root.battle.DebugInfo();
            if (object.x != null)
                message.x = object.x >>> 0;
            if (object.y != null)
                message.y = object.y >>> 0;
            if (object.z != null)
                message.z = object.z >>> 0;
            if (object.color != null)
                message.color = object.color >>> 0;
            if (object.size != null)
                message.size = object.size >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DebugInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.DebugInfo
         * @static
         * @param {battle.DebugInfo} message DebugInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.color = 0;
                object.size = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = message.z;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            return object;
        };

        /**
         * Converts this DebugInfo to JSON.
         * @function toJSON
         * @memberof battle.DebugInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DebugInfo
         * @function getTypeUrl
         * @memberof battle.DebugInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DebugInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.DebugInfo";
        };

        return DebugInfo;
    })();

    battle.notify_debug = (function() {

        /**
         * Properties of a notify_debug.
         * @memberof battle
         * @interface Inotify_debug
         * @property {Array.<battle.IDebugInfo>|null} [infos] notify_debug infos
         * @property {Array.<string>|null} [logs] notify_debug logs
         */

        /**
         * Constructs a new notify_debug.
         * @memberof battle
         * @classdesc Represents a notify_debug.
         * @implements Inotify_debug
         * @constructor
         * @param {battle.Inotify_debug=} [properties] Properties to set
         */
        function notify_debug(properties) {
            this.infos = [];
            this.logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_debug infos.
         * @member {Array.<battle.IDebugInfo>} infos
         * @memberof battle.notify_debug
         * @instance
         */
        notify_debug.prototype.infos = $util.emptyArray;

        /**
         * notify_debug logs.
         * @member {Array.<string>} logs
         * @memberof battle.notify_debug
         * @instance
         */
        notify_debug.prototype.logs = $util.emptyArray;

        /**
         * Creates a new notify_debug instance using the specified properties.
         * @function create
         * @memberof battle.notify_debug
         * @static
         * @param {battle.Inotify_debug=} [properties] Properties to set
         * @returns {battle.notify_debug} notify_debug instance
         */
        notify_debug.create = function create(properties) {
            return new notify_debug(properties);
        };

        /**
         * Encodes the specified notify_debug message. Does not implicitly {@link battle.notify_debug.verify|verify} messages.
         * @function encode
         * @memberof battle.notify_debug
         * @static
         * @param {battle.Inotify_debug} message notify_debug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_debug.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.battle.DebugInfo.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.logs != null && message.logs.length)
                for (var i = 0; i < message.logs.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.logs[i]);
            return writer;
        };

        /**
         * Encodes the specified notify_debug message, length delimited. Does not implicitly {@link battle.notify_debug.verify|verify} messages.
         * @function encodeDelimited
         * @memberof battle.notify_debug
         * @static
         * @param {battle.Inotify_debug} message notify_debug message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_debug.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_debug message from the specified reader or buffer.
         * @function decode
         * @memberof battle.notify_debug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {battle.notify_debug} notify_debug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_debug.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.battle.notify_debug();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.infos && message.infos.length))
                            message.infos = [];
                        message.infos.push($root.battle.DebugInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.logs && message.logs.length))
                            message.logs = [];
                        message.logs.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_debug message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof battle.notify_debug
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {battle.notify_debug} notify_debug
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_debug.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_debug message.
         * @function verify
         * @memberof battle.notify_debug
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_debug.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.battle.DebugInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.logs != null && message.hasOwnProperty("logs")) {
                if (!Array.isArray(message.logs))
                    return "logs: array expected";
                for (var i = 0; i < message.logs.length; ++i)
                    if (!$util.isString(message.logs[i]))
                        return "logs: string[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_debug message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof battle.notify_debug
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {battle.notify_debug} notify_debug
         */
        notify_debug.fromObject = function fromObject(object) {
            if (object instanceof $root.battle.notify_debug)
                return object;
            var message = new $root.battle.notify_debug();
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".battle.notify_debug.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".battle.notify_debug.infos: object expected");
                    message.infos[i] = $root.battle.DebugInfo.fromObject(object.infos[i]);
                }
            }
            if (object.logs) {
                if (!Array.isArray(object.logs))
                    throw TypeError(".battle.notify_debug.logs: array expected");
                message.logs = [];
                for (var i = 0; i < object.logs.length; ++i)
                    message.logs[i] = String(object.logs[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_debug message. Also converts values to other types if specified.
         * @function toObject
         * @memberof battle.notify_debug
         * @static
         * @param {battle.notify_debug} message notify_debug
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_debug.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.infos = [];
                object.logs = [];
            }
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.battle.DebugInfo.toObject(message.infos[j], options);
            }
            if (message.logs && message.logs.length) {
                object.logs = [];
                for (var j = 0; j < message.logs.length; ++j)
                    object.logs[j] = message.logs[j];
            }
            return object;
        };

        /**
         * Converts this notify_debug to JSON.
         * @function toJSON
         * @memberof battle.notify_debug
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_debug.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_debug
         * @function getTypeUrl
         * @memberof battle.notify_debug
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_debug.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/battle.notify_debug";
        };

        return notify_debug;
    })();

    return battle;
})();

$root.chat = (function() {

    /**
     * Namespace chat.
     * @exports chat
     * @namespace
     */
    var chat = {};

    chat.ChatRole = (function() {

        /**
         * Properties of a ChatRole.
         * @memberof chat
         * @interface IChatRole
         * @property {number|null} [rid] ChatRole rid
         * @property {number|null} [avatarId] ChatRole avatarId
         * @property {string|null} [avatarUrl] ChatRole avatarUrl
         * @property {string|null} [name] ChatRole name
         */

        /**
         * Constructs a new ChatRole.
         * @memberof chat
         * @classdesc Represents a ChatRole.
         * @implements IChatRole
         * @constructor
         * @param {chat.IChatRole=} [properties] Properties to set
         */
        function ChatRole(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatRole rid.
         * @member {number} rid
         * @memberof chat.ChatRole
         * @instance
         */
        ChatRole.prototype.rid = 0;

        /**
         * ChatRole avatarId.
         * @member {number} avatarId
         * @memberof chat.ChatRole
         * @instance
         */
        ChatRole.prototype.avatarId = 0;

        /**
         * ChatRole avatarUrl.
         * @member {string} avatarUrl
         * @memberof chat.ChatRole
         * @instance
         */
        ChatRole.prototype.avatarUrl = "";

        /**
         * ChatRole name.
         * @member {string} name
         * @memberof chat.ChatRole
         * @instance
         */
        ChatRole.prototype.name = "";

        /**
         * Creates a new ChatRole instance using the specified properties.
         * @function create
         * @memberof chat.ChatRole
         * @static
         * @param {chat.IChatRole=} [properties] Properties to set
         * @returns {chat.ChatRole} ChatRole instance
         */
        ChatRole.create = function create(properties) {
            return new ChatRole(properties);
        };

        /**
         * Encodes the specified ChatRole message. Does not implicitly {@link chat.ChatRole.verify|verify} messages.
         * @function encode
         * @memberof chat.ChatRole
         * @static
         * @param {chat.IChatRole} message ChatRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatRole.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.avatarId != null && Object.hasOwnProperty.call(message, "avatarId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.avatarId);
            if (message.avatarUrl != null && Object.hasOwnProperty.call(message, "avatarUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarUrl);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified ChatRole message, length delimited. Does not implicitly {@link chat.ChatRole.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.ChatRole
         * @static
         * @param {chat.IChatRole} message ChatRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatRole.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatRole message from the specified reader or buffer.
         * @function decode
         * @memberof chat.ChatRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.ChatRole} ChatRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRole.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.ChatRole();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.avatarId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.avatarUrl = reader.string();
                        break;
                    }
                case 4: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatRole message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.ChatRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.ChatRole} ChatRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatRole.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatRole message.
         * @function verify
         * @memberof chat.ChatRole
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatRole.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                if (!$util.isInteger(message.avatarId))
                    return "avatarId: integer expected";
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                if (!$util.isString(message.avatarUrl))
                    return "avatarUrl: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a ChatRole message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.ChatRole
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.ChatRole} ChatRole
         */
        ChatRole.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.ChatRole)
                return object;
            var message = new $root.chat.ChatRole();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.avatarId != null)
                message.avatarId = object.avatarId >>> 0;
            if (object.avatarUrl != null)
                message.avatarUrl = String(object.avatarUrl);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a ChatRole message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.ChatRole
         * @static
         * @param {chat.ChatRole} message ChatRole
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatRole.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rid = 0;
                object.avatarId = 0;
                object.avatarUrl = "";
                object.name = "";
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.avatarId != null && message.hasOwnProperty("avatarId"))
                object.avatarId = message.avatarId;
            if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                object.avatarUrl = message.avatarUrl;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this ChatRole to JSON.
         * @function toJSON
         * @memberof chat.ChatRole
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatRole.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChatRole
         * @function getTypeUrl
         * @memberof chat.ChatRole
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChatRole.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.ChatRole";
        };

        return ChatRole;
    })();

    chat.ChatMessage = (function() {

        /**
         * Properties of a ChatMessage.
         * @memberof chat
         * @interface IChatMessage
         * @property {number|null} [rid] ChatMessage rid
         * @property {string|null} [text] ChatMessage text
         * @property {number|null} [time] ChatMessage time
         */

        /**
         * Constructs a new ChatMessage.
         * @memberof chat
         * @classdesc Represents a ChatMessage.
         * @implements IChatMessage
         * @constructor
         * @param {chat.IChatMessage=} [properties] Properties to set
         */
        function ChatMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatMessage rid.
         * @member {number} rid
         * @memberof chat.ChatMessage
         * @instance
         */
        ChatMessage.prototype.rid = 0;

        /**
         * ChatMessage text.
         * @member {string} text
         * @memberof chat.ChatMessage
         * @instance
         */
        ChatMessage.prototype.text = "";

        /**
         * ChatMessage time.
         * @member {number} time
         * @memberof chat.ChatMessage
         * @instance
         */
        ChatMessage.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChatMessage instance using the specified properties.
         * @function create
         * @memberof chat.ChatMessage
         * @static
         * @param {chat.IChatMessage=} [properties] Properties to set
         * @returns {chat.ChatMessage} ChatMessage instance
         */
        ChatMessage.create = function create(properties) {
            return new ChatMessage(properties);
        };

        /**
         * Encodes the specified ChatMessage message. Does not implicitly {@link chat.ChatMessage.verify|verify} messages.
         * @function encode
         * @memberof chat.ChatMessage
         * @static
         * @param {chat.IChatMessage} message ChatMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified ChatMessage message, length delimited. Does not implicitly {@link chat.ChatMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.ChatMessage
         * @static
         * @param {chat.IChatMessage} message ChatMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatMessage message from the specified reader or buffer.
         * @function decode
         * @memberof chat.ChatMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.ChatMessage} ChatMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.ChatMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.text = reader.string();
                        break;
                    }
                case 4: {
                        message.time = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.ChatMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.ChatMessage} ChatMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatMessage message.
         * @function verify
         * @memberof chat.ChatMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.ChatMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.ChatMessage} ChatMessage
         */
        ChatMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.ChatMessage)
                return object;
            var message = new $root.chat.ChatMessage();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.ChatMessage
         * @static
         * @param {chat.ChatMessage} message ChatMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rid = 0;
                object.text = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };

        /**
         * Converts this ChatMessage to JSON.
         * @function toJSON
         * @memberof chat.ChatMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChatMessage
         * @function getTypeUrl
         * @memberof chat.ChatMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChatMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.ChatMessage";
        };

        return ChatMessage;
    })();

    chat.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof chat
         * @interface Ic2s_load
         * @property {number|null} [channel] c2s_load channel
         */

        /**
         * Constructs a new c2s_load.
         * @memberof chat
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {chat.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load channel.
         * @member {number} channel
         * @memberof chat.c2s_load
         * @instance
         */
        c2s_load.prototype.channel = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof chat.c2s_load
         * @static
         * @param {chat.Ic2s_load=} [properties] Properties to set
         * @returns {chat.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link chat.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof chat.c2s_load
         * @static
         * @param {chat.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link chat.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.c2s_load
         * @static
         * @param {chat.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof chat.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.channel = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof chat.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.c2s_load)
                return object;
            var message = new $root.chat.c2s_load();
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.c2s_load
         * @static
         * @param {chat.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.channel = 0;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof chat.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof chat.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.c2s_load";
        };

        return c2s_load;
    })();

    chat.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof chat
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {number|null} [channel] s2c_load channel
         * @property {Array.<chat.IChatMessage>|null} [messages] s2c_load messages
         * @property {Array.<chat.IChatRole>|null} [chatRoles] s2c_load chatRoles
         */

        /**
         * Constructs a new s2c_load.
         * @memberof chat
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {chat.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.messages = [];
            this.chatRoles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof chat.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load channel.
         * @member {number} channel
         * @memberof chat.s2c_load
         * @instance
         */
        s2c_load.prototype.channel = 0;

        /**
         * s2c_load messages.
         * @member {Array.<chat.IChatMessage>} messages
         * @memberof chat.s2c_load
         * @instance
         */
        s2c_load.prototype.messages = $util.emptyArray;

        /**
         * s2c_load chatRoles.
         * @member {Array.<chat.IChatRole>} chatRoles
         * @memberof chat.s2c_load
         * @instance
         */
        s2c_load.prototype.chatRoles = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof chat.s2c_load
         * @static
         * @param {chat.Is2c_load=} [properties] Properties to set
         * @returns {chat.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link chat.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof chat.s2c_load
         * @static
         * @param {chat.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.channel);
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.chat.ChatMessage.encode(message.messages[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.chatRoles != null && message.chatRoles.length)
                for (var i = 0; i < message.chatRoles.length; ++i)
                    $root.chat.ChatRole.encode(message.chatRoles[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link chat.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.s2c_load
         * @static
         * @param {chat.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof chat.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.channel = reader.uint32();
                        break;
                    }
                case 3: {
                        if (!(message.messages && message.messages.length))
                            message.messages = [];
                        message.messages.push($root.chat.ChatMessage.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.chatRoles && message.chatRoles.length))
                            message.chatRoles = [];
                        message.chatRoles.push($root.chat.ChatRole.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof chat.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.chat.ChatMessage.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            if (message.chatRoles != null && message.hasOwnProperty("chatRoles")) {
                if (!Array.isArray(message.chatRoles))
                    return "chatRoles: array expected";
                for (var i = 0; i < message.chatRoles.length; ++i) {
                    var error = $root.chat.ChatRole.verify(message.chatRoles[i]);
                    if (error)
                        return "chatRoles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.s2c_load)
                return object;
            var message = new $root.chat.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".chat.s2c_load.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".chat.s2c_load.messages: object expected");
                    message.messages[i] = $root.chat.ChatMessage.fromObject(object.messages[i]);
                }
            }
            if (object.chatRoles) {
                if (!Array.isArray(object.chatRoles))
                    throw TypeError(".chat.s2c_load.chatRoles: array expected");
                message.chatRoles = [];
                for (var i = 0; i < object.chatRoles.length; ++i) {
                    if (typeof object.chatRoles[i] !== "object")
                        throw TypeError(".chat.s2c_load.chatRoles: object expected");
                    message.chatRoles[i] = $root.chat.ChatRole.fromObject(object.chatRoles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.s2c_load
         * @static
         * @param {chat.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.messages = [];
                object.chatRoles = [];
            }
            if (options.defaults) {
                object.err = 0;
                object.channel = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.chat.ChatMessage.toObject(message.messages[j], options);
            }
            if (message.chatRoles && message.chatRoles.length) {
                object.chatRoles = [];
                for (var j = 0; j < message.chatRoles.length; ++j)
                    object.chatRoles[j] = $root.chat.ChatRole.toObject(message.chatRoles[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof chat.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof chat.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.s2c_load";
        };

        return s2c_load;
    })();

    chat.c2s_send = (function() {

        /**
         * Properties of a c2s_send.
         * @memberof chat
         * @interface Ic2s_send
         * @property {number|null} [channel] c2s_send channel
         * @property {string|null} [text] c2s_send text
         */

        /**
         * Constructs a new c2s_send.
         * @memberof chat
         * @classdesc Represents a c2s_send.
         * @implements Ic2s_send
         * @constructor
         * @param {chat.Ic2s_send=} [properties] Properties to set
         */
        function c2s_send(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_send channel.
         * @member {number} channel
         * @memberof chat.c2s_send
         * @instance
         */
        c2s_send.prototype.channel = 0;

        /**
         * c2s_send text.
         * @member {string} text
         * @memberof chat.c2s_send
         * @instance
         */
        c2s_send.prototype.text = "";

        /**
         * Creates a new c2s_send instance using the specified properties.
         * @function create
         * @memberof chat.c2s_send
         * @static
         * @param {chat.Ic2s_send=} [properties] Properties to set
         * @returns {chat.c2s_send} c2s_send instance
         */
        c2s_send.create = function create(properties) {
            return new c2s_send(properties);
        };

        /**
         * Encodes the specified c2s_send message. Does not implicitly {@link chat.c2s_send.verify|verify} messages.
         * @function encode
         * @memberof chat.c2s_send
         * @static
         * @param {chat.Ic2s_send} message c2s_send message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_send.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified c2s_send message, length delimited. Does not implicitly {@link chat.c2s_send.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.c2s_send
         * @static
         * @param {chat.Ic2s_send} message c2s_send message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_send.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_send message from the specified reader or buffer.
         * @function decode
         * @memberof chat.c2s_send
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.c2s_send} c2s_send
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_send.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.c2s_send();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.channel = reader.uint32();
                        break;
                    }
                case 2: {
                        message.text = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_send message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.c2s_send
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.c2s_send} c2s_send
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_send.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_send message.
         * @function verify
         * @memberof chat.c2s_send
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_send.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates a c2s_send message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.c2s_send
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.c2s_send} c2s_send
         */
        c2s_send.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.c2s_send)
                return object;
            var message = new $root.chat.c2s_send();
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from a c2s_send message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.c2s_send
         * @static
         * @param {chat.c2s_send} message c2s_send
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_send.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channel = 0;
                object.text = "";
            }
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this c2s_send to JSON.
         * @function toJSON
         * @memberof chat.c2s_send
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_send.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_send
         * @function getTypeUrl
         * @memberof chat.c2s_send
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_send.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.c2s_send";
        };

        return c2s_send;
    })();

    chat.s2c_send = (function() {

        /**
         * Properties of a s2c_send.
         * @memberof chat
         * @interface Is2c_send
         * @property {number|null} [err] s2c_send err
         */

        /**
         * Constructs a new s2c_send.
         * @memberof chat
         * @classdesc Represents a s2c_send.
         * @implements Is2c_send
         * @constructor
         * @param {chat.Is2c_send=} [properties] Properties to set
         */
        function s2c_send(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_send err.
         * @member {number} err
         * @memberof chat.s2c_send
         * @instance
         */
        s2c_send.prototype.err = 0;

        /**
         * Creates a new s2c_send instance using the specified properties.
         * @function create
         * @memberof chat.s2c_send
         * @static
         * @param {chat.Is2c_send=} [properties] Properties to set
         * @returns {chat.s2c_send} s2c_send instance
         */
        s2c_send.create = function create(properties) {
            return new s2c_send(properties);
        };

        /**
         * Encodes the specified s2c_send message. Does not implicitly {@link chat.s2c_send.verify|verify} messages.
         * @function encode
         * @memberof chat.s2c_send
         * @static
         * @param {chat.Is2c_send} message s2c_send message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_send.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_send message, length delimited. Does not implicitly {@link chat.s2c_send.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.s2c_send
         * @static
         * @param {chat.Is2c_send} message s2c_send message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_send.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_send message from the specified reader or buffer.
         * @function decode
         * @memberof chat.s2c_send
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.s2c_send} s2c_send
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_send.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.s2c_send();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_send message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.s2c_send
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.s2c_send} s2c_send
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_send.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_send message.
         * @function verify
         * @memberof chat.s2c_send
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_send.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_send message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.s2c_send
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.s2c_send} s2c_send
         */
        s2c_send.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.s2c_send)
                return object;
            var message = new $root.chat.s2c_send();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_send message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.s2c_send
         * @static
         * @param {chat.s2c_send} message s2c_send
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_send.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_send to JSON.
         * @function toJSON
         * @memberof chat.s2c_send
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_send.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_send
         * @function getTypeUrl
         * @memberof chat.s2c_send
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_send.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.s2c_send";
        };

        return s2c_send;
    })();

    chat.notify = (function() {

        /**
         * Properties of a notify.
         * @memberof chat
         * @interface Inotify
         * @property {number|null} [channel] notify channel
         * @property {Array.<chat.IChatMessage>|null} [messages] notify messages
         * @property {Array.<chat.IChatRole>|null} [chatRoles] notify chatRoles
         */

        /**
         * Constructs a new notify.
         * @memberof chat
         * @classdesc Represents a notify.
         * @implements Inotify
         * @constructor
         * @param {chat.Inotify=} [properties] Properties to set
         */
        function notify(properties) {
            this.messages = [];
            this.chatRoles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify channel.
         * @member {number} channel
         * @memberof chat.notify
         * @instance
         */
        notify.prototype.channel = 0;

        /**
         * notify messages.
         * @member {Array.<chat.IChatMessage>} messages
         * @memberof chat.notify
         * @instance
         */
        notify.prototype.messages = $util.emptyArray;

        /**
         * notify chatRoles.
         * @member {Array.<chat.IChatRole>} chatRoles
         * @memberof chat.notify
         * @instance
         */
        notify.prototype.chatRoles = $util.emptyArray;

        /**
         * Creates a new notify instance using the specified properties.
         * @function create
         * @memberof chat.notify
         * @static
         * @param {chat.Inotify=} [properties] Properties to set
         * @returns {chat.notify} notify instance
         */
        notify.create = function create(properties) {
            return new notify(properties);
        };

        /**
         * Encodes the specified notify message. Does not implicitly {@link chat.notify.verify|verify} messages.
         * @function encode
         * @memberof chat.notify
         * @static
         * @param {chat.Inotify} message notify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channel);
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.chat.ChatMessage.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.chatRoles != null && message.chatRoles.length)
                for (var i = 0; i < message.chatRoles.length; ++i)
                    $root.chat.ChatRole.encode(message.chatRoles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify message, length delimited. Does not implicitly {@link chat.notify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chat.notify
         * @static
         * @param {chat.Inotify} message notify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify message from the specified reader or buffer.
         * @function decode
         * @memberof chat.notify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chat.notify} notify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chat.notify();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.channel = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.messages && message.messages.length))
                            message.messages = [];
                        message.messages.push($root.chat.ChatMessage.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.chatRoles && message.chatRoles.length))
                            message.chatRoles = [];
                        message.chatRoles.push($root.chat.ChatRole.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chat.notify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chat.notify} notify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify message.
         * @function verify
         * @memberof chat.notify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.chat.ChatMessage.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            if (message.chatRoles != null && message.hasOwnProperty("chatRoles")) {
                if (!Array.isArray(message.chatRoles))
                    return "chatRoles: array expected";
                for (var i = 0; i < message.chatRoles.length; ++i) {
                    var error = $root.chat.ChatRole.verify(message.chatRoles[i]);
                    if (error)
                        return "chatRoles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chat.notify
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chat.notify} notify
         */
        notify.fromObject = function fromObject(object) {
            if (object instanceof $root.chat.notify)
                return object;
            var message = new $root.chat.notify();
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".chat.notify.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".chat.notify.messages: object expected");
                    message.messages[i] = $root.chat.ChatMessage.fromObject(object.messages[i]);
                }
            }
            if (object.chatRoles) {
                if (!Array.isArray(object.chatRoles))
                    throw TypeError(".chat.notify.chatRoles: array expected");
                message.chatRoles = [];
                for (var i = 0; i < object.chatRoles.length; ++i) {
                    if (typeof object.chatRoles[i] !== "object")
                        throw TypeError(".chat.notify.chatRoles: object expected");
                    message.chatRoles[i] = $root.chat.ChatRole.fromObject(object.chatRoles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chat.notify
         * @static
         * @param {chat.notify} message notify
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.messages = [];
                object.chatRoles = [];
            }
            if (options.defaults)
                object.channel = 0;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.chat.ChatMessage.toObject(message.messages[j], options);
            }
            if (message.chatRoles && message.chatRoles.length) {
                object.chatRoles = [];
                for (var j = 0; j < message.chatRoles.length; ++j)
                    object.chatRoles[j] = $root.chat.ChatRole.toObject(message.chatRoles[j], options);
            }
            return object;
        };

        /**
         * Converts this notify to JSON.
         * @function toJSON
         * @memberof chat.notify
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify
         * @function getTypeUrl
         * @memberof chat.notify
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chat.notify";
        };

        return notify;
    })();

    return chat;
})();

$root.chest = (function() {

    /**
     * Namespace chest.
     * @exports chest
     * @namespace
     */
    var chest = {};

    chest.ChestInfo = (function() {

        /**
         * Properties of a ChestInfo.
         * @memberof chest
         * @interface IChestInfo
         * @property {number|null} [id] ChestInfo id
         * @property {number|null} [num] ChestInfo num
         */

        /**
         * Constructs a new ChestInfo.
         * @memberof chest
         * @classdesc Represents a ChestInfo.
         * @implements IChestInfo
         * @constructor
         * @param {chest.IChestInfo=} [properties] Properties to set
         */
        function ChestInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChestInfo id.
         * @member {number} id
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.id = 0;

        /**
         * ChestInfo num.
         * @member {number} num
         * @memberof chest.ChestInfo
         * @instance
         */
        ChestInfo.prototype.num = 0;

        /**
         * Creates a new ChestInfo instance using the specified properties.
         * @function create
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.IChestInfo=} [properties] Properties to set
         * @returns {chest.ChestInfo} ChestInfo instance
         */
        ChestInfo.create = function create(properties) {
            return new ChestInfo(properties);
        };

        /**
         * Encodes the specified ChestInfo message. Does not implicitly {@link chest.ChestInfo.verify|verify} messages.
         * @function encode
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.IChestInfo} message ChestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChestInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified ChestInfo message, length delimited. Does not implicitly {@link chest.ChestInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.IChestInfo} message ChestInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChestInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChestInfo message from the specified reader or buffer.
         * @function decode
         * @memberof chest.ChestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.ChestInfo} ChestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChestInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.ChestInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChestInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.ChestInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.ChestInfo} ChestInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChestInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChestInfo message.
         * @function verify
         * @memberof chest.ChestInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChestInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a ChestInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.ChestInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.ChestInfo} ChestInfo
         */
        ChestInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.ChestInfo)
                return object;
            var message = new $root.chest.ChestInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChestInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.ChestInfo
         * @static
         * @param {chest.ChestInfo} message ChestInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChestInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this ChestInfo to JSON.
         * @function toJSON
         * @memberof chest.ChestInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChestInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChestInfo
         * @function getTypeUrl
         * @memberof chest.ChestInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChestInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.ChestInfo";
        };

        return ChestInfo;
    })();

    chest.ScoreInfo = (function() {

        /**
         * Properties of a ScoreInfo.
         * @memberof chest
         * @interface IScoreInfo
         * @property {number|null} [score] ScoreInfo score
         * @property {number|null} [scoreId] ScoreInfo scoreId
         */

        /**
         * Constructs a new ScoreInfo.
         * @memberof chest
         * @classdesc Represents a ScoreInfo.
         * @implements IScoreInfo
         * @constructor
         * @param {chest.IScoreInfo=} [properties] Properties to set
         */
        function ScoreInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ScoreInfo score.
         * @member {number} score
         * @memberof chest.ScoreInfo
         * @instance
         */
        ScoreInfo.prototype.score = 0;

        /**
         * ScoreInfo scoreId.
         * @member {number} scoreId
         * @memberof chest.ScoreInfo
         * @instance
         */
        ScoreInfo.prototype.scoreId = 0;

        /**
         * Creates a new ScoreInfo instance using the specified properties.
         * @function create
         * @memberof chest.ScoreInfo
         * @static
         * @param {chest.IScoreInfo=} [properties] Properties to set
         * @returns {chest.ScoreInfo} ScoreInfo instance
         */
        ScoreInfo.create = function create(properties) {
            return new ScoreInfo(properties);
        };

        /**
         * Encodes the specified ScoreInfo message. Does not implicitly {@link chest.ScoreInfo.verify|verify} messages.
         * @function encode
         * @memberof chest.ScoreInfo
         * @static
         * @param {chest.IScoreInfo} message ScoreInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScoreInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.score);
            if (message.scoreId != null && Object.hasOwnProperty.call(message, "scoreId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.scoreId);
            return writer;
        };

        /**
         * Encodes the specified ScoreInfo message, length delimited. Does not implicitly {@link chest.ScoreInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.ScoreInfo
         * @static
         * @param {chest.IScoreInfo} message ScoreInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScoreInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ScoreInfo message from the specified reader or buffer.
         * @function decode
         * @memberof chest.ScoreInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.ScoreInfo} ScoreInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScoreInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.ScoreInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4: {
                        message.score = reader.uint32();
                        break;
                    }
                case 5: {
                        message.scoreId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ScoreInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.ScoreInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.ScoreInfo} ScoreInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScoreInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ScoreInfo message.
         * @function verify
         * @memberof chest.ScoreInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ScoreInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.scoreId != null && message.hasOwnProperty("scoreId"))
                if (!$util.isInteger(message.scoreId))
                    return "scoreId: integer expected";
            return null;
        };

        /**
         * Creates a ScoreInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.ScoreInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.ScoreInfo} ScoreInfo
         */
        ScoreInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.ScoreInfo)
                return object;
            var message = new $root.chest.ScoreInfo();
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.scoreId != null)
                message.scoreId = object.scoreId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ScoreInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.ScoreInfo
         * @static
         * @param {chest.ScoreInfo} message ScoreInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ScoreInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.score = 0;
                object.scoreId = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.scoreId != null && message.hasOwnProperty("scoreId"))
                object.scoreId = message.scoreId;
            return object;
        };

        /**
         * Converts this ScoreInfo to JSON.
         * @function toJSON
         * @memberof chest.ScoreInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ScoreInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ScoreInfo
         * @function getTypeUrl
         * @memberof chest.ScoreInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ScoreInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.ScoreInfo";
        };

        return ScoreInfo;
    })();

    chest.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof chest
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof chest
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {chest.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof chest.c2s_load
         * @static
         * @param {chest.Ic2s_load=} [properties] Properties to set
         * @returns {chest.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link chest.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_load
         * @static
         * @param {chest.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link chest.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_load
         * @static
         * @param {chest.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof chest.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_load)
                return object;
            return new $root.chest.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_load
         * @static
         * @param {chest.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof chest.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof chest.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_load";
        };

        return c2s_load;
    })();

    chest.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof chest
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {number|null} [heroId] s2c_load heroId
         * @property {Array.<chest.IChestInfo>|null} [chests] s2c_load chests
         * @property {chest.IScoreInfo|null} [score] s2c_load score
         * @property {Array.<number>|null} [heroIds] s2c_load heroIds
         */

        /**
         * Constructs a new s2c_load.
         * @memberof chest
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {chest.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.chests = [];
            this.heroIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load heroId.
         * @member {number} heroId
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.heroId = 0;

        /**
         * s2c_load chests.
         * @member {Array.<chest.IChestInfo>} chests
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.chests = $util.emptyArray;

        /**
         * s2c_load score.
         * @member {chest.IScoreInfo|null|undefined} score
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.score = null;

        /**
         * s2c_load heroIds.
         * @member {Array.<number>} heroIds
         * @memberof chest.s2c_load
         * @instance
         */
        s2c_load.prototype.heroIds = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof chest.s2c_load
         * @static
         * @param {chest.Is2c_load=} [properties] Properties to set
         * @returns {chest.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link chest.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_load
         * @static
         * @param {chest.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.heroId);
            if (message.chests != null && message.chests.length)
                for (var i = 0; i < message.chests.length; ++i)
                    $root.chest.ChestInfo.encode(message.chests[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                $root.chest.ScoreInfo.encode(message.score, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.heroIds != null && message.heroIds.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.heroIds.length; ++i)
                    writer.uint32(message.heroIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link chest.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_load
         * @static
         * @param {chest.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.heroId = reader.uint32();
                        break;
                    }
                case 3: {
                        if (!(message.chests && message.chests.length))
                            message.chests = [];
                        message.chests.push($root.chest.ChestInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.score = $root.chest.ScoreInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.heroIds && message.heroIds.length))
                            message.heroIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.heroIds.push(reader.uint32());
                        } else
                            message.heroIds.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof chest.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.chests != null && message.hasOwnProperty("chests")) {
                if (!Array.isArray(message.chests))
                    return "chests: array expected";
                for (var i = 0; i < message.chests.length; ++i) {
                    var error = $root.chest.ChestInfo.verify(message.chests[i]);
                    if (error)
                        return "chests." + error;
                }
            }
            if (message.score != null && message.hasOwnProperty("score")) {
                var error = $root.chest.ScoreInfo.verify(message.score);
                if (error)
                    return "score." + error;
            }
            if (message.heroIds != null && message.hasOwnProperty("heroIds")) {
                if (!Array.isArray(message.heroIds))
                    return "heroIds: array expected";
                for (var i = 0; i < message.heroIds.length; ++i)
                    if (!$util.isInteger(message.heroIds[i]))
                        return "heroIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_load)
                return object;
            var message = new $root.chest.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.heroId != null)
                message.heroId = object.heroId >>> 0;
            if (object.chests) {
                if (!Array.isArray(object.chests))
                    throw TypeError(".chest.s2c_load.chests: array expected");
                message.chests = [];
                for (var i = 0; i < object.chests.length; ++i) {
                    if (typeof object.chests[i] !== "object")
                        throw TypeError(".chest.s2c_load.chests: object expected");
                    message.chests[i] = $root.chest.ChestInfo.fromObject(object.chests[i]);
                }
            }
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".chest.s2c_load.score: object expected");
                message.score = $root.chest.ScoreInfo.fromObject(object.score);
            }
            if (object.heroIds) {
                if (!Array.isArray(object.heroIds))
                    throw TypeError(".chest.s2c_load.heroIds: array expected");
                message.heroIds = [];
                for (var i = 0; i < object.heroIds.length; ++i)
                    message.heroIds[i] = object.heroIds[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_load
         * @static
         * @param {chest.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.chests = [];
                object.heroIds = [];
            }
            if (options.defaults) {
                object.err = 0;
                object.heroId = 0;
                object.score = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.chests && message.chests.length) {
                object.chests = [];
                for (var j = 0; j < message.chests.length; ++j)
                    object.chests[j] = $root.chest.ChestInfo.toObject(message.chests[j], options);
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = $root.chest.ScoreInfo.toObject(message.score, options);
            if (message.heroIds && message.heroIds.length) {
                object.heroIds = [];
                for (var j = 0; j < message.heroIds.length; ++j)
                    object.heroIds[j] = message.heroIds[j];
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof chest.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof chest.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_load";
        };

        return s2c_load;
    })();

    chest.c2s_open_chest = (function() {

        /**
         * Properties of a c2s_open_chest.
         * @memberof chest
         * @interface Ic2s_open_chest
         * @property {number|null} [id] c2s_open_chest id
         */

        /**
         * Constructs a new c2s_open_chest.
         * @memberof chest
         * @classdesc Represents a c2s_open_chest.
         * @implements Ic2s_open_chest
         * @constructor
         * @param {chest.Ic2s_open_chest=} [properties] Properties to set
         */
        function c2s_open_chest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_open_chest id.
         * @member {number} id
         * @memberof chest.c2s_open_chest
         * @instance
         */
        c2s_open_chest.prototype.id = 0;

        /**
         * Creates a new c2s_open_chest instance using the specified properties.
         * @function create
         * @memberof chest.c2s_open_chest
         * @static
         * @param {chest.Ic2s_open_chest=} [properties] Properties to set
         * @returns {chest.c2s_open_chest} c2s_open_chest instance
         */
        c2s_open_chest.create = function create(properties) {
            return new c2s_open_chest(properties);
        };

        /**
         * Encodes the specified c2s_open_chest message. Does not implicitly {@link chest.c2s_open_chest.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_open_chest
         * @static
         * @param {chest.Ic2s_open_chest} message c2s_open_chest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_open_chest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified c2s_open_chest message, length delimited. Does not implicitly {@link chest.c2s_open_chest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_open_chest
         * @static
         * @param {chest.Ic2s_open_chest} message c2s_open_chest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_open_chest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_open_chest message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_open_chest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_open_chest} c2s_open_chest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_open_chest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_open_chest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_open_chest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_open_chest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_open_chest} c2s_open_chest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_open_chest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_open_chest message.
         * @function verify
         * @memberof chest.c2s_open_chest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_open_chest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a c2s_open_chest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_open_chest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_open_chest} c2s_open_chest
         */
        c2s_open_chest.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_open_chest)
                return object;
            var message = new $root.chest.c2s_open_chest();
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_open_chest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_open_chest
         * @static
         * @param {chest.c2s_open_chest} message c2s_open_chest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_open_chest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this c2s_open_chest to JSON.
         * @function toJSON
         * @memberof chest.c2s_open_chest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_open_chest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_open_chest
         * @function getTypeUrl
         * @memberof chest.c2s_open_chest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_open_chest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_open_chest";
        };

        return c2s_open_chest;
    })();

    chest.s2c_open_chest = (function() {

        /**
         * Properties of a s2c_open_chest.
         * @memberof chest
         * @interface Is2c_open_chest
         * @property {number|null} [err] s2c_open_chest err
         * @property {chest.IChestInfo|null} [chest] s2c_open_chest chest
         * @property {chest.IScoreInfo|null} [score] s2c_open_chest score
         * @property {Array.<bag.IItem>|null} [rewards] s2c_open_chest rewards
         */

        /**
         * Constructs a new s2c_open_chest.
         * @memberof chest
         * @classdesc Represents a s2c_open_chest.
         * @implements Is2c_open_chest
         * @constructor
         * @param {chest.Is2c_open_chest=} [properties] Properties to set
         */
        function s2c_open_chest(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_open_chest err.
         * @member {number} err
         * @memberof chest.s2c_open_chest
         * @instance
         */
        s2c_open_chest.prototype.err = 0;

        /**
         * s2c_open_chest chest.
         * @member {chest.IChestInfo|null|undefined} chest
         * @memberof chest.s2c_open_chest
         * @instance
         */
        s2c_open_chest.prototype.chest = null;

        /**
         * s2c_open_chest score.
         * @member {chest.IScoreInfo|null|undefined} score
         * @memberof chest.s2c_open_chest
         * @instance
         */
        s2c_open_chest.prototype.score = null;

        /**
         * s2c_open_chest rewards.
         * @member {Array.<bag.IItem>} rewards
         * @memberof chest.s2c_open_chest
         * @instance
         */
        s2c_open_chest.prototype.rewards = $util.emptyArray;

        /**
         * Creates a new s2c_open_chest instance using the specified properties.
         * @function create
         * @memberof chest.s2c_open_chest
         * @static
         * @param {chest.Is2c_open_chest=} [properties] Properties to set
         * @returns {chest.s2c_open_chest} s2c_open_chest instance
         */
        s2c_open_chest.create = function create(properties) {
            return new s2c_open_chest(properties);
        };

        /**
         * Encodes the specified s2c_open_chest message. Does not implicitly {@link chest.s2c_open_chest.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_open_chest
         * @static
         * @param {chest.Is2c_open_chest} message s2c_open_chest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_open_chest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.chest != null && Object.hasOwnProperty.call(message, "chest"))
                $root.chest.ChestInfo.encode(message.chest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                $root.chest.ScoreInfo.encode(message.score, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.bag.Item.encode(message.rewards[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_open_chest message, length delimited. Does not implicitly {@link chest.s2c_open_chest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_open_chest
         * @static
         * @param {chest.Is2c_open_chest} message s2c_open_chest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_open_chest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_open_chest message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_open_chest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_open_chest} s2c_open_chest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_open_chest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_open_chest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.chest = $root.chest.ChestInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.score = $root.chest.ScoreInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.rewards && message.rewards.length))
                            message.rewards = [];
                        message.rewards.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_open_chest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_open_chest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_open_chest} s2c_open_chest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_open_chest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_open_chest message.
         * @function verify
         * @memberof chest.s2c_open_chest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_open_chest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.chest != null && message.hasOwnProperty("chest")) {
                var error = $root.chest.ChestInfo.verify(message.chest);
                if (error)
                    return "chest." + error;
            }
            if (message.score != null && message.hasOwnProperty("score")) {
                var error = $root.chest.ScoreInfo.verify(message.score);
                if (error)
                    return "score." + error;
            }
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.bag.Item.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_open_chest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_open_chest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_open_chest} s2c_open_chest
         */
        s2c_open_chest.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_open_chest)
                return object;
            var message = new $root.chest.s2c_open_chest();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.chest != null) {
                if (typeof object.chest !== "object")
                    throw TypeError(".chest.s2c_open_chest.chest: object expected");
                message.chest = $root.chest.ChestInfo.fromObject(object.chest);
            }
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".chest.s2c_open_chest.score: object expected");
                message.score = $root.chest.ScoreInfo.fromObject(object.score);
            }
            if (object.rewards) {
                if (!Array.isArray(object.rewards))
                    throw TypeError(".chest.s2c_open_chest.rewards: array expected");
                message.rewards = [];
                for (var i = 0; i < object.rewards.length; ++i) {
                    if (typeof object.rewards[i] !== "object")
                        throw TypeError(".chest.s2c_open_chest.rewards: object expected");
                    message.rewards[i] = $root.bag.Item.fromObject(object.rewards[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_open_chest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_open_chest
         * @static
         * @param {chest.s2c_open_chest} message s2c_open_chest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_open_chest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rewards = [];
            if (options.defaults) {
                object.err = 0;
                object.chest = null;
                object.score = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.chest != null && message.hasOwnProperty("chest"))
                object.chest = $root.chest.ChestInfo.toObject(message.chest, options);
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = $root.chest.ScoreInfo.toObject(message.score, options);
            if (message.rewards && message.rewards.length) {
                object.rewards = [];
                for (var j = 0; j < message.rewards.length; ++j)
                    object.rewards[j] = $root.bag.Item.toObject(message.rewards[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_open_chest to JSON.
         * @function toJSON
         * @memberof chest.s2c_open_chest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_open_chest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_open_chest
         * @function getTypeUrl
         * @memberof chest.s2c_open_chest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_open_chest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_open_chest";
        };

        return s2c_open_chest;
    })();

    chest.c2s_score_receive = (function() {

        /**
         * Properties of a c2s_score_receive.
         * @memberof chest
         * @interface Ic2s_score_receive
         */

        /**
         * Constructs a new c2s_score_receive.
         * @memberof chest
         * @classdesc Represents a c2s_score_receive.
         * @implements Ic2s_score_receive
         * @constructor
         * @param {chest.Ic2s_score_receive=} [properties] Properties to set
         */
        function c2s_score_receive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_score_receive instance using the specified properties.
         * @function create
         * @memberof chest.c2s_score_receive
         * @static
         * @param {chest.Ic2s_score_receive=} [properties] Properties to set
         * @returns {chest.c2s_score_receive} c2s_score_receive instance
         */
        c2s_score_receive.create = function create(properties) {
            return new c2s_score_receive(properties);
        };

        /**
         * Encodes the specified c2s_score_receive message. Does not implicitly {@link chest.c2s_score_receive.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_score_receive
         * @static
         * @param {chest.Ic2s_score_receive} message c2s_score_receive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_score_receive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_score_receive message, length delimited. Does not implicitly {@link chest.c2s_score_receive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_score_receive
         * @static
         * @param {chest.Ic2s_score_receive} message c2s_score_receive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_score_receive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_score_receive message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_score_receive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_score_receive} c2s_score_receive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_score_receive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_score_receive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_score_receive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_score_receive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_score_receive} c2s_score_receive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_score_receive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_score_receive message.
         * @function verify
         * @memberof chest.c2s_score_receive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_score_receive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_score_receive message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_score_receive
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_score_receive} c2s_score_receive
         */
        c2s_score_receive.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_score_receive)
                return object;
            return new $root.chest.c2s_score_receive();
        };

        /**
         * Creates a plain object from a c2s_score_receive message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_score_receive
         * @static
         * @param {chest.c2s_score_receive} message c2s_score_receive
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_score_receive.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_score_receive to JSON.
         * @function toJSON
         * @memberof chest.c2s_score_receive
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_score_receive.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_score_receive
         * @function getTypeUrl
         * @memberof chest.c2s_score_receive
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_score_receive.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_score_receive";
        };

        return c2s_score_receive;
    })();

    chest.s2c_score_receive = (function() {

        /**
         * Properties of a s2c_score_receive.
         * @memberof chest
         * @interface Is2c_score_receive
         * @property {number|null} [err] s2c_score_receive err
         * @property {chest.IScoreInfo|null} [score] s2c_score_receive score
         */

        /**
         * Constructs a new s2c_score_receive.
         * @memberof chest
         * @classdesc Represents a s2c_score_receive.
         * @implements Is2c_score_receive
         * @constructor
         * @param {chest.Is2c_score_receive=} [properties] Properties to set
         */
        function s2c_score_receive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_score_receive err.
         * @member {number} err
         * @memberof chest.s2c_score_receive
         * @instance
         */
        s2c_score_receive.prototype.err = 0;

        /**
         * s2c_score_receive score.
         * @member {chest.IScoreInfo|null|undefined} score
         * @memberof chest.s2c_score_receive
         * @instance
         */
        s2c_score_receive.prototype.score = null;

        /**
         * Creates a new s2c_score_receive instance using the specified properties.
         * @function create
         * @memberof chest.s2c_score_receive
         * @static
         * @param {chest.Is2c_score_receive=} [properties] Properties to set
         * @returns {chest.s2c_score_receive} s2c_score_receive instance
         */
        s2c_score_receive.create = function create(properties) {
            return new s2c_score_receive(properties);
        };

        /**
         * Encodes the specified s2c_score_receive message. Does not implicitly {@link chest.s2c_score_receive.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_score_receive
         * @static
         * @param {chest.Is2c_score_receive} message s2c_score_receive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_score_receive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                $root.chest.ScoreInfo.encode(message.score, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_score_receive message, length delimited. Does not implicitly {@link chest.s2c_score_receive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_score_receive
         * @static
         * @param {chest.Is2c_score_receive} message s2c_score_receive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_score_receive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_score_receive message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_score_receive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_score_receive} s2c_score_receive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_score_receive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_score_receive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.score = $root.chest.ScoreInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_score_receive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_score_receive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_score_receive} s2c_score_receive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_score_receive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_score_receive message.
         * @function verify
         * @memberof chest.s2c_score_receive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_score_receive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.score != null && message.hasOwnProperty("score")) {
                var error = $root.chest.ScoreInfo.verify(message.score);
                if (error)
                    return "score." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_score_receive message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_score_receive
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_score_receive} s2c_score_receive
         */
        s2c_score_receive.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_score_receive)
                return object;
            var message = new $root.chest.s2c_score_receive();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".chest.s2c_score_receive.score: object expected");
                message.score = $root.chest.ScoreInfo.fromObject(object.score);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_score_receive message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_score_receive
         * @static
         * @param {chest.s2c_score_receive} message s2c_score_receive
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_score_receive.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.score = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = $root.chest.ScoreInfo.toObject(message.score, options);
            return object;
        };

        /**
         * Converts this s2c_score_receive to JSON.
         * @function toJSON
         * @memberof chest.s2c_score_receive
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_score_receive.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_score_receive
         * @function getTypeUrl
         * @memberof chest.s2c_score_receive
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_score_receive.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_score_receive";
        };

        return s2c_score_receive;
    })();

    chest.c2s_switch_hero = (function() {

        /**
         * Properties of a c2s_switch_hero.
         * @memberof chest
         * @interface Ic2s_switch_hero
         * @property {number|null} [heroId] c2s_switch_hero heroId
         */

        /**
         * Constructs a new c2s_switch_hero.
         * @memberof chest
         * @classdesc Represents a c2s_switch_hero.
         * @implements Ic2s_switch_hero
         * @constructor
         * @param {chest.Ic2s_switch_hero=} [properties] Properties to set
         */
        function c2s_switch_hero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_switch_hero heroId.
         * @member {number} heroId
         * @memberof chest.c2s_switch_hero
         * @instance
         */
        c2s_switch_hero.prototype.heroId = 0;

        /**
         * Creates a new c2s_switch_hero instance using the specified properties.
         * @function create
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {chest.Ic2s_switch_hero=} [properties] Properties to set
         * @returns {chest.c2s_switch_hero} c2s_switch_hero instance
         */
        c2s_switch_hero.create = function create(properties) {
            return new c2s_switch_hero(properties);
        };

        /**
         * Encodes the specified c2s_switch_hero message. Does not implicitly {@link chest.c2s_switch_hero.verify|verify} messages.
         * @function encode
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {chest.Ic2s_switch_hero} message c2s_switch_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_switch_hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.heroId);
            return writer;
        };

        /**
         * Encodes the specified c2s_switch_hero message, length delimited. Does not implicitly {@link chest.c2s_switch_hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {chest.Ic2s_switch_hero} message c2s_switch_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_switch_hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_switch_hero message from the specified reader or buffer.
         * @function decode
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.c2s_switch_hero} c2s_switch_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_switch_hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.c2s_switch_hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.heroId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_switch_hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.c2s_switch_hero} c2s_switch_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_switch_hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_switch_hero message.
         * @function verify
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_switch_hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_switch_hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.c2s_switch_hero} c2s_switch_hero
         */
        c2s_switch_hero.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.c2s_switch_hero)
                return object;
            var message = new $root.chest.c2s_switch_hero();
            if (object.heroId != null)
                message.heroId = object.heroId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_switch_hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {chest.c2s_switch_hero} message c2s_switch_hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_switch_hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.heroId = 0;
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            return object;
        };

        /**
         * Converts this c2s_switch_hero to JSON.
         * @function toJSON
         * @memberof chest.c2s_switch_hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_switch_hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_switch_hero
         * @function getTypeUrl
         * @memberof chest.c2s_switch_hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_switch_hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.c2s_switch_hero";
        };

        return c2s_switch_hero;
    })();

    chest.s2c_switch_hero = (function() {

        /**
         * Properties of a s2c_switch_hero.
         * @memberof chest
         * @interface Is2c_switch_hero
         * @property {number|null} [err] s2c_switch_hero err
         */

        /**
         * Constructs a new s2c_switch_hero.
         * @memberof chest
         * @classdesc Represents a s2c_switch_hero.
         * @implements Is2c_switch_hero
         * @constructor
         * @param {chest.Is2c_switch_hero=} [properties] Properties to set
         */
        function s2c_switch_hero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_switch_hero err.
         * @member {number} err
         * @memberof chest.s2c_switch_hero
         * @instance
         */
        s2c_switch_hero.prototype.err = 0;

        /**
         * Creates a new s2c_switch_hero instance using the specified properties.
         * @function create
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {chest.Is2c_switch_hero=} [properties] Properties to set
         * @returns {chest.s2c_switch_hero} s2c_switch_hero instance
         */
        s2c_switch_hero.create = function create(properties) {
            return new s2c_switch_hero(properties);
        };

        /**
         * Encodes the specified s2c_switch_hero message. Does not implicitly {@link chest.s2c_switch_hero.verify|verify} messages.
         * @function encode
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {chest.Is2c_switch_hero} message s2c_switch_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_switch_hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_switch_hero message, length delimited. Does not implicitly {@link chest.s2c_switch_hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {chest.Is2c_switch_hero} message s2c_switch_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_switch_hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_switch_hero message from the specified reader or buffer.
         * @function decode
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.s2c_switch_hero} s2c_switch_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_switch_hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.s2c_switch_hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_switch_hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.s2c_switch_hero} s2c_switch_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_switch_hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_switch_hero message.
         * @function verify
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_switch_hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_switch_hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.s2c_switch_hero} s2c_switch_hero
         */
        s2c_switch_hero.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.s2c_switch_hero)
                return object;
            var message = new $root.chest.s2c_switch_hero();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_switch_hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {chest.s2c_switch_hero} message s2c_switch_hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_switch_hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_switch_hero to JSON.
         * @function toJSON
         * @memberof chest.s2c_switch_hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_switch_hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_switch_hero
         * @function getTypeUrl
         * @memberof chest.s2c_switch_hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_switch_hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.s2c_switch_hero";
        };

        return s2c_switch_hero;
    })();

    chest.notify_chest = (function() {

        /**
         * Properties of a notify_chest.
         * @memberof chest
         * @interface Inotify_chest
         * @property {Array.<chest.IChestInfo>|null} [chests] notify_chest chests
         * @property {chest.IScoreInfo|null} [score] notify_chest score
         */

        /**
         * Constructs a new notify_chest.
         * @memberof chest
         * @classdesc Represents a notify_chest.
         * @implements Inotify_chest
         * @constructor
         * @param {chest.Inotify_chest=} [properties] Properties to set
         */
        function notify_chest(properties) {
            this.chests = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_chest chests.
         * @member {Array.<chest.IChestInfo>} chests
         * @memberof chest.notify_chest
         * @instance
         */
        notify_chest.prototype.chests = $util.emptyArray;

        /**
         * notify_chest score.
         * @member {chest.IScoreInfo|null|undefined} score
         * @memberof chest.notify_chest
         * @instance
         */
        notify_chest.prototype.score = null;

        /**
         * Creates a new notify_chest instance using the specified properties.
         * @function create
         * @memberof chest.notify_chest
         * @static
         * @param {chest.Inotify_chest=} [properties] Properties to set
         * @returns {chest.notify_chest} notify_chest instance
         */
        notify_chest.create = function create(properties) {
            return new notify_chest(properties);
        };

        /**
         * Encodes the specified notify_chest message. Does not implicitly {@link chest.notify_chest.verify|verify} messages.
         * @function encode
         * @memberof chest.notify_chest
         * @static
         * @param {chest.Inotify_chest} message notify_chest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_chest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chests != null && message.chests.length)
                for (var i = 0; i < message.chests.length; ++i)
                    $root.chest.ChestInfo.encode(message.chests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                $root.chest.ScoreInfo.encode(message.score, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_chest message, length delimited. Does not implicitly {@link chest.notify_chest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.notify_chest
         * @static
         * @param {chest.Inotify_chest} message notify_chest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_chest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_chest message from the specified reader or buffer.
         * @function decode
         * @memberof chest.notify_chest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.notify_chest} notify_chest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_chest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.notify_chest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.chests && message.chests.length))
                            message.chests = [];
                        message.chests.push($root.chest.ChestInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.score = $root.chest.ScoreInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_chest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.notify_chest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.notify_chest} notify_chest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_chest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_chest message.
         * @function verify
         * @memberof chest.notify_chest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_chest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chests != null && message.hasOwnProperty("chests")) {
                if (!Array.isArray(message.chests))
                    return "chests: array expected";
                for (var i = 0; i < message.chests.length; ++i) {
                    var error = $root.chest.ChestInfo.verify(message.chests[i]);
                    if (error)
                        return "chests." + error;
                }
            }
            if (message.score != null && message.hasOwnProperty("score")) {
                var error = $root.chest.ScoreInfo.verify(message.score);
                if (error)
                    return "score." + error;
            }
            return null;
        };

        /**
         * Creates a notify_chest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.notify_chest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.notify_chest} notify_chest
         */
        notify_chest.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.notify_chest)
                return object;
            var message = new $root.chest.notify_chest();
            if (object.chests) {
                if (!Array.isArray(object.chests))
                    throw TypeError(".chest.notify_chest.chests: array expected");
                message.chests = [];
                for (var i = 0; i < object.chests.length; ++i) {
                    if (typeof object.chests[i] !== "object")
                        throw TypeError(".chest.notify_chest.chests: object expected");
                    message.chests[i] = $root.chest.ChestInfo.fromObject(object.chests[i]);
                }
            }
            if (object.score != null) {
                if (typeof object.score !== "object")
                    throw TypeError(".chest.notify_chest.score: object expected");
                message.score = $root.chest.ScoreInfo.fromObject(object.score);
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_chest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.notify_chest
         * @static
         * @param {chest.notify_chest} message notify_chest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_chest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chests = [];
            if (options.defaults)
                object.score = null;
            if (message.chests && message.chests.length) {
                object.chests = [];
                for (var j = 0; j < message.chests.length; ++j)
                    object.chests[j] = $root.chest.ChestInfo.toObject(message.chests[j], options);
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = $root.chest.ScoreInfo.toObject(message.score, options);
            return object;
        };

        /**
         * Converts this notify_chest to JSON.
         * @function toJSON
         * @memberof chest.notify_chest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_chest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_chest
         * @function getTypeUrl
         * @memberof chest.notify_chest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_chest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.notify_chest";
        };

        return notify_chest;
    })();

    chest.notify_chest_hero = (function() {

        /**
         * Properties of a notify_chest_hero.
         * @memberof chest
         * @interface Inotify_chest_hero
         * @property {Array.<number>|null} [heroIds] notify_chest_hero heroIds
         */

        /**
         * Constructs a new notify_chest_hero.
         * @memberof chest
         * @classdesc Represents a notify_chest_hero.
         * @implements Inotify_chest_hero
         * @constructor
         * @param {chest.Inotify_chest_hero=} [properties] Properties to set
         */
        function notify_chest_hero(properties) {
            this.heroIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_chest_hero heroIds.
         * @member {Array.<number>} heroIds
         * @memberof chest.notify_chest_hero
         * @instance
         */
        notify_chest_hero.prototype.heroIds = $util.emptyArray;

        /**
         * Creates a new notify_chest_hero instance using the specified properties.
         * @function create
         * @memberof chest.notify_chest_hero
         * @static
         * @param {chest.Inotify_chest_hero=} [properties] Properties to set
         * @returns {chest.notify_chest_hero} notify_chest_hero instance
         */
        notify_chest_hero.create = function create(properties) {
            return new notify_chest_hero(properties);
        };

        /**
         * Encodes the specified notify_chest_hero message. Does not implicitly {@link chest.notify_chest_hero.verify|verify} messages.
         * @function encode
         * @memberof chest.notify_chest_hero
         * @static
         * @param {chest.Inotify_chest_hero} message notify_chest_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_chest_hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroIds != null && message.heroIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.heroIds.length; ++i)
                    writer.uint32(message.heroIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified notify_chest_hero message, length delimited. Does not implicitly {@link chest.notify_chest_hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof chest.notify_chest_hero
         * @static
         * @param {chest.Inotify_chest_hero} message notify_chest_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_chest_hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_chest_hero message from the specified reader or buffer.
         * @function decode
         * @memberof chest.notify_chest_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {chest.notify_chest_hero} notify_chest_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_chest_hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.chest.notify_chest_hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.heroIds && message.heroIds.length))
                            message.heroIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.heroIds.push(reader.uint32());
                        } else
                            message.heroIds.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_chest_hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof chest.notify_chest_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {chest.notify_chest_hero} notify_chest_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_chest_hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_chest_hero message.
         * @function verify
         * @memberof chest.notify_chest_hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_chest_hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroIds != null && message.hasOwnProperty("heroIds")) {
                if (!Array.isArray(message.heroIds))
                    return "heroIds: array expected";
                for (var i = 0; i < message.heroIds.length; ++i)
                    if (!$util.isInteger(message.heroIds[i]))
                        return "heroIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_chest_hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof chest.notify_chest_hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {chest.notify_chest_hero} notify_chest_hero
         */
        notify_chest_hero.fromObject = function fromObject(object) {
            if (object instanceof $root.chest.notify_chest_hero)
                return object;
            var message = new $root.chest.notify_chest_hero();
            if (object.heroIds) {
                if (!Array.isArray(object.heroIds))
                    throw TypeError(".chest.notify_chest_hero.heroIds: array expected");
                message.heroIds = [];
                for (var i = 0; i < object.heroIds.length; ++i)
                    message.heroIds[i] = object.heroIds[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_chest_hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof chest.notify_chest_hero
         * @static
         * @param {chest.notify_chest_hero} message notify_chest_hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_chest_hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroIds = [];
            if (message.heroIds && message.heroIds.length) {
                object.heroIds = [];
                for (var j = 0; j < message.heroIds.length; ++j)
                    object.heroIds[j] = message.heroIds[j];
            }
            return object;
        };

        /**
         * Converts this notify_chest_hero to JSON.
         * @function toJSON
         * @memberof chest.notify_chest_hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_chest_hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_chest_hero
         * @function getTypeUrl
         * @memberof chest.notify_chest_hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_chest_hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/chest.notify_chest_hero";
        };

        return notify_chest_hero;
    })();

    return chest;
})();

$root.dungeon = (function() {

    /**
     * Namespace dungeon.
     * @exports dungeon
     * @namespace
     */
    var dungeon = {};

    dungeon.Dungeon = (function() {

        /**
         * Properties of a Dungeon.
         * @memberof dungeon
         * @interface IDungeon
         * @property {number|null} [id] Dungeon id
         * @property {number|null} [star] Dungeon star
         */

        /**
         * Constructs a new Dungeon.
         * @memberof dungeon
         * @classdesc Represents a Dungeon.
         * @implements IDungeon
         * @constructor
         * @param {dungeon.IDungeon=} [properties] Properties to set
         */
        function Dungeon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dungeon id.
         * @member {number} id
         * @memberof dungeon.Dungeon
         * @instance
         */
        Dungeon.prototype.id = 0;

        /**
         * Dungeon star.
         * @member {number} star
         * @memberof dungeon.Dungeon
         * @instance
         */
        Dungeon.prototype.star = 0;

        /**
         * Creates a new Dungeon instance using the specified properties.
         * @function create
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.IDungeon=} [properties] Properties to set
         * @returns {dungeon.Dungeon} Dungeon instance
         */
        Dungeon.create = function create(properties) {
            return new Dungeon(properties);
        };

        /**
         * Encodes the specified Dungeon message. Does not implicitly {@link dungeon.Dungeon.verify|verify} messages.
         * @function encode
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.IDungeon} message Dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dungeon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.star);
            return writer;
        };

        /**
         * Encodes the specified Dungeon message, length delimited. Does not implicitly {@link dungeon.Dungeon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.IDungeon} message Dungeon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dungeon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dungeon message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.Dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.Dungeon} Dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dungeon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.Dungeon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.star = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dungeon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.Dungeon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.Dungeon} Dungeon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dungeon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dungeon message.
         * @function verify
         * @memberof dungeon.Dungeon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dungeon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            return null;
        };

        /**
         * Creates a Dungeon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.Dungeon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.Dungeon} Dungeon
         */
        Dungeon.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.Dungeon)
                return object;
            var message = new $root.dungeon.Dungeon();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.star != null)
                message.star = object.star >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Dungeon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.Dungeon
         * @static
         * @param {dungeon.Dungeon} message Dungeon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dungeon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.star = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            return object;
        };

        /**
         * Converts this Dungeon to JSON.
         * @function toJSON
         * @memberof dungeon.Dungeon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dungeon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Dungeon
         * @function getTypeUrl
         * @memberof dungeon.Dungeon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Dungeon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.Dungeon";
        };

        return Dungeon;
    })();

    dungeon.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof dungeon
         * @interface Ic2s_load
         * @property {number|null} [dungeonType] c2s_load dungeonType
         */

        /**
         * Constructs a new c2s_load.
         * @memberof dungeon
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {dungeon.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load dungeonType.
         * @member {number} dungeonType
         * @memberof dungeon.c2s_load
         * @instance
         */
        c2s_load.prototype.dungeonType = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.Ic2s_load=} [properties] Properties to set
         * @returns {dungeon.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link dungeon.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dungeonType != null && Object.hasOwnProperty.call(message, "dungeonType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.dungeonType);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link dungeon.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dungeonType = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof dungeon.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dungeonType != null && message.hasOwnProperty("dungeonType"))
                if (!$util.isInteger(message.dungeonType))
                    return "dungeonType: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.c2s_load)
                return object;
            var message = new $root.dungeon.c2s_load();
            if (object.dungeonType != null)
                message.dungeonType = object.dungeonType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.c2s_load
         * @static
         * @param {dungeon.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.dungeonType = 0;
            if (message.dungeonType != null && message.hasOwnProperty("dungeonType"))
                object.dungeonType = message.dungeonType;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof dungeon.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof dungeon.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.c2s_load";
        };

        return c2s_load;
    })();

    dungeon.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof dungeon
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<dungeon.IDungeon>|null} [dungeonList] s2c_load dungeonList
         */

        /**
         * Constructs a new s2c_load.
         * @memberof dungeon
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {dungeon.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.dungeonList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof dungeon.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load dungeonList.
         * @member {Array.<dungeon.IDungeon>} dungeonList
         * @memberof dungeon.s2c_load
         * @instance
         */
        s2c_load.prototype.dungeonList = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.Is2c_load=} [properties] Properties to set
         * @returns {dungeon.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link dungeon.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.dungeonList != null && message.dungeonList.length)
                for (var i = 0; i < message.dungeonList.length; ++i)
                    $root.dungeon.Dungeon.encode(message.dungeonList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link dungeon.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.dungeonList && message.dungeonList.length))
                            message.dungeonList = [];
                        message.dungeonList.push($root.dungeon.Dungeon.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof dungeon.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.dungeonList != null && message.hasOwnProperty("dungeonList")) {
                if (!Array.isArray(message.dungeonList))
                    return "dungeonList: array expected";
                for (var i = 0; i < message.dungeonList.length; ++i) {
                    var error = $root.dungeon.Dungeon.verify(message.dungeonList[i]);
                    if (error)
                        return "dungeonList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.s2c_load)
                return object;
            var message = new $root.dungeon.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.dungeonList) {
                if (!Array.isArray(object.dungeonList))
                    throw TypeError(".dungeon.s2c_load.dungeonList: array expected");
                message.dungeonList = [];
                for (var i = 0; i < object.dungeonList.length; ++i) {
                    if (typeof object.dungeonList[i] !== "object")
                        throw TypeError(".dungeon.s2c_load.dungeonList: object expected");
                    message.dungeonList[i] = $root.dungeon.Dungeon.fromObject(object.dungeonList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.s2c_load
         * @static
         * @param {dungeon.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dungeonList = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.dungeonList && message.dungeonList.length) {
                object.dungeonList = [];
                for (var j = 0; j < message.dungeonList.length; ++j)
                    object.dungeonList[j] = $root.dungeon.Dungeon.toObject(message.dungeonList[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof dungeon.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof dungeon.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.s2c_load";
        };

        return s2c_load;
    })();

    dungeon.c2s_challenge = (function() {

        /**
         * Properties of a c2s_challenge.
         * @memberof dungeon
         * @interface Ic2s_challenge
         * @property {number|null} [dungeonId] c2s_challenge dungeonId
         */

        /**
         * Constructs a new c2s_challenge.
         * @memberof dungeon
         * @classdesc Represents a c2s_challenge.
         * @implements Ic2s_challenge
         * @constructor
         * @param {dungeon.Ic2s_challenge=} [properties] Properties to set
         */
        function c2s_challenge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_challenge dungeonId.
         * @member {number} dungeonId
         * @memberof dungeon.c2s_challenge
         * @instance
         */
        c2s_challenge.prototype.dungeonId = 0;

        /**
         * Creates a new c2s_challenge instance using the specified properties.
         * @function create
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {dungeon.Ic2s_challenge=} [properties] Properties to set
         * @returns {dungeon.c2s_challenge} c2s_challenge instance
         */
        c2s_challenge.create = function create(properties) {
            return new c2s_challenge(properties);
        };

        /**
         * Encodes the specified c2s_challenge message. Does not implicitly {@link dungeon.c2s_challenge.verify|verify} messages.
         * @function encode
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {dungeon.Ic2s_challenge} message c2s_challenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_challenge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dungeonId != null && Object.hasOwnProperty.call(message, "dungeonId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.dungeonId);
            return writer;
        };

        /**
         * Encodes the specified c2s_challenge message, length delimited. Does not implicitly {@link dungeon.c2s_challenge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {dungeon.Ic2s_challenge} message c2s_challenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_challenge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_challenge message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.c2s_challenge} c2s_challenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_challenge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.c2s_challenge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dungeonId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_challenge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.c2s_challenge} c2s_challenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_challenge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_challenge message.
         * @function verify
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_challenge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                if (!$util.isInteger(message.dungeonId))
                    return "dungeonId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_challenge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.c2s_challenge} c2s_challenge
         */
        c2s_challenge.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.c2s_challenge)
                return object;
            var message = new $root.dungeon.c2s_challenge();
            if (object.dungeonId != null)
                message.dungeonId = object.dungeonId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_challenge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {dungeon.c2s_challenge} message c2s_challenge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_challenge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.dungeonId = 0;
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                object.dungeonId = message.dungeonId;
            return object;
        };

        /**
         * Converts this c2s_challenge to JSON.
         * @function toJSON
         * @memberof dungeon.c2s_challenge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_challenge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_challenge
         * @function getTypeUrl
         * @memberof dungeon.c2s_challenge
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_challenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.c2s_challenge";
        };

        return c2s_challenge;
    })();

    dungeon.s2c_challenge = (function() {

        /**
         * Properties of a s2c_challenge.
         * @memberof dungeon
         * @interface Is2c_challenge
         * @property {number|null} [err] s2c_challenge err
         * @property {number|null} [worldUid] s2c_challenge worldUid
         */

        /**
         * Constructs a new s2c_challenge.
         * @memberof dungeon
         * @classdesc Represents a s2c_challenge.
         * @implements Is2c_challenge
         * @constructor
         * @param {dungeon.Is2c_challenge=} [properties] Properties to set
         */
        function s2c_challenge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_challenge err.
         * @member {number} err
         * @memberof dungeon.s2c_challenge
         * @instance
         */
        s2c_challenge.prototype.err = 0;

        /**
         * s2c_challenge worldUid.
         * @member {number} worldUid
         * @memberof dungeon.s2c_challenge
         * @instance
         */
        s2c_challenge.prototype.worldUid = 0;

        /**
         * Creates a new s2c_challenge instance using the specified properties.
         * @function create
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {dungeon.Is2c_challenge=} [properties] Properties to set
         * @returns {dungeon.s2c_challenge} s2c_challenge instance
         */
        s2c_challenge.create = function create(properties) {
            return new s2c_challenge(properties);
        };

        /**
         * Encodes the specified s2c_challenge message. Does not implicitly {@link dungeon.s2c_challenge.verify|verify} messages.
         * @function encode
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {dungeon.Is2c_challenge} message s2c_challenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_challenge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.worldUid != null && Object.hasOwnProperty.call(message, "worldUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.worldUid);
            return writer;
        };

        /**
         * Encodes the specified s2c_challenge message, length delimited. Does not implicitly {@link dungeon.s2c_challenge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {dungeon.Is2c_challenge} message s2c_challenge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_challenge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_challenge message from the specified reader or buffer.
         * @function decode
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dungeon.s2c_challenge} s2c_challenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_challenge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dungeon.s2c_challenge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.worldUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_challenge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dungeon.s2c_challenge} s2c_challenge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_challenge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_challenge message.
         * @function verify
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_challenge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.worldUid != null && message.hasOwnProperty("worldUid"))
                if (!$util.isInteger(message.worldUid))
                    return "worldUid: integer expected";
            return null;
        };

        /**
         * Creates a s2c_challenge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dungeon.s2c_challenge} s2c_challenge
         */
        s2c_challenge.fromObject = function fromObject(object) {
            if (object instanceof $root.dungeon.s2c_challenge)
                return object;
            var message = new $root.dungeon.s2c_challenge();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.worldUid != null)
                message.worldUid = object.worldUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_challenge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {dungeon.s2c_challenge} message s2c_challenge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_challenge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.worldUid = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.worldUid != null && message.hasOwnProperty("worldUid"))
                object.worldUid = message.worldUid;
            return object;
        };

        /**
         * Converts this s2c_challenge to JSON.
         * @function toJSON
         * @memberof dungeon.s2c_challenge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_challenge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_challenge
         * @function getTypeUrl
         * @memberof dungeon.s2c_challenge
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_challenge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dungeon.s2c_challenge";
        };

        return s2c_challenge;
    })();

    return dungeon;
})();

$root.hero = (function() {

    /**
     * Namespace hero.
     * @exports hero
     * @namespace
     */
    var hero = {};

    hero.Hero = (function() {

        /**
         * Properties of a Hero.
         * @memberof hero
         * @interface IHero
         * @property {number|null} [uid] Hero uid
         * @property {number|null} [id] Hero id
         * @property {number|null} [soldierId] Hero soldierId
         * @property {number|null} [soldierAmount] Hero soldierAmount
         * @property {number|null} [hp] Hero hp
         * @property {Object.<string,number>|null} [attrs] Hero attrs
         */

        /**
         * Constructs a new Hero.
         * @memberof hero
         * @classdesc Represents a Hero.
         * @implements IHero
         * @constructor
         * @param {hero.IHero=} [properties] Properties to set
         */
        function Hero(properties) {
            this.attrs = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hero uid.
         * @member {number} uid
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.uid = 0;

        /**
         * Hero id.
         * @member {number} id
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.id = 0;

        /**
         * Hero soldierId.
         * @member {number} soldierId
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.soldierId = 0;

        /**
         * Hero soldierAmount.
         * @member {number} soldierAmount
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.soldierAmount = 0;

        /**
         * Hero hp.
         * @member {number} hp
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.hp = 0;

        /**
         * Hero attrs.
         * @member {Object.<string,number>} attrs
         * @memberof hero.Hero
         * @instance
         */
        Hero.prototype.attrs = $util.emptyObject;

        /**
         * Creates a new Hero instance using the specified properties.
         * @function create
         * @memberof hero.Hero
         * @static
         * @param {hero.IHero=} [properties] Properties to set
         * @returns {hero.Hero} Hero instance
         */
        Hero.create = function create(properties) {
            return new Hero(properties);
        };

        /**
         * Encodes the specified Hero message. Does not implicitly {@link hero.Hero.verify|verify} messages.
         * @function encode
         * @memberof hero.Hero
         * @static
         * @param {hero.IHero} message Hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            if (message.soldierId != null && Object.hasOwnProperty.call(message, "soldierId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.soldierId);
            if (message.soldierAmount != null && Object.hasOwnProperty.call(message, "soldierAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.soldierAmount);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.hp);
            if (message.attrs != null && Object.hasOwnProperty.call(message, "attrs"))
                for (var keys = Object.keys(message.attrs), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.attrs[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Hero message, length delimited. Does not implicitly {@link hero.Hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hero.Hero
         * @static
         * @param {hero.IHero} message Hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hero message from the specified reader or buffer.
         * @function decode
         * @memberof hero.Hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hero.Hero} Hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hero.Hero(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                case 3: {
                        message.soldierId = reader.uint32();
                        break;
                    }
                case 4: {
                        message.soldierAmount = reader.uint32();
                        break;
                    }
                case 5: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 6: {
                        if (message.attrs === $util.emptyObject)
                            message.attrs = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attrs[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hero.Hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hero.Hero} Hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hero message.
         * @function verify
         * @memberof hero.Hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                if (!$util.isInteger(message.soldierId))
                    return "soldierId: integer expected";
            if (message.soldierAmount != null && message.hasOwnProperty("soldierAmount"))
                if (!$util.isInteger(message.soldierAmount))
                    return "soldierAmount: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.attrs != null && message.hasOwnProperty("attrs")) {
                if (!$util.isObject(message.attrs))
                    return "attrs: object expected";
                var key = Object.keys(message.attrs);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "attrs: integer key{k:uint32} expected";
                    if (!$util.isInteger(message.attrs[key[i]]))
                        return "attrs: integer{k:uint32} expected";
                }
            }
            return null;
        };

        /**
         * Creates a Hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hero.Hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hero.Hero} Hero
         */
        Hero.fromObject = function fromObject(object) {
            if (object instanceof $root.hero.Hero)
                return object;
            var message = new $root.hero.Hero();
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.soldierId != null)
                message.soldierId = object.soldierId >>> 0;
            if (object.soldierAmount != null)
                message.soldierAmount = object.soldierAmount >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.attrs) {
                if (typeof object.attrs !== "object")
                    throw TypeError(".hero.Hero.attrs: object expected");
                message.attrs = {};
                for (var keys = Object.keys(object.attrs), i = 0; i < keys.length; ++i)
                    message.attrs[keys[i]] = object.attrs[keys[i]] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a Hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hero.Hero
         * @static
         * @param {hero.Hero} message Hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.attrs = {};
            if (options.defaults) {
                object.uid = 0;
                object.id = 0;
                object.soldierId = 0;
                object.soldierAmount = 0;
                object.hp = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                object.soldierId = message.soldierId;
            if (message.soldierAmount != null && message.hasOwnProperty("soldierAmount"))
                object.soldierAmount = message.soldierAmount;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            var keys2;
            if (message.attrs && (keys2 = Object.keys(message.attrs)).length) {
                object.attrs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.attrs[keys2[j]] = message.attrs[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this Hero to JSON.
         * @function toJSON
         * @memberof hero.Hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Hero
         * @function getTypeUrl
         * @memberof hero.Hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hero.Hero";
        };

        return Hero;
    })();

    hero.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof hero
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof hero
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {hero.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof hero.c2s_load
         * @static
         * @param {hero.Ic2s_load=} [properties] Properties to set
         * @returns {hero.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link hero.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof hero.c2s_load
         * @static
         * @param {hero.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link hero.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hero.c2s_load
         * @static
         * @param {hero.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof hero.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hero.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hero.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hero.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hero.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof hero.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hero.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hero.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.hero.c2s_load)
                return object;
            return new $root.hero.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hero.c2s_load
         * @static
         * @param {hero.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof hero.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof hero.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hero.c2s_load";
        };

        return c2s_load;
    })();

    hero.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof hero
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<hero.IHero>|null} [heroList] s2c_load heroList
         */

        /**
         * Constructs a new s2c_load.
         * @memberof hero
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {hero.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.heroList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof hero.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load heroList.
         * @member {Array.<hero.IHero>} heroList
         * @memberof hero.s2c_load
         * @instance
         */
        s2c_load.prototype.heroList = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof hero.s2c_load
         * @static
         * @param {hero.Is2c_load=} [properties] Properties to set
         * @returns {hero.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link hero.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof hero.s2c_load
         * @static
         * @param {hero.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.heroList != null && message.heroList.length)
                for (var i = 0; i < message.heroList.length; ++i)
                    $root.hero.Hero.encode(message.heroList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link hero.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hero.s2c_load
         * @static
         * @param {hero.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof hero.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hero.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hero.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.heroList && message.heroList.length))
                            message.heroList = [];
                        message.heroList.push($root.hero.Hero.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hero.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hero.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof hero.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.heroList != null && message.hasOwnProperty("heroList")) {
                if (!Array.isArray(message.heroList))
                    return "heroList: array expected";
                for (var i = 0; i < message.heroList.length; ++i) {
                    var error = $root.hero.Hero.verify(message.heroList[i]);
                    if (error)
                        return "heroList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hero.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hero.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.hero.s2c_load)
                return object;
            var message = new $root.hero.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.heroList) {
                if (!Array.isArray(object.heroList))
                    throw TypeError(".hero.s2c_load.heroList: array expected");
                message.heroList = [];
                for (var i = 0; i < object.heroList.length; ++i) {
                    if (typeof object.heroList[i] !== "object")
                        throw TypeError(".hero.s2c_load.heroList: object expected");
                    message.heroList[i] = $root.hero.Hero.fromObject(object.heroList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hero.s2c_load
         * @static
         * @param {hero.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroList = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.heroList && message.heroList.length) {
                object.heroList = [];
                for (var j = 0; j < message.heroList.length; ++j)
                    object.heroList[j] = $root.hero.Hero.toObject(message.heroList[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof hero.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof hero.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hero.s2c_load";
        };

        return s2c_load;
    })();

    return hero;
})();

$root.mail = (function() {

    /**
     * Namespace mail.
     * @exports mail
     * @namespace
     */
    var mail = {};

    mail.MailInfo = (function() {

        /**
         * Properties of a MailInfo.
         * @memberof mail
         * @interface IMailInfo
         * @property {number|null} [uid] MailInfo uid
         * @property {number|null} [id] MailInfo id
         * @property {number|null} [time] MailInfo time
         * @property {number|null} [state] MailInfo state
         * @property {string|null} [title] MailInfo title
         * @property {string|null} [content] MailInfo content
         * @property {Array.<bag.IItem>|null} [reward] MailInfo reward
         * @property {number|null} [expiredSec] MailInfo expiredSec
         */

        /**
         * Constructs a new MailInfo.
         * @memberof mail
         * @classdesc Represents a MailInfo.
         * @implements IMailInfo
         * @constructor
         * @param {mail.IMailInfo=} [properties] Properties to set
         */
        function MailInfo(properties) {
            this.reward = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailInfo uid.
         * @member {number} uid
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.uid = 0;

        /**
         * MailInfo id.
         * @member {number} id
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.id = 0;

        /**
         * MailInfo time.
         * @member {number} time
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.time = 0;

        /**
         * MailInfo state.
         * @member {number} state
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.state = 0;

        /**
         * MailInfo title.
         * @member {string} title
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.title = "";

        /**
         * MailInfo content.
         * @member {string} content
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.content = "";

        /**
         * MailInfo reward.
         * @member {Array.<bag.IItem>} reward
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.reward = $util.emptyArray;

        /**
         * MailInfo expiredSec.
         * @member {number} expiredSec
         * @memberof mail.MailInfo
         * @instance
         */
        MailInfo.prototype.expiredSec = 0;

        /**
         * Creates a new MailInfo instance using the specified properties.
         * @function create
         * @memberof mail.MailInfo
         * @static
         * @param {mail.IMailInfo=} [properties] Properties to set
         * @returns {mail.MailInfo} MailInfo instance
         */
        MailInfo.create = function create(properties) {
            return new MailInfo(properties);
        };

        /**
         * Encodes the specified MailInfo message. Does not implicitly {@link mail.MailInfo.verify|verify} messages.
         * @function encode
         * @memberof mail.MailInfo
         * @static
         * @param {mail.IMailInfo} message MailInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.time);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.state);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.title);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.content);
            if (message.reward != null && message.reward.length)
                for (var i = 0; i < message.reward.length; ++i)
                    $root.bag.Item.encode(message.reward[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.expiredSec != null && Object.hasOwnProperty.call(message, "expiredSec"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expiredSec);
            return writer;
        };

        /**
         * Encodes the specified MailInfo message, length delimited. Does not implicitly {@link mail.MailInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.MailInfo
         * @static
         * @param {mail.IMailInfo} message MailInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailInfo message from the specified reader or buffer.
         * @function decode
         * @memberof mail.MailInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.MailInfo} MailInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.MailInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                case 3: {
                        message.time = reader.uint32();
                        break;
                    }
                case 4: {
                        message.state = reader.uint32();
                        break;
                    }
                case 5: {
                        message.title = reader.string();
                        break;
                    }
                case 6: {
                        message.content = reader.string();
                        break;
                    }
                case 7: {
                        if (!(message.reward && message.reward.length))
                            message.reward = [];
                        message.reward.push($root.bag.Item.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.expiredSec = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.MailInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.MailInfo} MailInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailInfo message.
         * @function verify
         * @memberof mail.MailInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                if (!Array.isArray(message.reward))
                    return "reward: array expected";
                for (var i = 0; i < message.reward.length; ++i) {
                    var error = $root.bag.Item.verify(message.reward[i]);
                    if (error)
                        return "reward." + error;
                }
            }
            if (message.expiredSec != null && message.hasOwnProperty("expiredSec"))
                if (!$util.isInteger(message.expiredSec))
                    return "expiredSec: integer expected";
            return null;
        };

        /**
         * Creates a MailInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.MailInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.MailInfo} MailInfo
         */
        MailInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.MailInfo)
                return object;
            var message = new $root.mail.MailInfo();
            if (object.uid != null)
                message.uid = object.uid >>> 0;
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.time != null)
                message.time = object.time >>> 0;
            if (object.state != null)
                message.state = object.state >>> 0;
            if (object.title != null)
                message.title = String(object.title);
            if (object.content != null)
                message.content = String(object.content);
            if (object.reward) {
                if (!Array.isArray(object.reward))
                    throw TypeError(".mail.MailInfo.reward: array expected");
                message.reward = [];
                for (var i = 0; i < object.reward.length; ++i) {
                    if (typeof object.reward[i] !== "object")
                        throw TypeError(".mail.MailInfo.reward: object expected");
                    message.reward[i] = $root.bag.Item.fromObject(object.reward[i]);
                }
            }
            if (object.expiredSec != null)
                message.expiredSec = object.expiredSec >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MailInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.MailInfo
         * @static
         * @param {mail.MailInfo} message MailInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MailInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reward = [];
            if (options.defaults) {
                object.uid = 0;
                object.id = 0;
                object.time = 0;
                object.state = 0;
                object.title = "";
                object.content = "";
                object.expiredSec = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.reward && message.reward.length) {
                object.reward = [];
                for (var j = 0; j < message.reward.length; ++j)
                    object.reward[j] = $root.bag.Item.toObject(message.reward[j], options);
            }
            if (message.expiredSec != null && message.hasOwnProperty("expiredSec"))
                object.expiredSec = message.expiredSec;
            return object;
        };

        /**
         * Converts this MailInfo to JSON.
         * @function toJSON
         * @memberof mail.MailInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MailInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MailInfo
         * @function getTypeUrl
         * @memberof mail.MailInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MailInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.MailInfo";
        };

        return MailInfo;
    })();

    mail.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof mail
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof mail
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {mail.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof mail.c2s_load
         * @static
         * @param {mail.Ic2s_load=} [properties] Properties to set
         * @returns {mail.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link mail.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_load
         * @static
         * @param {mail.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link mail.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_load
         * @static
         * @param {mail.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof mail.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_load)
                return object;
            return new $root.mail.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_load
         * @static
         * @param {mail.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof mail.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof mail.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_load";
        };

        return c2s_load;
    })();

    mail.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof mail
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<mail.IMailInfo>|null} [mails] s2c_load mails
         */

        /**
         * Constructs a new s2c_load.
         * @memberof mail
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {mail.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof mail.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load mails.
         * @member {Array.<mail.IMailInfo>} mails
         * @memberof mail.s2c_load
         * @instance
         */
        s2c_load.prototype.mails = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof mail.s2c_load
         * @static
         * @param {mail.Is2c_load=} [properties] Properties to set
         * @returns {mail.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link mail.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_load
         * @static
         * @param {mail.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.mails != null && message.mails.length)
                for (var i = 0; i < message.mails.length; ++i)
                    $root.mail.MailInfo.encode(message.mails[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link mail.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_load
         * @static
         * @param {mail.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.mails && message.mails.length))
                            message.mails = [];
                        message.mails.push($root.mail.MailInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof mail.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.mails != null && message.hasOwnProperty("mails")) {
                if (!Array.isArray(message.mails))
                    return "mails: array expected";
                for (var i = 0; i < message.mails.length; ++i) {
                    var error = $root.mail.MailInfo.verify(message.mails[i]);
                    if (error)
                        return "mails." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_load)
                return object;
            var message = new $root.mail.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.mails) {
                if (!Array.isArray(object.mails))
                    throw TypeError(".mail.s2c_load.mails: array expected");
                message.mails = [];
                for (var i = 0; i < object.mails.length; ++i) {
                    if (typeof object.mails[i] !== "object")
                        throw TypeError(".mail.s2c_load.mails: object expected");
                    message.mails[i] = $root.mail.MailInfo.fromObject(object.mails[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_load
         * @static
         * @param {mail.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mails = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.mails && message.mails.length) {
                object.mails = [];
                for (var j = 0; j < message.mails.length; ++j)
                    object.mails[j] = $root.mail.MailInfo.toObject(message.mails[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof mail.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof mail.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_load";
        };

        return s2c_load;
    })();

    mail.c2s_read = (function() {

        /**
         * Properties of a c2s_read.
         * @memberof mail
         * @interface Ic2s_read
         * @property {Array.<number>|null} [mailUids] c2s_read mailUids
         */

        /**
         * Constructs a new c2s_read.
         * @memberof mail
         * @classdesc Represents a c2s_read.
         * @implements Ic2s_read
         * @constructor
         * @param {mail.Ic2s_read=} [properties] Properties to set
         */
        function c2s_read(properties) {
            this.mailUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_read mailUids.
         * @member {Array.<number>} mailUids
         * @memberof mail.c2s_read
         * @instance
         */
        c2s_read.prototype.mailUids = $util.emptyArray;

        /**
         * Creates a new c2s_read instance using the specified properties.
         * @function create
         * @memberof mail.c2s_read
         * @static
         * @param {mail.Ic2s_read=} [properties] Properties to set
         * @returns {mail.c2s_read} c2s_read instance
         */
        c2s_read.create = function create(properties) {
            return new c2s_read(properties);
        };

        /**
         * Encodes the specified c2s_read message. Does not implicitly {@link mail.c2s_read.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_read
         * @static
         * @param {mail.Ic2s_read} message c2s_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_read.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailUids != null && message.mailUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mailUids.length; ++i)
                    writer.uint32(message.mailUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_read message, length delimited. Does not implicitly {@link mail.c2s_read.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_read
         * @static
         * @param {mail.Ic2s_read} message c2s_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_read.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_read message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_read} c2s_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_read.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_read();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mailUids && message.mailUids.length))
                            message.mailUids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.mailUids.push(reader.uint32());
                        } else
                            message.mailUids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_read message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_read} c2s_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_read.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_read message.
         * @function verify
         * @memberof mail.c2s_read
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_read.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailUids != null && message.hasOwnProperty("mailUids")) {
                if (!Array.isArray(message.mailUids))
                    return "mailUids: array expected";
                for (var i = 0; i < message.mailUids.length; ++i)
                    if (!$util.isInteger(message.mailUids[i]))
                        return "mailUids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_read message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_read
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_read} c2s_read
         */
        c2s_read.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_read)
                return object;
            var message = new $root.mail.c2s_read();
            if (object.mailUids) {
                if (!Array.isArray(object.mailUids))
                    throw TypeError(".mail.c2s_read.mailUids: array expected");
                message.mailUids = [];
                for (var i = 0; i < object.mailUids.length; ++i)
                    message.mailUids[i] = object.mailUids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_read message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_read
         * @static
         * @param {mail.c2s_read} message c2s_read
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_read.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailUids = [];
            if (message.mailUids && message.mailUids.length) {
                object.mailUids = [];
                for (var j = 0; j < message.mailUids.length; ++j)
                    object.mailUids[j] = message.mailUids[j];
            }
            return object;
        };

        /**
         * Converts this c2s_read to JSON.
         * @function toJSON
         * @memberof mail.c2s_read
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_read.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_read
         * @function getTypeUrl
         * @memberof mail.c2s_read
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_read.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_read";
        };

        return c2s_read;
    })();

    mail.s2c_read = (function() {

        /**
         * Properties of a s2c_read.
         * @memberof mail
         * @interface Is2c_read
         * @property {number|null} [err] s2c_read err
         */

        /**
         * Constructs a new s2c_read.
         * @memberof mail
         * @classdesc Represents a s2c_read.
         * @implements Is2c_read
         * @constructor
         * @param {mail.Is2c_read=} [properties] Properties to set
         */
        function s2c_read(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_read err.
         * @member {number} err
         * @memberof mail.s2c_read
         * @instance
         */
        s2c_read.prototype.err = 0;

        /**
         * Creates a new s2c_read instance using the specified properties.
         * @function create
         * @memberof mail.s2c_read
         * @static
         * @param {mail.Is2c_read=} [properties] Properties to set
         * @returns {mail.s2c_read} s2c_read instance
         */
        s2c_read.create = function create(properties) {
            return new s2c_read(properties);
        };

        /**
         * Encodes the specified s2c_read message. Does not implicitly {@link mail.s2c_read.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_read
         * @static
         * @param {mail.Is2c_read} message s2c_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_read.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_read message, length delimited. Does not implicitly {@link mail.s2c_read.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_read
         * @static
         * @param {mail.Is2c_read} message s2c_read message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_read.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_read message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_read} s2c_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_read.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_read();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_read message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_read
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_read} s2c_read
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_read.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_read message.
         * @function verify
         * @memberof mail.s2c_read
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_read.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_read message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_read
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_read} s2c_read
         */
        s2c_read.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_read)
                return object;
            var message = new $root.mail.s2c_read();
            if (object.err != null)
                message.err = object.err | 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_read message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_read
         * @static
         * @param {mail.s2c_read} message s2c_read
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_read.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_read to JSON.
         * @function toJSON
         * @memberof mail.s2c_read
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_read.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_read
         * @function getTypeUrl
         * @memberof mail.s2c_read
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_read.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_read";
        };

        return s2c_read;
    })();

    mail.c2s_receive_reward = (function() {

        /**
         * Properties of a c2s_receive_reward.
         * @memberof mail
         * @interface Ic2s_receive_reward
         * @property {Array.<number>|null} [mailUids] c2s_receive_reward mailUids
         */

        /**
         * Constructs a new c2s_receive_reward.
         * @memberof mail
         * @classdesc Represents a c2s_receive_reward.
         * @implements Ic2s_receive_reward
         * @constructor
         * @param {mail.Ic2s_receive_reward=} [properties] Properties to set
         */
        function c2s_receive_reward(properties) {
            this.mailUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_receive_reward mailUids.
         * @member {Array.<number>} mailUids
         * @memberof mail.c2s_receive_reward
         * @instance
         */
        c2s_receive_reward.prototype.mailUids = $util.emptyArray;

        /**
         * Creates a new c2s_receive_reward instance using the specified properties.
         * @function create
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.Ic2s_receive_reward=} [properties] Properties to set
         * @returns {mail.c2s_receive_reward} c2s_receive_reward instance
         */
        c2s_receive_reward.create = function create(properties) {
            return new c2s_receive_reward(properties);
        };

        /**
         * Encodes the specified c2s_receive_reward message. Does not implicitly {@link mail.c2s_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailUids != null && message.mailUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mailUids.length; ++i)
                    writer.uint32(message.mailUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_receive_reward message, length delimited. Does not implicitly {@link mail.c2s_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mailUids && message.mailUids.length))
                            message.mailUids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.mailUids.push(reader.uint32());
                        } else
                            message.mailUids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_receive_reward message.
         * @function verify
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailUids != null && message.hasOwnProperty("mailUids")) {
                if (!Array.isArray(message.mailUids))
                    return "mailUids: array expected";
                for (var i = 0; i < message.mailUids.length; ++i)
                    if (!$util.isInteger(message.mailUids[i]))
                        return "mailUids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_receive_reward} c2s_receive_reward
         */
        c2s_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_receive_reward)
                return object;
            var message = new $root.mail.c2s_receive_reward();
            if (object.mailUids) {
                if (!Array.isArray(object.mailUids))
                    throw TypeError(".mail.c2s_receive_reward.mailUids: array expected");
                message.mailUids = [];
                for (var i = 0; i < object.mailUids.length; ++i)
                    message.mailUids[i] = object.mailUids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {mail.c2s_receive_reward} message c2s_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailUids = [];
            if (message.mailUids && message.mailUids.length) {
                object.mailUids = [];
                for (var j = 0; j < message.mailUids.length; ++j)
                    object.mailUids[j] = message.mailUids[j];
            }
            return object;
        };

        /**
         * Converts this c2s_receive_reward to JSON.
         * @function toJSON
         * @memberof mail.c2s_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_receive_reward
         * @function getTypeUrl
         * @memberof mail.c2s_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_receive_reward";
        };

        return c2s_receive_reward;
    })();

    mail.s2c_receive_reward = (function() {

        /**
         * Properties of a s2c_receive_reward.
         * @memberof mail
         * @interface Is2c_receive_reward
         * @property {number|null} [err] s2c_receive_reward err
         */

        /**
         * Constructs a new s2c_receive_reward.
         * @memberof mail
         * @classdesc Represents a s2c_receive_reward.
         * @implements Is2c_receive_reward
         * @constructor
         * @param {mail.Is2c_receive_reward=} [properties] Properties to set
         */
        function s2c_receive_reward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_receive_reward err.
         * @member {number} err
         * @memberof mail.s2c_receive_reward
         * @instance
         */
        s2c_receive_reward.prototype.err = 0;

        /**
         * Creates a new s2c_receive_reward instance using the specified properties.
         * @function create
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.Is2c_receive_reward=} [properties] Properties to set
         * @returns {mail.s2c_receive_reward} s2c_receive_reward instance
         */
        s2c_receive_reward.create = function create(properties) {
            return new s2c_receive_reward(properties);
        };

        /**
         * Encodes the specified s2c_receive_reward message. Does not implicitly {@link mail.s2c_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_receive_reward message, length delimited. Does not implicitly {@link mail.s2c_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_receive_reward message.
         * @function verify
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_receive_reward} s2c_receive_reward
         */
        s2c_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_receive_reward)
                return object;
            var message = new $root.mail.s2c_receive_reward();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {mail.s2c_receive_reward} message s2c_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_receive_reward to JSON.
         * @function toJSON
         * @memberof mail.s2c_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_receive_reward
         * @function getTypeUrl
         * @memberof mail.s2c_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_receive_reward";
        };

        return s2c_receive_reward;
    })();

    mail.c2s_delete_mails = (function() {

        /**
         * Properties of a c2s_delete_mails.
         * @memberof mail
         * @interface Ic2s_delete_mails
         * @property {Array.<number>|null} [mailUids] c2s_delete_mails mailUids
         */

        /**
         * Constructs a new c2s_delete_mails.
         * @memberof mail
         * @classdesc Represents a c2s_delete_mails.
         * @implements Ic2s_delete_mails
         * @constructor
         * @param {mail.Ic2s_delete_mails=} [properties] Properties to set
         */
        function c2s_delete_mails(properties) {
            this.mailUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_delete_mails mailUids.
         * @member {Array.<number>} mailUids
         * @memberof mail.c2s_delete_mails
         * @instance
         */
        c2s_delete_mails.prototype.mailUids = $util.emptyArray;

        /**
         * Creates a new c2s_delete_mails instance using the specified properties.
         * @function create
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.Ic2s_delete_mails=} [properties] Properties to set
         * @returns {mail.c2s_delete_mails} c2s_delete_mails instance
         */
        c2s_delete_mails.create = function create(properties) {
            return new c2s_delete_mails(properties);
        };

        /**
         * Encodes the specified c2s_delete_mails message. Does not implicitly {@link mail.c2s_delete_mails.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.Ic2s_delete_mails} message c2s_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_delete_mails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailUids != null && message.mailUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.mailUids.length; ++i)
                    writer.uint32(message.mailUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_delete_mails message, length delimited. Does not implicitly {@link mail.c2s_delete_mails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.Ic2s_delete_mails} message c2s_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_delete_mails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_delete_mails message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_delete_mails} c2s_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_delete_mails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_delete_mails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mailUids && message.mailUids.length))
                            message.mailUids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.mailUids.push(reader.uint32());
                        } else
                            message.mailUids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_delete_mails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_delete_mails} c2s_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_delete_mails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_delete_mails message.
         * @function verify
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_delete_mails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailUids != null && message.hasOwnProperty("mailUids")) {
                if (!Array.isArray(message.mailUids))
                    return "mailUids: array expected";
                for (var i = 0; i < message.mailUids.length; ++i)
                    if (!$util.isInteger(message.mailUids[i]))
                        return "mailUids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_delete_mails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_delete_mails} c2s_delete_mails
         */
        c2s_delete_mails.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_delete_mails)
                return object;
            var message = new $root.mail.c2s_delete_mails();
            if (object.mailUids) {
                if (!Array.isArray(object.mailUids))
                    throw TypeError(".mail.c2s_delete_mails.mailUids: array expected");
                message.mailUids = [];
                for (var i = 0; i < object.mailUids.length; ++i)
                    message.mailUids[i] = object.mailUids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_delete_mails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {mail.c2s_delete_mails} message c2s_delete_mails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_delete_mails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailUids = [];
            if (message.mailUids && message.mailUids.length) {
                object.mailUids = [];
                for (var j = 0; j < message.mailUids.length; ++j)
                    object.mailUids[j] = message.mailUids[j];
            }
            return object;
        };

        /**
         * Converts this c2s_delete_mails to JSON.
         * @function toJSON
         * @memberof mail.c2s_delete_mails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_delete_mails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_delete_mails
         * @function getTypeUrl
         * @memberof mail.c2s_delete_mails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_delete_mails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_delete_mails";
        };

        return c2s_delete_mails;
    })();

    mail.s2c_delete_mails = (function() {

        /**
         * Properties of a s2c_delete_mails.
         * @memberof mail
         * @interface Is2c_delete_mails
         * @property {number|null} [err] s2c_delete_mails err
         */

        /**
         * Constructs a new s2c_delete_mails.
         * @memberof mail
         * @classdesc Represents a s2c_delete_mails.
         * @implements Is2c_delete_mails
         * @constructor
         * @param {mail.Is2c_delete_mails=} [properties] Properties to set
         */
        function s2c_delete_mails(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_delete_mails err.
         * @member {number} err
         * @memberof mail.s2c_delete_mails
         * @instance
         */
        s2c_delete_mails.prototype.err = 0;

        /**
         * Creates a new s2c_delete_mails instance using the specified properties.
         * @function create
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.Is2c_delete_mails=} [properties] Properties to set
         * @returns {mail.s2c_delete_mails} s2c_delete_mails instance
         */
        s2c_delete_mails.create = function create(properties) {
            return new s2c_delete_mails(properties);
        };

        /**
         * Encodes the specified s2c_delete_mails message. Does not implicitly {@link mail.s2c_delete_mails.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.Is2c_delete_mails} message s2c_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_delete_mails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_delete_mails message, length delimited. Does not implicitly {@link mail.s2c_delete_mails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.Is2c_delete_mails} message s2c_delete_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_delete_mails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_delete_mails message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_delete_mails} s2c_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_delete_mails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_delete_mails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_delete_mails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_delete_mails} s2c_delete_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_delete_mails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_delete_mails message.
         * @function verify
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_delete_mails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_delete_mails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_delete_mails} s2c_delete_mails
         */
        s2c_delete_mails.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_delete_mails)
                return object;
            var message = new $root.mail.s2c_delete_mails();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_delete_mails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {mail.s2c_delete_mails} message s2c_delete_mails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_delete_mails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_delete_mails to JSON.
         * @function toJSON
         * @memberof mail.s2c_delete_mails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_delete_mails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_delete_mails
         * @function getTypeUrl
         * @memberof mail.s2c_delete_mails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_delete_mails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_delete_mails";
        };

        return s2c_delete_mails;
    })();

    mail.c2s_receive_all = (function() {

        /**
         * Properties of a c2s_receive_all.
         * @memberof mail
         * @interface Ic2s_receive_all
         */

        /**
         * Constructs a new c2s_receive_all.
         * @memberof mail
         * @classdesc Represents a c2s_receive_all.
         * @implements Ic2s_receive_all
         * @constructor
         * @param {mail.Ic2s_receive_all=} [properties] Properties to set
         */
        function c2s_receive_all(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_receive_all instance using the specified properties.
         * @function create
         * @memberof mail.c2s_receive_all
         * @static
         * @param {mail.Ic2s_receive_all=} [properties] Properties to set
         * @returns {mail.c2s_receive_all} c2s_receive_all instance
         */
        c2s_receive_all.create = function create(properties) {
            return new c2s_receive_all(properties);
        };

        /**
         * Encodes the specified c2s_receive_all message. Does not implicitly {@link mail.c2s_receive_all.verify|verify} messages.
         * @function encode
         * @memberof mail.c2s_receive_all
         * @static
         * @param {mail.Ic2s_receive_all} message c2s_receive_all message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_all.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_receive_all message, length delimited. Does not implicitly {@link mail.c2s_receive_all.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.c2s_receive_all
         * @static
         * @param {mail.Ic2s_receive_all} message c2s_receive_all message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_all.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_receive_all message from the specified reader or buffer.
         * @function decode
         * @memberof mail.c2s_receive_all
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.c2s_receive_all} c2s_receive_all
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_all.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.c2s_receive_all();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_receive_all message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.c2s_receive_all
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.c2s_receive_all} c2s_receive_all
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_all.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_receive_all message.
         * @function verify
         * @memberof mail.c2s_receive_all
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_receive_all.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_receive_all message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.c2s_receive_all
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.c2s_receive_all} c2s_receive_all
         */
        c2s_receive_all.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.c2s_receive_all)
                return object;
            return new $root.mail.c2s_receive_all();
        };

        /**
         * Creates a plain object from a c2s_receive_all message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.c2s_receive_all
         * @static
         * @param {mail.c2s_receive_all} message c2s_receive_all
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_receive_all.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_receive_all to JSON.
         * @function toJSON
         * @memberof mail.c2s_receive_all
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_receive_all.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_receive_all
         * @function getTypeUrl
         * @memberof mail.c2s_receive_all
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_receive_all.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.c2s_receive_all";
        };

        return c2s_receive_all;
    })();

    mail.s2c_receive_all = (function() {

        /**
         * Properties of a s2c_receive_all.
         * @memberof mail
         * @interface Is2c_receive_all
         * @property {number|null} [err] s2c_receive_all err
         */

        /**
         * Constructs a new s2c_receive_all.
         * @memberof mail
         * @classdesc Represents a s2c_receive_all.
         * @implements Is2c_receive_all
         * @constructor
         * @param {mail.Is2c_receive_all=} [properties] Properties to set
         */
        function s2c_receive_all(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_receive_all err.
         * @member {number} err
         * @memberof mail.s2c_receive_all
         * @instance
         */
        s2c_receive_all.prototype.err = 0;

        /**
         * Creates a new s2c_receive_all instance using the specified properties.
         * @function create
         * @memberof mail.s2c_receive_all
         * @static
         * @param {mail.Is2c_receive_all=} [properties] Properties to set
         * @returns {mail.s2c_receive_all} s2c_receive_all instance
         */
        s2c_receive_all.create = function create(properties) {
            return new s2c_receive_all(properties);
        };

        /**
         * Encodes the specified s2c_receive_all message. Does not implicitly {@link mail.s2c_receive_all.verify|verify} messages.
         * @function encode
         * @memberof mail.s2c_receive_all
         * @static
         * @param {mail.Is2c_receive_all} message s2c_receive_all message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_all.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_receive_all message, length delimited. Does not implicitly {@link mail.s2c_receive_all.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.s2c_receive_all
         * @static
         * @param {mail.Is2c_receive_all} message s2c_receive_all message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_all.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_receive_all message from the specified reader or buffer.
         * @function decode
         * @memberof mail.s2c_receive_all
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.s2c_receive_all} s2c_receive_all
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_all.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.s2c_receive_all();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_receive_all message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.s2c_receive_all
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.s2c_receive_all} s2c_receive_all
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_all.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_receive_all message.
         * @function verify
         * @memberof mail.s2c_receive_all
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_receive_all.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_receive_all message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.s2c_receive_all
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.s2c_receive_all} s2c_receive_all
         */
        s2c_receive_all.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.s2c_receive_all)
                return object;
            var message = new $root.mail.s2c_receive_all();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_receive_all message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.s2c_receive_all
         * @static
         * @param {mail.s2c_receive_all} message s2c_receive_all
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_receive_all.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_receive_all to JSON.
         * @function toJSON
         * @memberof mail.s2c_receive_all
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_receive_all.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_receive_all
         * @function getTypeUrl
         * @memberof mail.s2c_receive_all
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_receive_all.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.s2c_receive_all";
        };

        return s2c_receive_all;
    })();

    mail.notify_new_mails = (function() {

        /**
         * Properties of a notify_new_mails.
         * @memberof mail
         * @interface Inotify_new_mails
         * @property {Array.<mail.IMailInfo>|null} [mails] notify_new_mails mails
         */

        /**
         * Constructs a new notify_new_mails.
         * @memberof mail
         * @classdesc Represents a notify_new_mails.
         * @implements Inotify_new_mails
         * @constructor
         * @param {mail.Inotify_new_mails=} [properties] Properties to set
         */
        function notify_new_mails(properties) {
            this.mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_new_mails mails.
         * @member {Array.<mail.IMailInfo>} mails
         * @memberof mail.notify_new_mails
         * @instance
         */
        notify_new_mails.prototype.mails = $util.emptyArray;

        /**
         * Creates a new notify_new_mails instance using the specified properties.
         * @function create
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.Inotify_new_mails=} [properties] Properties to set
         * @returns {mail.notify_new_mails} notify_new_mails instance
         */
        notify_new_mails.create = function create(properties) {
            return new notify_new_mails(properties);
        };

        /**
         * Encodes the specified notify_new_mails message. Does not implicitly {@link mail.notify_new_mails.verify|verify} messages.
         * @function encode
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.Inotify_new_mails} message notify_new_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_new_mails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mails != null && message.mails.length)
                for (var i = 0; i < message.mails.length; ++i)
                    $root.mail.MailInfo.encode(message.mails[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_new_mails message, length delimited. Does not implicitly {@link mail.notify_new_mails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.Inotify_new_mails} message notify_new_mails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_new_mails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_new_mails message from the specified reader or buffer.
         * @function decode
         * @memberof mail.notify_new_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mail.notify_new_mails} notify_new_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_new_mails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mail.notify_new_mails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mails && message.mails.length))
                            message.mails = [];
                        message.mails.push($root.mail.MailInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_new_mails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mail.notify_new_mails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mail.notify_new_mails} notify_new_mails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_new_mails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_new_mails message.
         * @function verify
         * @memberof mail.notify_new_mails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_new_mails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mails != null && message.hasOwnProperty("mails")) {
                if (!Array.isArray(message.mails))
                    return "mails: array expected";
                for (var i = 0; i < message.mails.length; ++i) {
                    var error = $root.mail.MailInfo.verify(message.mails[i]);
                    if (error)
                        return "mails." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_new_mails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mail.notify_new_mails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mail.notify_new_mails} notify_new_mails
         */
        notify_new_mails.fromObject = function fromObject(object) {
            if (object instanceof $root.mail.notify_new_mails)
                return object;
            var message = new $root.mail.notify_new_mails();
            if (object.mails) {
                if (!Array.isArray(object.mails))
                    throw TypeError(".mail.notify_new_mails.mails: array expected");
                message.mails = [];
                for (var i = 0; i < object.mails.length; ++i) {
                    if (typeof object.mails[i] !== "object")
                        throw TypeError(".mail.notify_new_mails.mails: object expected");
                    message.mails[i] = $root.mail.MailInfo.fromObject(object.mails[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_new_mails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mail.notify_new_mails
         * @static
         * @param {mail.notify_new_mails} message notify_new_mails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_new_mails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mails = [];
            if (message.mails && message.mails.length) {
                object.mails = [];
                for (var j = 0; j < message.mails.length; ++j)
                    object.mails[j] = $root.mail.MailInfo.toObject(message.mails[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_new_mails to JSON.
         * @function toJSON
         * @memberof mail.notify_new_mails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_new_mails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_new_mails
         * @function getTypeUrl
         * @memberof mail.notify_new_mails
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_new_mails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mail.notify_new_mails";
        };

        return notify_new_mails;
    })();

    return mail;
})();

$root.money = (function() {

    /**
     * Namespace money.
     * @exports money
     * @namespace
     */
    var money = {};

    money.MoneyItem = (function() {

        /**
         * Properties of a MoneyItem.
         * @memberof money
         * @interface IMoneyItem
         * @property {number|null} [id] MoneyItem id
         * @property {number|null} [num] MoneyItem num
         * @property {number|null} [recoverTs] MoneyItem recoverTs
         */

        /**
         * Constructs a new MoneyItem.
         * @memberof money
         * @classdesc Represents a MoneyItem.
         * @implements IMoneyItem
         * @constructor
         * @param {money.IMoneyItem=} [properties] Properties to set
         */
        function MoneyItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoneyItem id.
         * @member {number} id
         * @memberof money.MoneyItem
         * @instance
         */
        MoneyItem.prototype.id = 0;

        /**
         * MoneyItem num.
         * @member {number} num
         * @memberof money.MoneyItem
         * @instance
         */
        MoneyItem.prototype.num = 0;

        /**
         * MoneyItem recoverTs.
         * @member {number} recoverTs
         * @memberof money.MoneyItem
         * @instance
         */
        MoneyItem.prototype.recoverTs = 0;

        /**
         * Creates a new MoneyItem instance using the specified properties.
         * @function create
         * @memberof money.MoneyItem
         * @static
         * @param {money.IMoneyItem=} [properties] Properties to set
         * @returns {money.MoneyItem} MoneyItem instance
         */
        MoneyItem.create = function create(properties) {
            return new MoneyItem(properties);
        };

        /**
         * Encodes the specified MoneyItem message. Does not implicitly {@link money.MoneyItem.verify|verify} messages.
         * @function encode
         * @memberof money.MoneyItem
         * @static
         * @param {money.IMoneyItem} message MoneyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoneyItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.recoverTs != null && Object.hasOwnProperty.call(message, "recoverTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.recoverTs);
            return writer;
        };

        /**
         * Encodes the specified MoneyItem message, length delimited. Does not implicitly {@link money.MoneyItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.MoneyItem
         * @static
         * @param {money.IMoneyItem} message MoneyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoneyItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoneyItem message from the specified reader or buffer.
         * @function decode
         * @memberof money.MoneyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.MoneyItem} MoneyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoneyItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.MoneyItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                case 3: {
                        message.recoverTs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoneyItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.MoneyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.MoneyItem} MoneyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoneyItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoneyItem message.
         * @function verify
         * @memberof money.MoneyItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoneyItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.recoverTs != null && message.hasOwnProperty("recoverTs"))
                if (!$util.isInteger(message.recoverTs))
                    return "recoverTs: integer expected";
            return null;
        };

        /**
         * Creates a MoneyItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.MoneyItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.MoneyItem} MoneyItem
         */
        MoneyItem.fromObject = function fromObject(object) {
            if (object instanceof $root.money.MoneyItem)
                return object;
            var message = new $root.money.MoneyItem();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.recoverTs != null)
                message.recoverTs = object.recoverTs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MoneyItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.MoneyItem
         * @static
         * @param {money.MoneyItem} message MoneyItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoneyItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.recoverTs = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.recoverTs != null && message.hasOwnProperty("recoverTs"))
                object.recoverTs = message.recoverTs;
            return object;
        };

        /**
         * Converts this MoneyItem to JSON.
         * @function toJSON
         * @memberof money.MoneyItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoneyItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MoneyItem
         * @function getTypeUrl
         * @memberof money.MoneyItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MoneyItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.MoneyItem";
        };

        return MoneyItem;
    })();

    money.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof money
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof money
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {money.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof money.c2s_load
         * @static
         * @param {money.Ic2s_load=} [properties] Properties to set
         * @returns {money.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link money.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof money.c2s_load
         * @static
         * @param {money.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link money.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.c2s_load
         * @static
         * @param {money.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof money.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof money.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.money.c2s_load)
                return object;
            return new $root.money.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.c2s_load
         * @static
         * @param {money.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof money.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof money.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.c2s_load";
        };

        return c2s_load;
    })();

    money.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof money
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<money.IMoneyItem>|null} [items] s2c_load items
         */

        /**
         * Constructs a new s2c_load.
         * @memberof money
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {money.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof money.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load items.
         * @member {Array.<money.IMoneyItem>} items
         * @memberof money.s2c_load
         * @instance
         */
        s2c_load.prototype.items = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof money.s2c_load
         * @static
         * @param {money.Is2c_load=} [properties] Properties to set
         * @returns {money.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link money.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof money.s2c_load
         * @static
         * @param {money.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.money.MoneyItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link money.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.s2c_load
         * @static
         * @param {money.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof money.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.money.MoneyItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof money.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.money.MoneyItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.money.s2c_load)
                return object;
            var message = new $root.money.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".money.s2c_load.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".money.s2c_load.items: object expected");
                    message.items[i] = $root.money.MoneyItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.s2c_load
         * @static
         * @param {money.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.money.MoneyItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof money.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof money.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.s2c_load";
        };

        return s2c_load;
    })();

    money.notify_items = (function() {

        /**
         * Properties of a notify_items.
         * @memberof money
         * @interface Inotify_items
         * @property {Array.<money.IMoneyItem>|null} [items] notify_items items
         */

        /**
         * Constructs a new notify_items.
         * @memberof money
         * @classdesc Represents a notify_items.
         * @implements Inotify_items
         * @constructor
         * @param {money.Inotify_items=} [properties] Properties to set
         */
        function notify_items(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_items items.
         * @member {Array.<money.IMoneyItem>} items
         * @memberof money.notify_items
         * @instance
         */
        notify_items.prototype.items = $util.emptyArray;

        /**
         * Creates a new notify_items instance using the specified properties.
         * @function create
         * @memberof money.notify_items
         * @static
         * @param {money.Inotify_items=} [properties] Properties to set
         * @returns {money.notify_items} notify_items instance
         */
        notify_items.create = function create(properties) {
            return new notify_items(properties);
        };

        /**
         * Encodes the specified notify_items message. Does not implicitly {@link money.notify_items.verify|verify} messages.
         * @function encode
         * @memberof money.notify_items
         * @static
         * @param {money.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.money.MoneyItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_items message, length delimited. Does not implicitly {@link money.notify_items.verify|verify} messages.
         * @function encodeDelimited
         * @memberof money.notify_items
         * @static
         * @param {money.Inotify_items} message notify_items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer.
         * @function decode
         * @memberof money.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {money.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.money.notify_items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.money.MoneyItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_items message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof money.notify_items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {money.notify_items} notify_items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_items message.
         * @function verify
         * @memberof money.notify_items
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.money.MoneyItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_items message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof money.notify_items
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {money.notify_items} notify_items
         */
        notify_items.fromObject = function fromObject(object) {
            if (object instanceof $root.money.notify_items)
                return object;
            var message = new $root.money.notify_items();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".money.notify_items.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".money.notify_items.items: object expected");
                    message.items[i] = $root.money.MoneyItem.fromObject(object.items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_items message. Also converts values to other types if specified.
         * @function toObject
         * @memberof money.notify_items
         * @static
         * @param {money.notify_items} message notify_items
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.money.MoneyItem.toObject(message.items[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_items to JSON.
         * @function toJSON
         * @memberof money.notify_items
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_items
         * @function getTypeUrl
         * @memberof money.notify_items
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/money.notify_items";
        };

        return notify_items;
    })();

    return money;
})();

$root.profile = (function() {

    /**
     * Namespace profile.
     * @exports profile
     * @namespace
     */
    var profile = {};

    profile.ProfileInfo = (function() {

        /**
         * Properties of a ProfileInfo.
         * @memberof profile
         * @interface IProfileInfo
         * @property {string|null} [name] ProfileInfo name
         * @property {number|null} [gender] ProfileInfo gender
         * @property {number|null} [exp] ProfileInfo exp
         * @property {number|null} [lv] ProfileInfo lv
         * @property {number|null} [headImgId] ProfileInfo headImgId
         */

        /**
         * Constructs a new ProfileInfo.
         * @memberof profile
         * @classdesc Represents a ProfileInfo.
         * @implements IProfileInfo
         * @constructor
         * @param {profile.IProfileInfo=} [properties] Properties to set
         */
        function ProfileInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProfileInfo name.
         * @member {string} name
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.name = "";

        /**
         * ProfileInfo gender.
         * @member {number} gender
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.gender = 0;

        /**
         * ProfileInfo exp.
         * @member {number} exp
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.exp = 0;

        /**
         * ProfileInfo lv.
         * @member {number} lv
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.lv = 0;

        /**
         * ProfileInfo headImgId.
         * @member {number} headImgId
         * @memberof profile.ProfileInfo
         * @instance
         */
        ProfileInfo.prototype.headImgId = 0;

        /**
         * Creates a new ProfileInfo instance using the specified properties.
         * @function create
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.IProfileInfo=} [properties] Properties to set
         * @returns {profile.ProfileInfo} ProfileInfo instance
         */
        ProfileInfo.create = function create(properties) {
            return new ProfileInfo(properties);
        };

        /**
         * Encodes the specified ProfileInfo message. Does not implicitly {@link profile.ProfileInfo.verify|verify} messages.
         * @function encode
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.IProfileInfo} message ProfileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfileInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gender);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.exp);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.lv);
            if (message.headImgId != null && Object.hasOwnProperty.call(message, "headImgId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.headImgId);
            return writer;
        };

        /**
         * Encodes the specified ProfileInfo message, length delimited. Does not implicitly {@link profile.ProfileInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.IProfileInfo} message ProfileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProfileInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProfileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof profile.ProfileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.ProfileInfo} ProfileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfileInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.ProfileInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.gender = reader.uint32();
                        break;
                    }
                case 3: {
                        message.exp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.lv = reader.uint32();
                        break;
                    }
                case 5: {
                        message.headImgId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProfileInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.ProfileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.ProfileInfo} ProfileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProfileInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProfileInfo message.
         * @function verify
         * @memberof profile.ProfileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProfileInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.headImgId != null && message.hasOwnProperty("headImgId"))
                if (!$util.isInteger(message.headImgId))
                    return "headImgId: integer expected";
            return null;
        };

        /**
         * Creates a ProfileInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.ProfileInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.ProfileInfo} ProfileInfo
         */
        ProfileInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.ProfileInfo)
                return object;
            var message = new $root.profile.ProfileInfo();
            if (object.name != null)
                message.name = String(object.name);
            if (object.gender != null)
                message.gender = object.gender >>> 0;
            if (object.exp != null)
                message.exp = object.exp >>> 0;
            if (object.lv != null)
                message.lv = object.lv >>> 0;
            if (object.headImgId != null)
                message.headImgId = object.headImgId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ProfileInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.ProfileInfo
         * @static
         * @param {profile.ProfileInfo} message ProfileInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProfileInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.gender = 0;
                object.exp = 0;
                object.lv = 0;
                object.headImgId = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.headImgId != null && message.hasOwnProperty("headImgId"))
                object.headImgId = message.headImgId;
            return object;
        };

        /**
         * Converts this ProfileInfo to JSON.
         * @function toJSON
         * @memberof profile.ProfileInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProfileInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProfileInfo
         * @function getTypeUrl
         * @memberof profile.ProfileInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProfileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.ProfileInfo";
        };

        return ProfileInfo;
    })();

    profile.c2s_create_role = (function() {

        /**
         * Properties of a c2s_create_role.
         * @memberof profile
         * @interface Ic2s_create_role
         * @property {string|null} [name] c2s_create_role name
         * @property {number|null} [gender] c2s_create_role gender
         */

        /**
         * Constructs a new c2s_create_role.
         * @memberof profile
         * @classdesc Represents a c2s_create_role.
         * @implements Ic2s_create_role
         * @constructor
         * @param {profile.Ic2s_create_role=} [properties] Properties to set
         */
        function c2s_create_role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_create_role name.
         * @member {string} name
         * @memberof profile.c2s_create_role
         * @instance
         */
        c2s_create_role.prototype.name = "";

        /**
         * c2s_create_role gender.
         * @member {number} gender
         * @memberof profile.c2s_create_role
         * @instance
         */
        c2s_create_role.prototype.gender = 0;

        /**
         * Creates a new c2s_create_role instance using the specified properties.
         * @function create
         * @memberof profile.c2s_create_role
         * @static
         * @param {profile.Ic2s_create_role=} [properties] Properties to set
         * @returns {profile.c2s_create_role} c2s_create_role instance
         */
        c2s_create_role.create = function create(properties) {
            return new c2s_create_role(properties);
        };

        /**
         * Encodes the specified c2s_create_role message. Does not implicitly {@link profile.c2s_create_role.verify|verify} messages.
         * @function encode
         * @memberof profile.c2s_create_role
         * @static
         * @param {profile.Ic2s_create_role} message c2s_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_create_role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gender);
            return writer;
        };

        /**
         * Encodes the specified c2s_create_role message, length delimited. Does not implicitly {@link profile.c2s_create_role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.c2s_create_role
         * @static
         * @param {profile.Ic2s_create_role} message c2s_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_create_role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_create_role message from the specified reader or buffer.
         * @function decode
         * @memberof profile.c2s_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.c2s_create_role} c2s_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_create_role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.c2s_create_role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.gender = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_create_role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.c2s_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.c2s_create_role} c2s_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_create_role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_create_role message.
         * @function verify
         * @memberof profile.c2s_create_role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_create_role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.gender != null && message.hasOwnProperty("gender"))
                if (!$util.isInteger(message.gender))
                    return "gender: integer expected";
            return null;
        };

        /**
         * Creates a c2s_create_role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.c2s_create_role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.c2s_create_role} c2s_create_role
         */
        c2s_create_role.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.c2s_create_role)
                return object;
            var message = new $root.profile.c2s_create_role();
            if (object.name != null)
                message.name = String(object.name);
            if (object.gender != null)
                message.gender = object.gender >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_create_role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.c2s_create_role
         * @static
         * @param {profile.c2s_create_role} message c2s_create_role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_create_role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.gender = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            return object;
        };

        /**
         * Converts this c2s_create_role to JSON.
         * @function toJSON
         * @memberof profile.c2s_create_role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_create_role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_create_role
         * @function getTypeUrl
         * @memberof profile.c2s_create_role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_create_role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.c2s_create_role";
        };

        return c2s_create_role;
    })();

    profile.s2c_create_role = (function() {

        /**
         * Properties of a s2c_create_role.
         * @memberof profile
         * @interface Is2c_create_role
         * @property {number|null} [err] s2c_create_role err
         * @property {profile.IProfileInfo|null} [profile] s2c_create_role profile
         */

        /**
         * Constructs a new s2c_create_role.
         * @memberof profile
         * @classdesc Represents a s2c_create_role.
         * @implements Is2c_create_role
         * @constructor
         * @param {profile.Is2c_create_role=} [properties] Properties to set
         */
        function s2c_create_role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_create_role err.
         * @member {number} err
         * @memberof profile.s2c_create_role
         * @instance
         */
        s2c_create_role.prototype.err = 0;

        /**
         * s2c_create_role profile.
         * @member {profile.IProfileInfo|null|undefined} profile
         * @memberof profile.s2c_create_role
         * @instance
         */
        s2c_create_role.prototype.profile = null;

        /**
         * Creates a new s2c_create_role instance using the specified properties.
         * @function create
         * @memberof profile.s2c_create_role
         * @static
         * @param {profile.Is2c_create_role=} [properties] Properties to set
         * @returns {profile.s2c_create_role} s2c_create_role instance
         */
        s2c_create_role.create = function create(properties) {
            return new s2c_create_role(properties);
        };

        /**
         * Encodes the specified s2c_create_role message. Does not implicitly {@link profile.s2c_create_role.verify|verify} messages.
         * @function encode
         * @memberof profile.s2c_create_role
         * @static
         * @param {profile.Is2c_create_role} message s2c_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_create_role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.profile.ProfileInfo.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_create_role message, length delimited. Does not implicitly {@link profile.s2c_create_role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.s2c_create_role
         * @static
         * @param {profile.Is2c_create_role} message s2c_create_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_create_role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_create_role message from the specified reader or buffer.
         * @function decode
         * @memberof profile.s2c_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.s2c_create_role} s2c_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_create_role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.s2c_create_role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.profile = $root.profile.ProfileInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_create_role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.s2c_create_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.s2c_create_role} s2c_create_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_create_role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_create_role message.
         * @function verify
         * @memberof profile.s2c_create_role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_create_role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.profile.ProfileInfo.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_create_role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.s2c_create_role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.s2c_create_role} s2c_create_role
         */
        s2c_create_role.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.s2c_create_role)
                return object;
            var message = new $root.profile.s2c_create_role();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".profile.s2c_create_role.profile: object expected");
                message.profile = $root.profile.ProfileInfo.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_create_role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.s2c_create_role
         * @static
         * @param {profile.s2c_create_role} message s2c_create_role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_create_role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.profile = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.profile.ProfileInfo.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this s2c_create_role to JSON.
         * @function toJSON
         * @memberof profile.s2c_create_role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_create_role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_create_role
         * @function getTypeUrl
         * @memberof profile.s2c_create_role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_create_role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.s2c_create_role";
        };

        return s2c_create_role;
    })();

    profile.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof profile
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof profile
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {profile.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof profile.c2s_load
         * @static
         * @param {profile.Ic2s_load=} [properties] Properties to set
         * @returns {profile.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link profile.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof profile.c2s_load
         * @static
         * @param {profile.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link profile.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.c2s_load
         * @static
         * @param {profile.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof profile.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof profile.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.c2s_load)
                return object;
            return new $root.profile.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.c2s_load
         * @static
         * @param {profile.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof profile.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof profile.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.c2s_load";
        };

        return c2s_load;
    })();

    profile.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof profile
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {profile.IProfileInfo|null} [profile] s2c_load profile
         */

        /**
         * Constructs a new s2c_load.
         * @memberof profile
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {profile.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof profile.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load profile.
         * @member {profile.IProfileInfo|null|undefined} profile
         * @memberof profile.s2c_load
         * @instance
         */
        s2c_load.prototype.profile = null;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof profile.s2c_load
         * @static
         * @param {profile.Is2c_load=} [properties] Properties to set
         * @returns {profile.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link profile.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof profile.s2c_load
         * @static
         * @param {profile.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.err);
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.profile.ProfileInfo.encode(message.profile, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link profile.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.s2c_load
         * @static
         * @param {profile.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof profile.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.int32();
                        break;
                    }
                case 2: {
                        message.profile = $root.profile.ProfileInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof profile.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.profile.ProfileInfo.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.s2c_load)
                return object;
            var message = new $root.profile.s2c_load();
            if (object.err != null)
                message.err = object.err | 0;
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".profile.s2c_load.profile: object expected");
                message.profile = $root.profile.ProfileInfo.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.s2c_load
         * @static
         * @param {profile.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.profile = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.profile.ProfileInfo.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof profile.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof profile.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.s2c_load";
        };

        return s2c_load;
    })();

    profile.notify_profile = (function() {

        /**
         * Properties of a notify_profile.
         * @memberof profile
         * @interface Inotify_profile
         * @property {profile.IProfileInfo|null} [profile] notify_profile profile
         */

        /**
         * Constructs a new notify_profile.
         * @memberof profile
         * @classdesc Represents a notify_profile.
         * @implements Inotify_profile
         * @constructor
         * @param {profile.Inotify_profile=} [properties] Properties to set
         */
        function notify_profile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_profile profile.
         * @member {profile.IProfileInfo|null|undefined} profile
         * @memberof profile.notify_profile
         * @instance
         */
        notify_profile.prototype.profile = null;

        /**
         * Creates a new notify_profile instance using the specified properties.
         * @function create
         * @memberof profile.notify_profile
         * @static
         * @param {profile.Inotify_profile=} [properties] Properties to set
         * @returns {profile.notify_profile} notify_profile instance
         */
        notify_profile.create = function create(properties) {
            return new notify_profile(properties);
        };

        /**
         * Encodes the specified notify_profile message. Does not implicitly {@link profile.notify_profile.verify|verify} messages.
         * @function encode
         * @memberof profile.notify_profile
         * @static
         * @param {profile.Inotify_profile} message notify_profile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_profile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                $root.profile.ProfileInfo.encode(message.profile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_profile message, length delimited. Does not implicitly {@link profile.notify_profile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof profile.notify_profile
         * @static
         * @param {profile.Inotify_profile} message notify_profile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_profile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_profile message from the specified reader or buffer.
         * @function decode
         * @memberof profile.notify_profile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {profile.notify_profile} notify_profile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_profile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.profile.notify_profile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.profile = $root.profile.ProfileInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_profile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof profile.notify_profile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {profile.notify_profile} notify_profile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_profile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_profile message.
         * @function verify
         * @memberof profile.notify_profile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_profile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.profile != null && message.hasOwnProperty("profile")) {
                var error = $root.profile.ProfileInfo.verify(message.profile);
                if (error)
                    return "profile." + error;
            }
            return null;
        };

        /**
         * Creates a notify_profile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof profile.notify_profile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {profile.notify_profile} notify_profile
         */
        notify_profile.fromObject = function fromObject(object) {
            if (object instanceof $root.profile.notify_profile)
                return object;
            var message = new $root.profile.notify_profile();
            if (object.profile != null) {
                if (typeof object.profile !== "object")
                    throw TypeError(".profile.notify_profile.profile: object expected");
                message.profile = $root.profile.ProfileInfo.fromObject(object.profile);
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_profile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof profile.notify_profile
         * @static
         * @param {profile.notify_profile} message notify_profile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_profile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.profile = null;
            if (message.profile != null && message.hasOwnProperty("profile"))
                object.profile = $root.profile.ProfileInfo.toObject(message.profile, options);
            return object;
        };

        /**
         * Converts this notify_profile to JSON.
         * @function toJSON
         * @memberof profile.notify_profile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_profile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_profile
         * @function getTypeUrl
         * @memberof profile.notify_profile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_profile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/profile.notify_profile";
        };

        return notify_profile;
    })();

    return profile;
})();

$root.shop = (function() {

    /**
     * Namespace shop.
     * @exports shop
     * @namespace
     */
    var shop = {};

    shop.ItemInfo = (function() {

        /**
         * Properties of an ItemInfo.
         * @memberof shop
         * @interface IItemInfo
         * @property {number|null} [id] ItemInfo id
         * @property {number|null} [buyNum] ItemInfo buyNum
         */

        /**
         * Constructs a new ItemInfo.
         * @memberof shop
         * @classdesc Represents an ItemInfo.
         * @implements IItemInfo
         * @constructor
         * @param {shop.IItemInfo=} [properties] Properties to set
         */
        function ItemInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemInfo id.
         * @member {number} id
         * @memberof shop.ItemInfo
         * @instance
         */
        ItemInfo.prototype.id = 0;

        /**
         * ItemInfo buyNum.
         * @member {number} buyNum
         * @memberof shop.ItemInfo
         * @instance
         */
        ItemInfo.prototype.buyNum = 0;

        /**
         * Creates a new ItemInfo instance using the specified properties.
         * @function create
         * @memberof shop.ItemInfo
         * @static
         * @param {shop.IItemInfo=} [properties] Properties to set
         * @returns {shop.ItemInfo} ItemInfo instance
         */
        ItemInfo.create = function create(properties) {
            return new ItemInfo(properties);
        };

        /**
         * Encodes the specified ItemInfo message. Does not implicitly {@link shop.ItemInfo.verify|verify} messages.
         * @function encode
         * @memberof shop.ItemInfo
         * @static
         * @param {shop.IItemInfo} message ItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.buyNum != null && Object.hasOwnProperty.call(message, "buyNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.buyNum);
            return writer;
        };

        /**
         * Encodes the specified ItemInfo message, length delimited. Does not implicitly {@link shop.ItemInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof shop.ItemInfo
         * @static
         * @param {shop.IItemInfo} message ItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemInfo message from the specified reader or buffer.
         * @function decode
         * @memberof shop.ItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {shop.ItemInfo} ItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.shop.ItemInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.buyNum = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof shop.ItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {shop.ItemInfo} ItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemInfo message.
         * @function verify
         * @memberof shop.ItemInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.buyNum != null && message.hasOwnProperty("buyNum"))
                if (!$util.isInteger(message.buyNum))
                    return "buyNum: integer expected";
            return null;
        };

        /**
         * Creates an ItemInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof shop.ItemInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {shop.ItemInfo} ItemInfo
         */
        ItemInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.shop.ItemInfo)
                return object;
            var message = new $root.shop.ItemInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.buyNum != null)
                message.buyNum = object.buyNum >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ItemInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof shop.ItemInfo
         * @static
         * @param {shop.ItemInfo} message ItemInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.buyNum = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.buyNum != null && message.hasOwnProperty("buyNum"))
                object.buyNum = message.buyNum;
            return object;
        };

        /**
         * Converts this ItemInfo to JSON.
         * @function toJSON
         * @memberof shop.ItemInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ItemInfo
         * @function getTypeUrl
         * @memberof shop.ItemInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ItemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/shop.ItemInfo";
        };

        return ItemInfo;
    })();

    shop.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof shop
         * @interface Ic2s_load
         * @property {number|null} [shopId] c2s_load shopId
         */

        /**
         * Constructs a new c2s_load.
         * @memberof shop
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {shop.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load shopId.
         * @member {number} shopId
         * @memberof shop.c2s_load
         * @instance
         */
        c2s_load.prototype.shopId = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof shop.c2s_load
         * @static
         * @param {shop.Ic2s_load=} [properties] Properties to set
         * @returns {shop.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link shop.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof shop.c2s_load
         * @static
         * @param {shop.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shopId != null && Object.hasOwnProperty.call(message, "shopId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.shopId);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link shop.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof shop.c2s_load
         * @static
         * @param {shop.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof shop.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {shop.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.shop.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.shopId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof shop.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {shop.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof shop.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shopId != null && message.hasOwnProperty("shopId"))
                if (!$util.isInteger(message.shopId))
                    return "shopId: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof shop.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {shop.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.shop.c2s_load)
                return object;
            var message = new $root.shop.c2s_load();
            if (object.shopId != null)
                message.shopId = object.shopId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof shop.c2s_load
         * @static
         * @param {shop.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.shopId = 0;
            if (message.shopId != null && message.hasOwnProperty("shopId"))
                object.shopId = message.shopId;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof shop.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof shop.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/shop.c2s_load";
        };

        return c2s_load;
    })();

    shop.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof shop
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<shop.IItemInfo>|null} [items] s2c_load items
         * @property {number|null} [time] s2c_load time
         */

        /**
         * Constructs a new s2c_load.
         * @memberof shop
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {shop.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof shop.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load items.
         * @member {Array.<shop.IItemInfo>} items
         * @memberof shop.s2c_load
         * @instance
         */
        s2c_load.prototype.items = $util.emptyArray;

        /**
         * s2c_load time.
         * @member {number} time
         * @memberof shop.s2c_load
         * @instance
         */
        s2c_load.prototype.time = 0;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof shop.s2c_load
         * @static
         * @param {shop.Is2c_load=} [properties] Properties to set
         * @returns {shop.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link shop.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof shop.s2c_load
         * @static
         * @param {shop.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.shop.ItemInfo.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.time);
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link shop.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof shop.s2c_load
         * @static
         * @param {shop.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof shop.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {shop.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.shop.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.shop.ItemInfo.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.time = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof shop.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {shop.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof shop.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.shop.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof shop.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {shop.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.shop.s2c_load)
                return object;
            var message = new $root.shop.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".shop.s2c_load.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".shop.s2c_load.items: object expected");
                    message.items[i] = $root.shop.ItemInfo.fromObject(object.items[i]);
                }
            }
            if (object.time != null)
                message.time = object.time >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof shop.s2c_load
         * @static
         * @param {shop.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults) {
                object.err = 0;
                object.time = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.shop.ItemInfo.toObject(message.items[j], options);
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof shop.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof shop.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/shop.s2c_load";
        };

        return s2c_load;
    })();

    shop.c2s_buy = (function() {

        /**
         * Properties of a c2s_buy.
         * @memberof shop
         * @interface Ic2s_buy
         * @property {number|null} [shopId] c2s_buy shopId
         * @property {number|null} [shopItemId] c2s_buy shopItemId
         * @property {number|null} [num] c2s_buy num
         */

        /**
         * Constructs a new c2s_buy.
         * @memberof shop
         * @classdesc Represents a c2s_buy.
         * @implements Ic2s_buy
         * @constructor
         * @param {shop.Ic2s_buy=} [properties] Properties to set
         */
        function c2s_buy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_buy shopId.
         * @member {number} shopId
         * @memberof shop.c2s_buy
         * @instance
         */
        c2s_buy.prototype.shopId = 0;

        /**
         * c2s_buy shopItemId.
         * @member {number} shopItemId
         * @memberof shop.c2s_buy
         * @instance
         */
        c2s_buy.prototype.shopItemId = 0;

        /**
         * c2s_buy num.
         * @member {number} num
         * @memberof shop.c2s_buy
         * @instance
         */
        c2s_buy.prototype.num = 0;

        /**
         * Creates a new c2s_buy instance using the specified properties.
         * @function create
         * @memberof shop.c2s_buy
         * @static
         * @param {shop.Ic2s_buy=} [properties] Properties to set
         * @returns {shop.c2s_buy} c2s_buy instance
         */
        c2s_buy.create = function create(properties) {
            return new c2s_buy(properties);
        };

        /**
         * Encodes the specified c2s_buy message. Does not implicitly {@link shop.c2s_buy.verify|verify} messages.
         * @function encode
         * @memberof shop.c2s_buy
         * @static
         * @param {shop.Ic2s_buy} message c2s_buy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_buy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shopId != null && Object.hasOwnProperty.call(message, "shopId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.shopId);
            if (message.shopItemId != null && Object.hasOwnProperty.call(message, "shopItemId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.shopItemId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified c2s_buy message, length delimited. Does not implicitly {@link shop.c2s_buy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof shop.c2s_buy
         * @static
         * @param {shop.Ic2s_buy} message c2s_buy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_buy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_buy message from the specified reader or buffer.
         * @function decode
         * @memberof shop.c2s_buy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {shop.c2s_buy} c2s_buy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_buy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.shop.c2s_buy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.shopId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.shopItemId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_buy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof shop.c2s_buy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {shop.c2s_buy} c2s_buy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_buy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_buy message.
         * @function verify
         * @memberof shop.c2s_buy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_buy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shopId != null && message.hasOwnProperty("shopId"))
                if (!$util.isInteger(message.shopId))
                    return "shopId: integer expected";
            if (message.shopItemId != null && message.hasOwnProperty("shopItemId"))
                if (!$util.isInteger(message.shopItemId))
                    return "shopItemId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a c2s_buy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof shop.c2s_buy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {shop.c2s_buy} c2s_buy
         */
        c2s_buy.fromObject = function fromObject(object) {
            if (object instanceof $root.shop.c2s_buy)
                return object;
            var message = new $root.shop.c2s_buy();
            if (object.shopId != null)
                message.shopId = object.shopId >>> 0;
            if (object.shopItemId != null)
                message.shopItemId = object.shopItemId >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_buy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof shop.c2s_buy
         * @static
         * @param {shop.c2s_buy} message c2s_buy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_buy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.shopId = 0;
                object.shopItemId = 0;
                object.num = 0;
            }
            if (message.shopId != null && message.hasOwnProperty("shopId"))
                object.shopId = message.shopId;
            if (message.shopItemId != null && message.hasOwnProperty("shopItemId"))
                object.shopItemId = message.shopItemId;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this c2s_buy to JSON.
         * @function toJSON
         * @memberof shop.c2s_buy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_buy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_buy
         * @function getTypeUrl
         * @memberof shop.c2s_buy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_buy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/shop.c2s_buy";
        };

        return c2s_buy;
    })();

    shop.s2c_buy = (function() {

        /**
         * Properties of a s2c_buy.
         * @memberof shop
         * @interface Is2c_buy
         * @property {number|null} [err] s2c_buy err
         */

        /**
         * Constructs a new s2c_buy.
         * @memberof shop
         * @classdesc Represents a s2c_buy.
         * @implements Is2c_buy
         * @constructor
         * @param {shop.Is2c_buy=} [properties] Properties to set
         */
        function s2c_buy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_buy err.
         * @member {number} err
         * @memberof shop.s2c_buy
         * @instance
         */
        s2c_buy.prototype.err = 0;

        /**
         * Creates a new s2c_buy instance using the specified properties.
         * @function create
         * @memberof shop.s2c_buy
         * @static
         * @param {shop.Is2c_buy=} [properties] Properties to set
         * @returns {shop.s2c_buy} s2c_buy instance
         */
        s2c_buy.create = function create(properties) {
            return new s2c_buy(properties);
        };

        /**
         * Encodes the specified s2c_buy message. Does not implicitly {@link shop.s2c_buy.verify|verify} messages.
         * @function encode
         * @memberof shop.s2c_buy
         * @static
         * @param {shop.Is2c_buy} message s2c_buy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_buy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_buy message, length delimited. Does not implicitly {@link shop.s2c_buy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof shop.s2c_buy
         * @static
         * @param {shop.Is2c_buy} message s2c_buy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_buy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_buy message from the specified reader or buffer.
         * @function decode
         * @memberof shop.s2c_buy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {shop.s2c_buy} s2c_buy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_buy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.shop.s2c_buy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_buy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof shop.s2c_buy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {shop.s2c_buy} s2c_buy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_buy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_buy message.
         * @function verify
         * @memberof shop.s2c_buy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_buy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_buy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof shop.s2c_buy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {shop.s2c_buy} s2c_buy
         */
        s2c_buy.fromObject = function fromObject(object) {
            if (object instanceof $root.shop.s2c_buy)
                return object;
            var message = new $root.shop.s2c_buy();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_buy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof shop.s2c_buy
         * @static
         * @param {shop.s2c_buy} message s2c_buy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_buy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_buy to JSON.
         * @function toJSON
         * @memberof shop.s2c_buy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_buy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_buy
         * @function getTypeUrl
         * @memberof shop.s2c_buy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_buy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/shop.s2c_buy";
        };

        return s2c_buy;
    })();

    return shop;
})();

$root.soldier = (function() {

    /**
     * Namespace soldier.
     * @exports soldier
     * @namespace
     */
    var soldier = {};

    soldier.SoldierInfo = (function() {

        /**
         * Properties of a SoldierInfo.
         * @memberof soldier
         * @interface ISoldierInfo
         * @property {number|null} [id] SoldierInfo id
         * @property {number|null} [lv] SoldierInfo lv
         * @property {Object.<string,number>|null} [attrs] SoldierInfo attrs
         */

        /**
         * Constructs a new SoldierInfo.
         * @memberof soldier
         * @classdesc Represents a SoldierInfo.
         * @implements ISoldierInfo
         * @constructor
         * @param {soldier.ISoldierInfo=} [properties] Properties to set
         */
        function SoldierInfo(properties) {
            this.attrs = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SoldierInfo id.
         * @member {number} id
         * @memberof soldier.SoldierInfo
         * @instance
         */
        SoldierInfo.prototype.id = 0;

        /**
         * SoldierInfo lv.
         * @member {number} lv
         * @memberof soldier.SoldierInfo
         * @instance
         */
        SoldierInfo.prototype.lv = 0;

        /**
         * SoldierInfo attrs.
         * @member {Object.<string,number>} attrs
         * @memberof soldier.SoldierInfo
         * @instance
         */
        SoldierInfo.prototype.attrs = $util.emptyObject;

        /**
         * Creates a new SoldierInfo instance using the specified properties.
         * @function create
         * @memberof soldier.SoldierInfo
         * @static
         * @param {soldier.ISoldierInfo=} [properties] Properties to set
         * @returns {soldier.SoldierInfo} SoldierInfo instance
         */
        SoldierInfo.create = function create(properties) {
            return new SoldierInfo(properties);
        };

        /**
         * Encodes the specified SoldierInfo message. Does not implicitly {@link soldier.SoldierInfo.verify|verify} messages.
         * @function encode
         * @memberof soldier.SoldierInfo
         * @static
         * @param {soldier.ISoldierInfo} message SoldierInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SoldierInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lv);
            if (message.attrs != null && Object.hasOwnProperty.call(message, "attrs"))
                for (var keys = Object.keys(message.attrs), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.attrs[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SoldierInfo message, length delimited. Does not implicitly {@link soldier.SoldierInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.SoldierInfo
         * @static
         * @param {soldier.ISoldierInfo} message SoldierInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SoldierInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SoldierInfo message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.SoldierInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.SoldierInfo} SoldierInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SoldierInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.SoldierInfo(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.lv = reader.uint32();
                        break;
                    }
                case 3: {
                        if (message.attrs === $util.emptyObject)
                            message.attrs = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = 0;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attrs[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SoldierInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.SoldierInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.SoldierInfo} SoldierInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SoldierInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SoldierInfo message.
         * @function verify
         * @memberof soldier.SoldierInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SoldierInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.attrs != null && message.hasOwnProperty("attrs")) {
                if (!$util.isObject(message.attrs))
                    return "attrs: object expected";
                var key = Object.keys(message.attrs);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "attrs: integer key{k:uint32} expected";
                    if (!$util.isInteger(message.attrs[key[i]]))
                        return "attrs: integer{k:uint32} expected";
                }
            }
            return null;
        };

        /**
         * Creates a SoldierInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.SoldierInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.SoldierInfo} SoldierInfo
         */
        SoldierInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.SoldierInfo)
                return object;
            var message = new $root.soldier.SoldierInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.lv != null)
                message.lv = object.lv >>> 0;
            if (object.attrs) {
                if (typeof object.attrs !== "object")
                    throw TypeError(".soldier.SoldierInfo.attrs: object expected");
                message.attrs = {};
                for (var keys = Object.keys(object.attrs), i = 0; i < keys.length; ++i)
                    message.attrs[keys[i]] = object.attrs[keys[i]] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a SoldierInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.SoldierInfo
         * @static
         * @param {soldier.SoldierInfo} message SoldierInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SoldierInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.attrs = {};
            if (options.defaults) {
                object.id = 0;
                object.lv = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            var keys2;
            if (message.attrs && (keys2 = Object.keys(message.attrs)).length) {
                object.attrs = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.attrs[keys2[j]] = message.attrs[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this SoldierInfo to JSON.
         * @function toJSON
         * @memberof soldier.SoldierInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SoldierInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SoldierInfo
         * @function getTypeUrl
         * @memberof soldier.SoldierInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SoldierInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.SoldierInfo";
        };

        return SoldierInfo;
    })();

    soldier.PendantInfo = (function() {

        /**
         * Properties of a PendantInfo.
         * @memberof soldier
         * @interface IPendantInfo
         * @property {number|null} [id] PendantInfo id
         * @property {number|null} [lv] PendantInfo lv
         */

        /**
         * Constructs a new PendantInfo.
         * @memberof soldier
         * @classdesc Represents a PendantInfo.
         * @implements IPendantInfo
         * @constructor
         * @param {soldier.IPendantInfo=} [properties] Properties to set
         */
        function PendantInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendantInfo id.
         * @member {number} id
         * @memberof soldier.PendantInfo
         * @instance
         */
        PendantInfo.prototype.id = 0;

        /**
         * PendantInfo lv.
         * @member {number} lv
         * @memberof soldier.PendantInfo
         * @instance
         */
        PendantInfo.prototype.lv = 0;

        /**
         * Creates a new PendantInfo instance using the specified properties.
         * @function create
         * @memberof soldier.PendantInfo
         * @static
         * @param {soldier.IPendantInfo=} [properties] Properties to set
         * @returns {soldier.PendantInfo} PendantInfo instance
         */
        PendantInfo.create = function create(properties) {
            return new PendantInfo(properties);
        };

        /**
         * Encodes the specified PendantInfo message. Does not implicitly {@link soldier.PendantInfo.verify|verify} messages.
         * @function encode
         * @memberof soldier.PendantInfo
         * @static
         * @param {soldier.IPendantInfo} message PendantInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendantInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lv);
            return writer;
        };

        /**
         * Encodes the specified PendantInfo message, length delimited. Does not implicitly {@link soldier.PendantInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.PendantInfo
         * @static
         * @param {soldier.IPendantInfo} message PendantInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendantInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendantInfo message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.PendantInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.PendantInfo} PendantInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendantInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.PendantInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.lv = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendantInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.PendantInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.PendantInfo} PendantInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendantInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendantInfo message.
         * @function verify
         * @memberof soldier.PendantInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendantInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            return null;
        };

        /**
         * Creates a PendantInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.PendantInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.PendantInfo} PendantInfo
         */
        PendantInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.PendantInfo)
                return object;
            var message = new $root.soldier.PendantInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.lv != null)
                message.lv = object.lv >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendantInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.PendantInfo
         * @static
         * @param {soldier.PendantInfo} message PendantInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendantInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.lv = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            return object;
        };

        /**
         * Converts this PendantInfo to JSON.
         * @function toJSON
         * @memberof soldier.PendantInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendantInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PendantInfo
         * @function getTypeUrl
         * @memberof soldier.PendantInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PendantInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.PendantInfo";
        };

        return PendantInfo;
    })();

    soldier.TrainInfo = (function() {

        /**
         * Properties of a TrainInfo.
         * @memberof soldier
         * @interface ITrainInfo
         * @property {number|null} [id] TrainInfo id
         * @property {number|null} [lv] TrainInfo lv
         */

        /**
         * Constructs a new TrainInfo.
         * @memberof soldier
         * @classdesc Represents a TrainInfo.
         * @implements ITrainInfo
         * @constructor
         * @param {soldier.ITrainInfo=} [properties] Properties to set
         */
        function TrainInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrainInfo id.
         * @member {number} id
         * @memberof soldier.TrainInfo
         * @instance
         */
        TrainInfo.prototype.id = 0;

        /**
         * TrainInfo lv.
         * @member {number} lv
         * @memberof soldier.TrainInfo
         * @instance
         */
        TrainInfo.prototype.lv = 0;

        /**
         * Creates a new TrainInfo instance using the specified properties.
         * @function create
         * @memberof soldier.TrainInfo
         * @static
         * @param {soldier.ITrainInfo=} [properties] Properties to set
         * @returns {soldier.TrainInfo} TrainInfo instance
         */
        TrainInfo.create = function create(properties) {
            return new TrainInfo(properties);
        };

        /**
         * Encodes the specified TrainInfo message. Does not implicitly {@link soldier.TrainInfo.verify|verify} messages.
         * @function encode
         * @memberof soldier.TrainInfo
         * @static
         * @param {soldier.ITrainInfo} message TrainInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrainInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lv);
            return writer;
        };

        /**
         * Encodes the specified TrainInfo message, length delimited. Does not implicitly {@link soldier.TrainInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.TrainInfo
         * @static
         * @param {soldier.ITrainInfo} message TrainInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrainInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrainInfo message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.TrainInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.TrainInfo} TrainInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrainInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.TrainInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.lv = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrainInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.TrainInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.TrainInfo} TrainInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrainInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrainInfo message.
         * @function verify
         * @memberof soldier.TrainInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrainInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            return null;
        };

        /**
         * Creates a TrainInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.TrainInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.TrainInfo} TrainInfo
         */
        TrainInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.TrainInfo)
                return object;
            var message = new $root.soldier.TrainInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.lv != null)
                message.lv = object.lv >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TrainInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.TrainInfo
         * @static
         * @param {soldier.TrainInfo} message TrainInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrainInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.lv = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            return object;
        };

        /**
         * Converts this TrainInfo to JSON.
         * @function toJSON
         * @memberof soldier.TrainInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrainInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrainInfo
         * @function getTypeUrl
         * @memberof soldier.TrainInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrainInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.TrainInfo";
        };

        return TrainInfo;
    })();

    soldier.c2s_load_soldier = (function() {

        /**
         * Properties of a c2s_load_soldier.
         * @memberof soldier
         * @interface Ic2s_load_soldier
         */

        /**
         * Constructs a new c2s_load_soldier.
         * @memberof soldier
         * @classdesc Represents a c2s_load_soldier.
         * @implements Ic2s_load_soldier
         * @constructor
         * @param {soldier.Ic2s_load_soldier=} [properties] Properties to set
         */
        function c2s_load_soldier(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load_soldier instance using the specified properties.
         * @function create
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {soldier.Ic2s_load_soldier=} [properties] Properties to set
         * @returns {soldier.c2s_load_soldier} c2s_load_soldier instance
         */
        c2s_load_soldier.create = function create(properties) {
            return new c2s_load_soldier(properties);
        };

        /**
         * Encodes the specified c2s_load_soldier message. Does not implicitly {@link soldier.c2s_load_soldier.verify|verify} messages.
         * @function encode
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {soldier.Ic2s_load_soldier} message c2s_load_soldier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_soldier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load_soldier message, length delimited. Does not implicitly {@link soldier.c2s_load_soldier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {soldier.Ic2s_load_soldier} message c2s_load_soldier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_soldier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load_soldier message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.c2s_load_soldier} c2s_load_soldier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_soldier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.c2s_load_soldier();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load_soldier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.c2s_load_soldier} c2s_load_soldier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_soldier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load_soldier message.
         * @function verify
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load_soldier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load_soldier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.c2s_load_soldier} c2s_load_soldier
         */
        c2s_load_soldier.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.c2s_load_soldier)
                return object;
            return new $root.soldier.c2s_load_soldier();
        };

        /**
         * Creates a plain object from a c2s_load_soldier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {soldier.c2s_load_soldier} message c2s_load_soldier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load_soldier.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load_soldier to JSON.
         * @function toJSON
         * @memberof soldier.c2s_load_soldier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load_soldier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load_soldier
         * @function getTypeUrl
         * @memberof soldier.c2s_load_soldier
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load_soldier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.c2s_load_soldier";
        };

        return c2s_load_soldier;
    })();

    soldier.s2c_load_soldier = (function() {

        /**
         * Properties of a s2c_load_soldier.
         * @memberof soldier
         * @interface Is2c_load_soldier
         * @property {number|null} [err] s2c_load_soldier err
         * @property {Array.<soldier.ISoldierInfo>|null} [soldiers] s2c_load_soldier soldiers
         */

        /**
         * Constructs a new s2c_load_soldier.
         * @memberof soldier
         * @classdesc Represents a s2c_load_soldier.
         * @implements Is2c_load_soldier
         * @constructor
         * @param {soldier.Is2c_load_soldier=} [properties] Properties to set
         */
        function s2c_load_soldier(properties) {
            this.soldiers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load_soldier err.
         * @member {number} err
         * @memberof soldier.s2c_load_soldier
         * @instance
         */
        s2c_load_soldier.prototype.err = 0;

        /**
         * s2c_load_soldier soldiers.
         * @member {Array.<soldier.ISoldierInfo>} soldiers
         * @memberof soldier.s2c_load_soldier
         * @instance
         */
        s2c_load_soldier.prototype.soldiers = $util.emptyArray;

        /**
         * Creates a new s2c_load_soldier instance using the specified properties.
         * @function create
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {soldier.Is2c_load_soldier=} [properties] Properties to set
         * @returns {soldier.s2c_load_soldier} s2c_load_soldier instance
         */
        s2c_load_soldier.create = function create(properties) {
            return new s2c_load_soldier(properties);
        };

        /**
         * Encodes the specified s2c_load_soldier message. Does not implicitly {@link soldier.s2c_load_soldier.verify|verify} messages.
         * @function encode
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {soldier.Is2c_load_soldier} message s2c_load_soldier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_soldier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.soldiers != null && message.soldiers.length)
                for (var i = 0; i < message.soldiers.length; ++i)
                    $root.soldier.SoldierInfo.encode(message.soldiers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load_soldier message, length delimited. Does not implicitly {@link soldier.s2c_load_soldier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {soldier.Is2c_load_soldier} message s2c_load_soldier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_soldier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load_soldier message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.s2c_load_soldier} s2c_load_soldier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_soldier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.s2c_load_soldier();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.soldiers && message.soldiers.length))
                            message.soldiers = [];
                        message.soldiers.push($root.soldier.SoldierInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load_soldier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.s2c_load_soldier} s2c_load_soldier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_soldier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load_soldier message.
         * @function verify
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load_soldier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.soldiers != null && message.hasOwnProperty("soldiers")) {
                if (!Array.isArray(message.soldiers))
                    return "soldiers: array expected";
                for (var i = 0; i < message.soldiers.length; ++i) {
                    var error = $root.soldier.SoldierInfo.verify(message.soldiers[i]);
                    if (error)
                        return "soldiers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load_soldier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.s2c_load_soldier} s2c_load_soldier
         */
        s2c_load_soldier.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.s2c_load_soldier)
                return object;
            var message = new $root.soldier.s2c_load_soldier();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.soldiers) {
                if (!Array.isArray(object.soldiers))
                    throw TypeError(".soldier.s2c_load_soldier.soldiers: array expected");
                message.soldiers = [];
                for (var i = 0; i < object.soldiers.length; ++i) {
                    if (typeof object.soldiers[i] !== "object")
                        throw TypeError(".soldier.s2c_load_soldier.soldiers: object expected");
                    message.soldiers[i] = $root.soldier.SoldierInfo.fromObject(object.soldiers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load_soldier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {soldier.s2c_load_soldier} message s2c_load_soldier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load_soldier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.soldiers = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.soldiers && message.soldiers.length) {
                object.soldiers = [];
                for (var j = 0; j < message.soldiers.length; ++j)
                    object.soldiers[j] = $root.soldier.SoldierInfo.toObject(message.soldiers[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load_soldier to JSON.
         * @function toJSON
         * @memberof soldier.s2c_load_soldier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load_soldier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load_soldier
         * @function getTypeUrl
         * @memberof soldier.s2c_load_soldier
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load_soldier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.s2c_load_soldier";
        };

        return s2c_load_soldier;
    })();

    soldier.c2s_load_pendant = (function() {

        /**
         * Properties of a c2s_load_pendant.
         * @memberof soldier
         * @interface Ic2s_load_pendant
         */

        /**
         * Constructs a new c2s_load_pendant.
         * @memberof soldier
         * @classdesc Represents a c2s_load_pendant.
         * @implements Ic2s_load_pendant
         * @constructor
         * @param {soldier.Ic2s_load_pendant=} [properties] Properties to set
         */
        function c2s_load_pendant(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load_pendant instance using the specified properties.
         * @function create
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {soldier.Ic2s_load_pendant=} [properties] Properties to set
         * @returns {soldier.c2s_load_pendant} c2s_load_pendant instance
         */
        c2s_load_pendant.create = function create(properties) {
            return new c2s_load_pendant(properties);
        };

        /**
         * Encodes the specified c2s_load_pendant message. Does not implicitly {@link soldier.c2s_load_pendant.verify|verify} messages.
         * @function encode
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {soldier.Ic2s_load_pendant} message c2s_load_pendant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_pendant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load_pendant message, length delimited. Does not implicitly {@link soldier.c2s_load_pendant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {soldier.Ic2s_load_pendant} message c2s_load_pendant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_pendant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load_pendant message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.c2s_load_pendant} c2s_load_pendant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_pendant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.c2s_load_pendant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load_pendant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.c2s_load_pendant} c2s_load_pendant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_pendant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load_pendant message.
         * @function verify
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load_pendant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load_pendant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.c2s_load_pendant} c2s_load_pendant
         */
        c2s_load_pendant.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.c2s_load_pendant)
                return object;
            return new $root.soldier.c2s_load_pendant();
        };

        /**
         * Creates a plain object from a c2s_load_pendant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {soldier.c2s_load_pendant} message c2s_load_pendant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load_pendant.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load_pendant to JSON.
         * @function toJSON
         * @memberof soldier.c2s_load_pendant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load_pendant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load_pendant
         * @function getTypeUrl
         * @memberof soldier.c2s_load_pendant
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load_pendant.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.c2s_load_pendant";
        };

        return c2s_load_pendant;
    })();

    soldier.s2c_load_pendant = (function() {

        /**
         * Properties of a s2c_load_pendant.
         * @memberof soldier
         * @interface Is2c_load_pendant
         * @property {number|null} [err] s2c_load_pendant err
         * @property {Array.<soldier.IPendantInfo>|null} [pendants] s2c_load_pendant pendants
         */

        /**
         * Constructs a new s2c_load_pendant.
         * @memberof soldier
         * @classdesc Represents a s2c_load_pendant.
         * @implements Is2c_load_pendant
         * @constructor
         * @param {soldier.Is2c_load_pendant=} [properties] Properties to set
         */
        function s2c_load_pendant(properties) {
            this.pendants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load_pendant err.
         * @member {number} err
         * @memberof soldier.s2c_load_pendant
         * @instance
         */
        s2c_load_pendant.prototype.err = 0;

        /**
         * s2c_load_pendant pendants.
         * @member {Array.<soldier.IPendantInfo>} pendants
         * @memberof soldier.s2c_load_pendant
         * @instance
         */
        s2c_load_pendant.prototype.pendants = $util.emptyArray;

        /**
         * Creates a new s2c_load_pendant instance using the specified properties.
         * @function create
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {soldier.Is2c_load_pendant=} [properties] Properties to set
         * @returns {soldier.s2c_load_pendant} s2c_load_pendant instance
         */
        s2c_load_pendant.create = function create(properties) {
            return new s2c_load_pendant(properties);
        };

        /**
         * Encodes the specified s2c_load_pendant message. Does not implicitly {@link soldier.s2c_load_pendant.verify|verify} messages.
         * @function encode
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {soldier.Is2c_load_pendant} message s2c_load_pendant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_pendant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.pendants != null && message.pendants.length)
                for (var i = 0; i < message.pendants.length; ++i)
                    $root.soldier.PendantInfo.encode(message.pendants[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load_pendant message, length delimited. Does not implicitly {@link soldier.s2c_load_pendant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {soldier.Is2c_load_pendant} message s2c_load_pendant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_pendant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load_pendant message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.s2c_load_pendant} s2c_load_pendant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_pendant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.s2c_load_pendant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.pendants && message.pendants.length))
                            message.pendants = [];
                        message.pendants.push($root.soldier.PendantInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load_pendant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.s2c_load_pendant} s2c_load_pendant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_pendant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load_pendant message.
         * @function verify
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load_pendant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.pendants != null && message.hasOwnProperty("pendants")) {
                if (!Array.isArray(message.pendants))
                    return "pendants: array expected";
                for (var i = 0; i < message.pendants.length; ++i) {
                    var error = $root.soldier.PendantInfo.verify(message.pendants[i]);
                    if (error)
                        return "pendants." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load_pendant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.s2c_load_pendant} s2c_load_pendant
         */
        s2c_load_pendant.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.s2c_load_pendant)
                return object;
            var message = new $root.soldier.s2c_load_pendant();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.pendants) {
                if (!Array.isArray(object.pendants))
                    throw TypeError(".soldier.s2c_load_pendant.pendants: array expected");
                message.pendants = [];
                for (var i = 0; i < object.pendants.length; ++i) {
                    if (typeof object.pendants[i] !== "object")
                        throw TypeError(".soldier.s2c_load_pendant.pendants: object expected");
                    message.pendants[i] = $root.soldier.PendantInfo.fromObject(object.pendants[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load_pendant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {soldier.s2c_load_pendant} message s2c_load_pendant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load_pendant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pendants = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.pendants && message.pendants.length) {
                object.pendants = [];
                for (var j = 0; j < message.pendants.length; ++j)
                    object.pendants[j] = $root.soldier.PendantInfo.toObject(message.pendants[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load_pendant to JSON.
         * @function toJSON
         * @memberof soldier.s2c_load_pendant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load_pendant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load_pendant
         * @function getTypeUrl
         * @memberof soldier.s2c_load_pendant
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load_pendant.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.s2c_load_pendant";
        };

        return s2c_load_pendant;
    })();

    soldier.c2s_load_train = (function() {

        /**
         * Properties of a c2s_load_train.
         * @memberof soldier
         * @interface Ic2s_load_train
         */

        /**
         * Constructs a new c2s_load_train.
         * @memberof soldier
         * @classdesc Represents a c2s_load_train.
         * @implements Ic2s_load_train
         * @constructor
         * @param {soldier.Ic2s_load_train=} [properties] Properties to set
         */
        function c2s_load_train(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load_train instance using the specified properties.
         * @function create
         * @memberof soldier.c2s_load_train
         * @static
         * @param {soldier.Ic2s_load_train=} [properties] Properties to set
         * @returns {soldier.c2s_load_train} c2s_load_train instance
         */
        c2s_load_train.create = function create(properties) {
            return new c2s_load_train(properties);
        };

        /**
         * Encodes the specified c2s_load_train message. Does not implicitly {@link soldier.c2s_load_train.verify|verify} messages.
         * @function encode
         * @memberof soldier.c2s_load_train
         * @static
         * @param {soldier.Ic2s_load_train} message c2s_load_train message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_train.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load_train message, length delimited. Does not implicitly {@link soldier.c2s_load_train.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.c2s_load_train
         * @static
         * @param {soldier.Ic2s_load_train} message c2s_load_train message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_train.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load_train message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.c2s_load_train
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.c2s_load_train} c2s_load_train
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_train.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.c2s_load_train();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load_train message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.c2s_load_train
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.c2s_load_train} c2s_load_train
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_train.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load_train message.
         * @function verify
         * @memberof soldier.c2s_load_train
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load_train.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load_train message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.c2s_load_train
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.c2s_load_train} c2s_load_train
         */
        c2s_load_train.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.c2s_load_train)
                return object;
            return new $root.soldier.c2s_load_train();
        };

        /**
         * Creates a plain object from a c2s_load_train message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.c2s_load_train
         * @static
         * @param {soldier.c2s_load_train} message c2s_load_train
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load_train.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load_train to JSON.
         * @function toJSON
         * @memberof soldier.c2s_load_train
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load_train.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load_train
         * @function getTypeUrl
         * @memberof soldier.c2s_load_train
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load_train.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.c2s_load_train";
        };

        return c2s_load_train;
    })();

    soldier.s2c_load_train = (function() {

        /**
         * Properties of a s2c_load_train.
         * @memberof soldier
         * @interface Is2c_load_train
         * @property {number|null} [err] s2c_load_train err
         * @property {Array.<soldier.ITrainInfo>|null} [trains] s2c_load_train trains
         */

        /**
         * Constructs a new s2c_load_train.
         * @memberof soldier
         * @classdesc Represents a s2c_load_train.
         * @implements Is2c_load_train
         * @constructor
         * @param {soldier.Is2c_load_train=} [properties] Properties to set
         */
        function s2c_load_train(properties) {
            this.trains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load_train err.
         * @member {number} err
         * @memberof soldier.s2c_load_train
         * @instance
         */
        s2c_load_train.prototype.err = 0;

        /**
         * s2c_load_train trains.
         * @member {Array.<soldier.ITrainInfo>} trains
         * @memberof soldier.s2c_load_train
         * @instance
         */
        s2c_load_train.prototype.trains = $util.emptyArray;

        /**
         * Creates a new s2c_load_train instance using the specified properties.
         * @function create
         * @memberof soldier.s2c_load_train
         * @static
         * @param {soldier.Is2c_load_train=} [properties] Properties to set
         * @returns {soldier.s2c_load_train} s2c_load_train instance
         */
        s2c_load_train.create = function create(properties) {
            return new s2c_load_train(properties);
        };

        /**
         * Encodes the specified s2c_load_train message. Does not implicitly {@link soldier.s2c_load_train.verify|verify} messages.
         * @function encode
         * @memberof soldier.s2c_load_train
         * @static
         * @param {soldier.Is2c_load_train} message s2c_load_train message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_train.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.trains != null && message.trains.length)
                for (var i = 0; i < message.trains.length; ++i)
                    $root.soldier.TrainInfo.encode(message.trains[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load_train message, length delimited. Does not implicitly {@link soldier.s2c_load_train.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.s2c_load_train
         * @static
         * @param {soldier.Is2c_load_train} message s2c_load_train message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_train.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load_train message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.s2c_load_train
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.s2c_load_train} s2c_load_train
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_train.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.s2c_load_train();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.trains && message.trains.length))
                            message.trains = [];
                        message.trains.push($root.soldier.TrainInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load_train message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.s2c_load_train
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.s2c_load_train} s2c_load_train
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_train.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load_train message.
         * @function verify
         * @memberof soldier.s2c_load_train
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load_train.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.trains != null && message.hasOwnProperty("trains")) {
                if (!Array.isArray(message.trains))
                    return "trains: array expected";
                for (var i = 0; i < message.trains.length; ++i) {
                    var error = $root.soldier.TrainInfo.verify(message.trains[i]);
                    if (error)
                        return "trains." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load_train message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.s2c_load_train
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.s2c_load_train} s2c_load_train
         */
        s2c_load_train.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.s2c_load_train)
                return object;
            var message = new $root.soldier.s2c_load_train();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.trains) {
                if (!Array.isArray(object.trains))
                    throw TypeError(".soldier.s2c_load_train.trains: array expected");
                message.trains = [];
                for (var i = 0; i < object.trains.length; ++i) {
                    if (typeof object.trains[i] !== "object")
                        throw TypeError(".soldier.s2c_load_train.trains: object expected");
                    message.trains[i] = $root.soldier.TrainInfo.fromObject(object.trains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load_train message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.s2c_load_train
         * @static
         * @param {soldier.s2c_load_train} message s2c_load_train
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load_train.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.trains = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.trains && message.trains.length) {
                object.trains = [];
                for (var j = 0; j < message.trains.length; ++j)
                    object.trains[j] = $root.soldier.TrainInfo.toObject(message.trains[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load_train to JSON.
         * @function toJSON
         * @memberof soldier.s2c_load_train
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load_train.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load_train
         * @function getTypeUrl
         * @memberof soldier.s2c_load_train
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load_train.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.s2c_load_train";
        };

        return s2c_load_train;
    })();

    soldier.c2s_soldier_upgrade = (function() {

        /**
         * Properties of a c2s_soldier_upgrade.
         * @memberof soldier
         * @interface Ic2s_soldier_upgrade
         * @property {number|null} [id] c2s_soldier_upgrade id
         */

        /**
         * Constructs a new c2s_soldier_upgrade.
         * @memberof soldier
         * @classdesc Represents a c2s_soldier_upgrade.
         * @implements Ic2s_soldier_upgrade
         * @constructor
         * @param {soldier.Ic2s_soldier_upgrade=} [properties] Properties to set
         */
        function c2s_soldier_upgrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_soldier_upgrade id.
         * @member {number} id
         * @memberof soldier.c2s_soldier_upgrade
         * @instance
         */
        c2s_soldier_upgrade.prototype.id = 0;

        /**
         * Creates a new c2s_soldier_upgrade instance using the specified properties.
         * @function create
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {soldier.Ic2s_soldier_upgrade=} [properties] Properties to set
         * @returns {soldier.c2s_soldier_upgrade} c2s_soldier_upgrade instance
         */
        c2s_soldier_upgrade.create = function create(properties) {
            return new c2s_soldier_upgrade(properties);
        };

        /**
         * Encodes the specified c2s_soldier_upgrade message. Does not implicitly {@link soldier.c2s_soldier_upgrade.verify|verify} messages.
         * @function encode
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {soldier.Ic2s_soldier_upgrade} message c2s_soldier_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_soldier_upgrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified c2s_soldier_upgrade message, length delimited. Does not implicitly {@link soldier.c2s_soldier_upgrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {soldier.Ic2s_soldier_upgrade} message c2s_soldier_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_soldier_upgrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_soldier_upgrade message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.c2s_soldier_upgrade} c2s_soldier_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_soldier_upgrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.c2s_soldier_upgrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_soldier_upgrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.c2s_soldier_upgrade} c2s_soldier_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_soldier_upgrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_soldier_upgrade message.
         * @function verify
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_soldier_upgrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a c2s_soldier_upgrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.c2s_soldier_upgrade} c2s_soldier_upgrade
         */
        c2s_soldier_upgrade.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.c2s_soldier_upgrade)
                return object;
            var message = new $root.soldier.c2s_soldier_upgrade();
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_soldier_upgrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {soldier.c2s_soldier_upgrade} message c2s_soldier_upgrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_soldier_upgrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this c2s_soldier_upgrade to JSON.
         * @function toJSON
         * @memberof soldier.c2s_soldier_upgrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_soldier_upgrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_soldier_upgrade
         * @function getTypeUrl
         * @memberof soldier.c2s_soldier_upgrade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_soldier_upgrade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.c2s_soldier_upgrade";
        };

        return c2s_soldier_upgrade;
    })();

    soldier.s2c_soldier_upgrade = (function() {

        /**
         * Properties of a s2c_soldier_upgrade.
         * @memberof soldier
         * @interface Is2c_soldier_upgrade
         * @property {number|null} [err] s2c_soldier_upgrade err
         */

        /**
         * Constructs a new s2c_soldier_upgrade.
         * @memberof soldier
         * @classdesc Represents a s2c_soldier_upgrade.
         * @implements Is2c_soldier_upgrade
         * @constructor
         * @param {soldier.Is2c_soldier_upgrade=} [properties] Properties to set
         */
        function s2c_soldier_upgrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_soldier_upgrade err.
         * @member {number} err
         * @memberof soldier.s2c_soldier_upgrade
         * @instance
         */
        s2c_soldier_upgrade.prototype.err = 0;

        /**
         * Creates a new s2c_soldier_upgrade instance using the specified properties.
         * @function create
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {soldier.Is2c_soldier_upgrade=} [properties] Properties to set
         * @returns {soldier.s2c_soldier_upgrade} s2c_soldier_upgrade instance
         */
        s2c_soldier_upgrade.create = function create(properties) {
            return new s2c_soldier_upgrade(properties);
        };

        /**
         * Encodes the specified s2c_soldier_upgrade message. Does not implicitly {@link soldier.s2c_soldier_upgrade.verify|verify} messages.
         * @function encode
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {soldier.Is2c_soldier_upgrade} message s2c_soldier_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_soldier_upgrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_soldier_upgrade message, length delimited. Does not implicitly {@link soldier.s2c_soldier_upgrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {soldier.Is2c_soldier_upgrade} message s2c_soldier_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_soldier_upgrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_soldier_upgrade message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.s2c_soldier_upgrade} s2c_soldier_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_soldier_upgrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.s2c_soldier_upgrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_soldier_upgrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.s2c_soldier_upgrade} s2c_soldier_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_soldier_upgrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_soldier_upgrade message.
         * @function verify
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_soldier_upgrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_soldier_upgrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.s2c_soldier_upgrade} s2c_soldier_upgrade
         */
        s2c_soldier_upgrade.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.s2c_soldier_upgrade)
                return object;
            var message = new $root.soldier.s2c_soldier_upgrade();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_soldier_upgrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {soldier.s2c_soldier_upgrade} message s2c_soldier_upgrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_soldier_upgrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_soldier_upgrade to JSON.
         * @function toJSON
         * @memberof soldier.s2c_soldier_upgrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_soldier_upgrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_soldier_upgrade
         * @function getTypeUrl
         * @memberof soldier.s2c_soldier_upgrade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_soldier_upgrade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.s2c_soldier_upgrade";
        };

        return s2c_soldier_upgrade;
    })();

    soldier.c2s_pendant_upgrade = (function() {

        /**
         * Properties of a c2s_pendant_upgrade.
         * @memberof soldier
         * @interface Ic2s_pendant_upgrade
         * @property {number|null} [id] c2s_pendant_upgrade id
         */

        /**
         * Constructs a new c2s_pendant_upgrade.
         * @memberof soldier
         * @classdesc Represents a c2s_pendant_upgrade.
         * @implements Ic2s_pendant_upgrade
         * @constructor
         * @param {soldier.Ic2s_pendant_upgrade=} [properties] Properties to set
         */
        function c2s_pendant_upgrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_pendant_upgrade id.
         * @member {number} id
         * @memberof soldier.c2s_pendant_upgrade
         * @instance
         */
        c2s_pendant_upgrade.prototype.id = 0;

        /**
         * Creates a new c2s_pendant_upgrade instance using the specified properties.
         * @function create
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {soldier.Ic2s_pendant_upgrade=} [properties] Properties to set
         * @returns {soldier.c2s_pendant_upgrade} c2s_pendant_upgrade instance
         */
        c2s_pendant_upgrade.create = function create(properties) {
            return new c2s_pendant_upgrade(properties);
        };

        /**
         * Encodes the specified c2s_pendant_upgrade message. Does not implicitly {@link soldier.c2s_pendant_upgrade.verify|verify} messages.
         * @function encode
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {soldier.Ic2s_pendant_upgrade} message c2s_pendant_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_pendant_upgrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            return writer;
        };

        /**
         * Encodes the specified c2s_pendant_upgrade message, length delimited. Does not implicitly {@link soldier.c2s_pendant_upgrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {soldier.Ic2s_pendant_upgrade} message c2s_pendant_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_pendant_upgrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_pendant_upgrade message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.c2s_pendant_upgrade} c2s_pendant_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_pendant_upgrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.c2s_pendant_upgrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_pendant_upgrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.c2s_pendant_upgrade} c2s_pendant_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_pendant_upgrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_pendant_upgrade message.
         * @function verify
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_pendant_upgrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };

        /**
         * Creates a c2s_pendant_upgrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.c2s_pendant_upgrade} c2s_pendant_upgrade
         */
        c2s_pendant_upgrade.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.c2s_pendant_upgrade)
                return object;
            var message = new $root.soldier.c2s_pendant_upgrade();
            if (object.id != null)
                message.id = object.id >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_pendant_upgrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {soldier.c2s_pendant_upgrade} message c2s_pendant_upgrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_pendant_upgrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this c2s_pendant_upgrade to JSON.
         * @function toJSON
         * @memberof soldier.c2s_pendant_upgrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_pendant_upgrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_pendant_upgrade
         * @function getTypeUrl
         * @memberof soldier.c2s_pendant_upgrade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_pendant_upgrade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.c2s_pendant_upgrade";
        };

        return c2s_pendant_upgrade;
    })();

    soldier.s2c_pendant_upgrade = (function() {

        /**
         * Properties of a s2c_pendant_upgrade.
         * @memberof soldier
         * @interface Is2c_pendant_upgrade
         * @property {number|null} [err] s2c_pendant_upgrade err
         */

        /**
         * Constructs a new s2c_pendant_upgrade.
         * @memberof soldier
         * @classdesc Represents a s2c_pendant_upgrade.
         * @implements Is2c_pendant_upgrade
         * @constructor
         * @param {soldier.Is2c_pendant_upgrade=} [properties] Properties to set
         */
        function s2c_pendant_upgrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_pendant_upgrade err.
         * @member {number} err
         * @memberof soldier.s2c_pendant_upgrade
         * @instance
         */
        s2c_pendant_upgrade.prototype.err = 0;

        /**
         * Creates a new s2c_pendant_upgrade instance using the specified properties.
         * @function create
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {soldier.Is2c_pendant_upgrade=} [properties] Properties to set
         * @returns {soldier.s2c_pendant_upgrade} s2c_pendant_upgrade instance
         */
        s2c_pendant_upgrade.create = function create(properties) {
            return new s2c_pendant_upgrade(properties);
        };

        /**
         * Encodes the specified s2c_pendant_upgrade message. Does not implicitly {@link soldier.s2c_pendant_upgrade.verify|verify} messages.
         * @function encode
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {soldier.Is2c_pendant_upgrade} message s2c_pendant_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_pendant_upgrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_pendant_upgrade message, length delimited. Does not implicitly {@link soldier.s2c_pendant_upgrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {soldier.Is2c_pendant_upgrade} message s2c_pendant_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_pendant_upgrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_pendant_upgrade message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.s2c_pendant_upgrade} s2c_pendant_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_pendant_upgrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.s2c_pendant_upgrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_pendant_upgrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.s2c_pendant_upgrade} s2c_pendant_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_pendant_upgrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_pendant_upgrade message.
         * @function verify
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_pendant_upgrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_pendant_upgrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.s2c_pendant_upgrade} s2c_pendant_upgrade
         */
        s2c_pendant_upgrade.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.s2c_pendant_upgrade)
                return object;
            var message = new $root.soldier.s2c_pendant_upgrade();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_pendant_upgrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {soldier.s2c_pendant_upgrade} message s2c_pendant_upgrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_pendant_upgrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_pendant_upgrade to JSON.
         * @function toJSON
         * @memberof soldier.s2c_pendant_upgrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_pendant_upgrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_pendant_upgrade
         * @function getTypeUrl
         * @memberof soldier.s2c_pendant_upgrade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_pendant_upgrade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.s2c_pendant_upgrade";
        };

        return s2c_pendant_upgrade;
    })();

    soldier.c2s_train_upgrade = (function() {

        /**
         * Properties of a c2s_train_upgrade.
         * @memberof soldier
         * @interface Ic2s_train_upgrade
         * @property {number|null} [id] c2s_train_upgrade id
         * @property {number|null} [num] c2s_train_upgrade num
         */

        /**
         * Constructs a new c2s_train_upgrade.
         * @memberof soldier
         * @classdesc Represents a c2s_train_upgrade.
         * @implements Ic2s_train_upgrade
         * @constructor
         * @param {soldier.Ic2s_train_upgrade=} [properties] Properties to set
         */
        function c2s_train_upgrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_train_upgrade id.
         * @member {number} id
         * @memberof soldier.c2s_train_upgrade
         * @instance
         */
        c2s_train_upgrade.prototype.id = 0;

        /**
         * c2s_train_upgrade num.
         * @member {number} num
         * @memberof soldier.c2s_train_upgrade
         * @instance
         */
        c2s_train_upgrade.prototype.num = 0;

        /**
         * Creates a new c2s_train_upgrade instance using the specified properties.
         * @function create
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {soldier.Ic2s_train_upgrade=} [properties] Properties to set
         * @returns {soldier.c2s_train_upgrade} c2s_train_upgrade instance
         */
        c2s_train_upgrade.create = function create(properties) {
            return new c2s_train_upgrade(properties);
        };

        /**
         * Encodes the specified c2s_train_upgrade message. Does not implicitly {@link soldier.c2s_train_upgrade.verify|verify} messages.
         * @function encode
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {soldier.Ic2s_train_upgrade} message c2s_train_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_train_upgrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified c2s_train_upgrade message, length delimited. Does not implicitly {@link soldier.c2s_train_upgrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {soldier.Ic2s_train_upgrade} message c2s_train_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_train_upgrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_train_upgrade message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.c2s_train_upgrade} c2s_train_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_train_upgrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.c2s_train_upgrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_train_upgrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.c2s_train_upgrade} c2s_train_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_train_upgrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_train_upgrade message.
         * @function verify
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_train_upgrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a c2s_train_upgrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.c2s_train_upgrade} c2s_train_upgrade
         */
        c2s_train_upgrade.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.c2s_train_upgrade)
                return object;
            var message = new $root.soldier.c2s_train_upgrade();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_train_upgrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {soldier.c2s_train_upgrade} message c2s_train_upgrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_train_upgrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this c2s_train_upgrade to JSON.
         * @function toJSON
         * @memberof soldier.c2s_train_upgrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_train_upgrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_train_upgrade
         * @function getTypeUrl
         * @memberof soldier.c2s_train_upgrade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_train_upgrade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.c2s_train_upgrade";
        };

        return c2s_train_upgrade;
    })();

    soldier.s2c_train_upgrade = (function() {

        /**
         * Properties of a s2c_train_upgrade.
         * @memberof soldier
         * @interface Is2c_train_upgrade
         * @property {number|null} [err] s2c_train_upgrade err
         */

        /**
         * Constructs a new s2c_train_upgrade.
         * @memberof soldier
         * @classdesc Represents a s2c_train_upgrade.
         * @implements Is2c_train_upgrade
         * @constructor
         * @param {soldier.Is2c_train_upgrade=} [properties] Properties to set
         */
        function s2c_train_upgrade(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_train_upgrade err.
         * @member {number} err
         * @memberof soldier.s2c_train_upgrade
         * @instance
         */
        s2c_train_upgrade.prototype.err = 0;

        /**
         * Creates a new s2c_train_upgrade instance using the specified properties.
         * @function create
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {soldier.Is2c_train_upgrade=} [properties] Properties to set
         * @returns {soldier.s2c_train_upgrade} s2c_train_upgrade instance
         */
        s2c_train_upgrade.create = function create(properties) {
            return new s2c_train_upgrade(properties);
        };

        /**
         * Encodes the specified s2c_train_upgrade message. Does not implicitly {@link soldier.s2c_train_upgrade.verify|verify} messages.
         * @function encode
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {soldier.Is2c_train_upgrade} message s2c_train_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_train_upgrade.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_train_upgrade message, length delimited. Does not implicitly {@link soldier.s2c_train_upgrade.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {soldier.Is2c_train_upgrade} message s2c_train_upgrade message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_train_upgrade.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_train_upgrade message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.s2c_train_upgrade} s2c_train_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_train_upgrade.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.s2c_train_upgrade();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_train_upgrade message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.s2c_train_upgrade} s2c_train_upgrade
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_train_upgrade.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_train_upgrade message.
         * @function verify
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_train_upgrade.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_train_upgrade message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.s2c_train_upgrade} s2c_train_upgrade
         */
        s2c_train_upgrade.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.s2c_train_upgrade)
                return object;
            var message = new $root.soldier.s2c_train_upgrade();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_train_upgrade message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {soldier.s2c_train_upgrade} message s2c_train_upgrade
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_train_upgrade.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_train_upgrade to JSON.
         * @function toJSON
         * @memberof soldier.s2c_train_upgrade
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_train_upgrade.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_train_upgrade
         * @function getTypeUrl
         * @memberof soldier.s2c_train_upgrade
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_train_upgrade.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.s2c_train_upgrade";
        };

        return s2c_train_upgrade;
    })();

    soldier.notify_pendants = (function() {

        /**
         * Properties of a notify_pendants.
         * @memberof soldier
         * @interface Inotify_pendants
         * @property {Array.<soldier.IPendantInfo>|null} [pendants] notify_pendants pendants
         */

        /**
         * Constructs a new notify_pendants.
         * @memberof soldier
         * @classdesc Represents a notify_pendants.
         * @implements Inotify_pendants
         * @constructor
         * @param {soldier.Inotify_pendants=} [properties] Properties to set
         */
        function notify_pendants(properties) {
            this.pendants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_pendants pendants.
         * @member {Array.<soldier.IPendantInfo>} pendants
         * @memberof soldier.notify_pendants
         * @instance
         */
        notify_pendants.prototype.pendants = $util.emptyArray;

        /**
         * Creates a new notify_pendants instance using the specified properties.
         * @function create
         * @memberof soldier.notify_pendants
         * @static
         * @param {soldier.Inotify_pendants=} [properties] Properties to set
         * @returns {soldier.notify_pendants} notify_pendants instance
         */
        notify_pendants.create = function create(properties) {
            return new notify_pendants(properties);
        };

        /**
         * Encodes the specified notify_pendants message. Does not implicitly {@link soldier.notify_pendants.verify|verify} messages.
         * @function encode
         * @memberof soldier.notify_pendants
         * @static
         * @param {soldier.Inotify_pendants} message notify_pendants message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_pendants.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pendants != null && message.pendants.length)
                for (var i = 0; i < message.pendants.length; ++i)
                    $root.soldier.PendantInfo.encode(message.pendants[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_pendants message, length delimited. Does not implicitly {@link soldier.notify_pendants.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.notify_pendants
         * @static
         * @param {soldier.Inotify_pendants} message notify_pendants message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_pendants.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_pendants message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.notify_pendants
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.notify_pendants} notify_pendants
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_pendants.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.notify_pendants();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.pendants && message.pendants.length))
                            message.pendants = [];
                        message.pendants.push($root.soldier.PendantInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_pendants message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.notify_pendants
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.notify_pendants} notify_pendants
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_pendants.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_pendants message.
         * @function verify
         * @memberof soldier.notify_pendants
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_pendants.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pendants != null && message.hasOwnProperty("pendants")) {
                if (!Array.isArray(message.pendants))
                    return "pendants: array expected";
                for (var i = 0; i < message.pendants.length; ++i) {
                    var error = $root.soldier.PendantInfo.verify(message.pendants[i]);
                    if (error)
                        return "pendants." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_pendants message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.notify_pendants
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.notify_pendants} notify_pendants
         */
        notify_pendants.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.notify_pendants)
                return object;
            var message = new $root.soldier.notify_pendants();
            if (object.pendants) {
                if (!Array.isArray(object.pendants))
                    throw TypeError(".soldier.notify_pendants.pendants: array expected");
                message.pendants = [];
                for (var i = 0; i < object.pendants.length; ++i) {
                    if (typeof object.pendants[i] !== "object")
                        throw TypeError(".soldier.notify_pendants.pendants: object expected");
                    message.pendants[i] = $root.soldier.PendantInfo.fromObject(object.pendants[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_pendants message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.notify_pendants
         * @static
         * @param {soldier.notify_pendants} message notify_pendants
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_pendants.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pendants = [];
            if (message.pendants && message.pendants.length) {
                object.pendants = [];
                for (var j = 0; j < message.pendants.length; ++j)
                    object.pendants[j] = $root.soldier.PendantInfo.toObject(message.pendants[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_pendants to JSON.
         * @function toJSON
         * @memberof soldier.notify_pendants
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_pendants.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_pendants
         * @function getTypeUrl
         * @memberof soldier.notify_pendants
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_pendants.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.notify_pendants";
        };

        return notify_pendants;
    })();

    soldier.notify_slodiers = (function() {

        /**
         * Properties of a notify_slodiers.
         * @memberof soldier
         * @interface Inotify_slodiers
         * @property {Array.<soldier.ISoldierInfo>|null} [soldiers] notify_slodiers soldiers
         */

        /**
         * Constructs a new notify_slodiers.
         * @memberof soldier
         * @classdesc Represents a notify_slodiers.
         * @implements Inotify_slodiers
         * @constructor
         * @param {soldier.Inotify_slodiers=} [properties] Properties to set
         */
        function notify_slodiers(properties) {
            this.soldiers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_slodiers soldiers.
         * @member {Array.<soldier.ISoldierInfo>} soldiers
         * @memberof soldier.notify_slodiers
         * @instance
         */
        notify_slodiers.prototype.soldiers = $util.emptyArray;

        /**
         * Creates a new notify_slodiers instance using the specified properties.
         * @function create
         * @memberof soldier.notify_slodiers
         * @static
         * @param {soldier.Inotify_slodiers=} [properties] Properties to set
         * @returns {soldier.notify_slodiers} notify_slodiers instance
         */
        notify_slodiers.create = function create(properties) {
            return new notify_slodiers(properties);
        };

        /**
         * Encodes the specified notify_slodiers message. Does not implicitly {@link soldier.notify_slodiers.verify|verify} messages.
         * @function encode
         * @memberof soldier.notify_slodiers
         * @static
         * @param {soldier.Inotify_slodiers} message notify_slodiers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_slodiers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.soldiers != null && message.soldiers.length)
                for (var i = 0; i < message.soldiers.length; ++i)
                    $root.soldier.SoldierInfo.encode(message.soldiers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_slodiers message, length delimited. Does not implicitly {@link soldier.notify_slodiers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof soldier.notify_slodiers
         * @static
         * @param {soldier.Inotify_slodiers} message notify_slodiers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_slodiers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_slodiers message from the specified reader or buffer.
         * @function decode
         * @memberof soldier.notify_slodiers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {soldier.notify_slodiers} notify_slodiers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_slodiers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.soldier.notify_slodiers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.soldiers && message.soldiers.length))
                            message.soldiers = [];
                        message.soldiers.push($root.soldier.SoldierInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_slodiers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof soldier.notify_slodiers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {soldier.notify_slodiers} notify_slodiers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_slodiers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_slodiers message.
         * @function verify
         * @memberof soldier.notify_slodiers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_slodiers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.soldiers != null && message.hasOwnProperty("soldiers")) {
                if (!Array.isArray(message.soldiers))
                    return "soldiers: array expected";
                for (var i = 0; i < message.soldiers.length; ++i) {
                    var error = $root.soldier.SoldierInfo.verify(message.soldiers[i]);
                    if (error)
                        return "soldiers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_slodiers message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof soldier.notify_slodiers
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {soldier.notify_slodiers} notify_slodiers
         */
        notify_slodiers.fromObject = function fromObject(object) {
            if (object instanceof $root.soldier.notify_slodiers)
                return object;
            var message = new $root.soldier.notify_slodiers();
            if (object.soldiers) {
                if (!Array.isArray(object.soldiers))
                    throw TypeError(".soldier.notify_slodiers.soldiers: array expected");
                message.soldiers = [];
                for (var i = 0; i < object.soldiers.length; ++i) {
                    if (typeof object.soldiers[i] !== "object")
                        throw TypeError(".soldier.notify_slodiers.soldiers: object expected");
                    message.soldiers[i] = $root.soldier.SoldierInfo.fromObject(object.soldiers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_slodiers message. Also converts values to other types if specified.
         * @function toObject
         * @memberof soldier.notify_slodiers
         * @static
         * @param {soldier.notify_slodiers} message notify_slodiers
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_slodiers.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.soldiers = [];
            if (message.soldiers && message.soldiers.length) {
                object.soldiers = [];
                for (var j = 0; j < message.soldiers.length; ++j)
                    object.soldiers[j] = $root.soldier.SoldierInfo.toObject(message.soldiers[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_slodiers to JSON.
         * @function toJSON
         * @memberof soldier.notify_slodiers
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_slodiers.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_slodiers
         * @function getTypeUrl
         * @memberof soldier.notify_slodiers
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_slodiers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/soldier.notify_slodiers";
        };

        return notify_slodiers;
    })();

    return soldier;
})();

$root.task = (function() {

    /**
     * Namespace task.
     * @exports task
     * @namespace
     */
    var task = {};

    task.TaskInfo = (function() {

        /**
         * Properties of a TaskInfo.
         * @memberof task
         * @interface ITaskInfo
         * @property {number|null} [id] TaskInfo id
         * @property {number|null} [num] TaskInfo num
         * @property {number|null} [max] TaskInfo max
         * @property {boolean|null} [finish] TaskInfo finish
         */

        /**
         * Constructs a new TaskInfo.
         * @memberof task
         * @classdesc Represents a TaskInfo.
         * @implements ITaskInfo
         * @constructor
         * @param {task.ITaskInfo=} [properties] Properties to set
         */
        function TaskInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskInfo id.
         * @member {number} id
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.id = 0;

        /**
         * TaskInfo num.
         * @member {number} num
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.num = 0;

        /**
         * TaskInfo max.
         * @member {number} max
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.max = 0;

        /**
         * TaskInfo finish.
         * @member {boolean} finish
         * @memberof task.TaskInfo
         * @instance
         */
        TaskInfo.prototype.finish = false;

        /**
         * Creates a new TaskInfo instance using the specified properties.
         * @function create
         * @memberof task.TaskInfo
         * @static
         * @param {task.ITaskInfo=} [properties] Properties to set
         * @returns {task.TaskInfo} TaskInfo instance
         */
        TaskInfo.create = function create(properties) {
            return new TaskInfo(properties);
        };

        /**
         * Encodes the specified TaskInfo message. Does not implicitly {@link task.TaskInfo.verify|verify} messages.
         * @function encode
         * @memberof task.TaskInfo
         * @static
         * @param {task.ITaskInfo} message TaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.max);
            if (message.finish != null && Object.hasOwnProperty.call(message, "finish"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.finish);
            return writer;
        };

        /**
         * Encodes the specified TaskInfo message, length delimited. Does not implicitly {@link task.TaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.TaskInfo
         * @static
         * @param {task.ITaskInfo} message TaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof task.TaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.TaskInfo} TaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.TaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                case 3: {
                        message.max = reader.uint32();
                        break;
                    }
                case 4: {
                        message.finish = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.TaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.TaskInfo} TaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskInfo message.
         * @function verify
         * @memberof task.TaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.max != null && message.hasOwnProperty("max"))
                if (!$util.isInteger(message.max))
                    return "max: integer expected";
            if (message.finish != null && message.hasOwnProperty("finish"))
                if (typeof message.finish !== "boolean")
                    return "finish: boolean expected";
            return null;
        };

        /**
         * Creates a TaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.TaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.TaskInfo} TaskInfo
         */
        TaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.task.TaskInfo)
                return object;
            var message = new $root.task.TaskInfo();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.max != null)
                message.max = object.max >>> 0;
            if (object.finish != null)
                message.finish = Boolean(object.finish);
            return message;
        };

        /**
         * Creates a plain object from a TaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.TaskInfo
         * @static
         * @param {task.TaskInfo} message TaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.max = 0;
                object.finish = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.max != null && message.hasOwnProperty("max"))
                object.max = message.max;
            if (message.finish != null && message.hasOwnProperty("finish"))
                object.finish = message.finish;
            return object;
        };

        /**
         * Converts this TaskInfo to JSON.
         * @function toJSON
         * @memberof task.TaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TaskInfo
         * @function getTypeUrl
         * @memberof task.TaskInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TaskInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.TaskInfo";
        };

        return TaskInfo;
    })();

    task.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof task
         * @interface Ic2s_load
         * @property {number|null} [taskType] c2s_load taskType
         */

        /**
         * Constructs a new c2s_load.
         * @memberof task
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {task.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load taskType.
         * @member {number} taskType
         * @memberof task.c2s_load
         * @instance
         */
        c2s_load.prototype.taskType = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof task.c2s_load
         * @static
         * @param {task.Ic2s_load=} [properties] Properties to set
         * @returns {task.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link task.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof task.c2s_load
         * @static
         * @param {task.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskType != null && Object.hasOwnProperty.call(message, "taskType"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.taskType);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link task.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.c2s_load
         * @static
         * @param {task.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof task.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.taskType = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof task.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskType != null && message.hasOwnProperty("taskType"))
                if (!$util.isInteger(message.taskType))
                    return "taskType: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.task.c2s_load)
                return object;
            var message = new $root.task.c2s_load();
            if (object.taskType != null)
                message.taskType = object.taskType >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.c2s_load
         * @static
         * @param {task.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.taskType = 0;
            if (message.taskType != null && message.hasOwnProperty("taskType"))
                object.taskType = message.taskType;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof task.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof task.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.c2s_load";
        };

        return c2s_load;
    })();

    task.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof task
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<task.ITaskInfo>|null} [tasks] s2c_load tasks
         */

        /**
         * Constructs a new s2c_load.
         * @memberof task
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {task.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.tasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof task.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load tasks.
         * @member {Array.<task.ITaskInfo>} tasks
         * @memberof task.s2c_load
         * @instance
         */
        s2c_load.prototype.tasks = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof task.s2c_load
         * @static
         * @param {task.Is2c_load=} [properties] Properties to set
         * @returns {task.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link task.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof task.s2c_load
         * @static
         * @param {task.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.task.TaskInfo.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link task.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.s2c_load
         * @static
         * @param {task.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof task.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.task.TaskInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof task.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.task.TaskInfo.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.task.s2c_load)
                return object;
            var message = new $root.task.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".task.s2c_load.tasks: array expected");
                message.tasks = [];
                for (var i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".task.s2c_load.tasks: object expected");
                    message.tasks[i] = $root.task.TaskInfo.fromObject(object.tasks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.s2c_load
         * @static
         * @param {task.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (var j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.task.TaskInfo.toObject(message.tasks[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof task.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof task.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.s2c_load";
        };

        return s2c_load;
    })();

    task.c2s_receive_reward = (function() {

        /**
         * Properties of a c2s_receive_reward.
         * @memberof task
         * @interface Ic2s_receive_reward
         * @property {Array.<number>|null} [taskIds] c2s_receive_reward taskIds
         */

        /**
         * Constructs a new c2s_receive_reward.
         * @memberof task
         * @classdesc Represents a c2s_receive_reward.
         * @implements Ic2s_receive_reward
         * @constructor
         * @param {task.Ic2s_receive_reward=} [properties] Properties to set
         */
        function c2s_receive_reward(properties) {
            this.taskIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_receive_reward taskIds.
         * @member {Array.<number>} taskIds
         * @memberof task.c2s_receive_reward
         * @instance
         */
        c2s_receive_reward.prototype.taskIds = $util.emptyArray;

        /**
         * Creates a new c2s_receive_reward instance using the specified properties.
         * @function create
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.Ic2s_receive_reward=} [properties] Properties to set
         * @returns {task.c2s_receive_reward} c2s_receive_reward instance
         */
        c2s_receive_reward.create = function create(properties) {
            return new c2s_receive_reward(properties);
        };

        /**
         * Encodes the specified c2s_receive_reward message. Does not implicitly {@link task.c2s_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskIds != null && message.taskIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.taskIds.length; ++i)
                    writer.uint32(message.taskIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified c2s_receive_reward message, length delimited. Does not implicitly {@link task.c2s_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.Ic2s_receive_reward} message c2s_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof task.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.c2s_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.taskIds && message.taskIds.length))
                            message.taskIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.taskIds.push(reader.uint32());
                        } else
                            message.taskIds.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.c2s_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.c2s_receive_reward} c2s_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_receive_reward message.
         * @function verify
         * @memberof task.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskIds != null && message.hasOwnProperty("taskIds")) {
                if (!Array.isArray(message.taskIds))
                    return "taskIds: array expected";
                for (var i = 0; i < message.taskIds.length; ++i)
                    if (!$util.isInteger(message.taskIds[i]))
                        return "taskIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a c2s_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.c2s_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.c2s_receive_reward} c2s_receive_reward
         */
        c2s_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.task.c2s_receive_reward)
                return object;
            var message = new $root.task.c2s_receive_reward();
            if (object.taskIds) {
                if (!Array.isArray(object.taskIds))
                    throw TypeError(".task.c2s_receive_reward.taskIds: array expected");
                message.taskIds = [];
                for (var i = 0; i < object.taskIds.length; ++i)
                    message.taskIds[i] = object.taskIds[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.c2s_receive_reward
         * @static
         * @param {task.c2s_receive_reward} message c2s_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskIds = [];
            if (message.taskIds && message.taskIds.length) {
                object.taskIds = [];
                for (var j = 0; j < message.taskIds.length; ++j)
                    object.taskIds[j] = message.taskIds[j];
            }
            return object;
        };

        /**
         * Converts this c2s_receive_reward to JSON.
         * @function toJSON
         * @memberof task.c2s_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_receive_reward
         * @function getTypeUrl
         * @memberof task.c2s_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.c2s_receive_reward";
        };

        return c2s_receive_reward;
    })();

    task.s2c_receive_reward = (function() {

        /**
         * Properties of a s2c_receive_reward.
         * @memberof task
         * @interface Is2c_receive_reward
         * @property {number|null} [err] s2c_receive_reward err
         */

        /**
         * Constructs a new s2c_receive_reward.
         * @memberof task
         * @classdesc Represents a s2c_receive_reward.
         * @implements Is2c_receive_reward
         * @constructor
         * @param {task.Is2c_receive_reward=} [properties] Properties to set
         */
        function s2c_receive_reward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_receive_reward err.
         * @member {number} err
         * @memberof task.s2c_receive_reward
         * @instance
         */
        s2c_receive_reward.prototype.err = 0;

        /**
         * Creates a new s2c_receive_reward instance using the specified properties.
         * @function create
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.Is2c_receive_reward=} [properties] Properties to set
         * @returns {task.s2c_receive_reward} s2c_receive_reward instance
         */
        s2c_receive_reward.create = function create(properties) {
            return new s2c_receive_reward(properties);
        };

        /**
         * Encodes the specified s2c_receive_reward message. Does not implicitly {@link task.s2c_receive_reward.verify|verify} messages.
         * @function encode
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_receive_reward message, length delimited. Does not implicitly {@link task.s2c_receive_reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.Is2c_receive_reward} message s2c_receive_reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_receive_reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer.
         * @function decode
         * @memberof task.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.s2c_receive_reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_receive_reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.s2c_receive_reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.s2c_receive_reward} s2c_receive_reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_receive_reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_receive_reward message.
         * @function verify
         * @memberof task.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_receive_reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_receive_reward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.s2c_receive_reward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.s2c_receive_reward} s2c_receive_reward
         */
        s2c_receive_reward.fromObject = function fromObject(object) {
            if (object instanceof $root.task.s2c_receive_reward)
                return object;
            var message = new $root.task.s2c_receive_reward();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_receive_reward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.s2c_receive_reward
         * @static
         * @param {task.s2c_receive_reward} message s2c_receive_reward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_receive_reward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_receive_reward to JSON.
         * @function toJSON
         * @memberof task.s2c_receive_reward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_receive_reward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_receive_reward
         * @function getTypeUrl
         * @memberof task.s2c_receive_reward
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_receive_reward.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.s2c_receive_reward";
        };

        return s2c_receive_reward;
    })();

    task.notify_tasks = (function() {

        /**
         * Properties of a notify_tasks.
         * @memberof task
         * @interface Inotify_tasks
         * @property {Array.<task.ITaskInfo>|null} [tasks] notify_tasks tasks
         */

        /**
         * Constructs a new notify_tasks.
         * @memberof task
         * @classdesc Represents a notify_tasks.
         * @implements Inotify_tasks
         * @constructor
         * @param {task.Inotify_tasks=} [properties] Properties to set
         */
        function notify_tasks(properties) {
            this.tasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_tasks tasks.
         * @member {Array.<task.ITaskInfo>} tasks
         * @memberof task.notify_tasks
         * @instance
         */
        notify_tasks.prototype.tasks = $util.emptyArray;

        /**
         * Creates a new notify_tasks instance using the specified properties.
         * @function create
         * @memberof task.notify_tasks
         * @static
         * @param {task.Inotify_tasks=} [properties] Properties to set
         * @returns {task.notify_tasks} notify_tasks instance
         */
        notify_tasks.create = function create(properties) {
            return new notify_tasks(properties);
        };

        /**
         * Encodes the specified notify_tasks message. Does not implicitly {@link task.notify_tasks.verify|verify} messages.
         * @function encode
         * @memberof task.notify_tasks
         * @static
         * @param {task.Inotify_tasks} message notify_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_tasks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.task.TaskInfo.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_tasks message, length delimited. Does not implicitly {@link task.notify_tasks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.notify_tasks
         * @static
         * @param {task.Inotify_tasks} message notify_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_tasks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_tasks message from the specified reader or buffer.
         * @function decode
         * @memberof task.notify_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.notify_tasks} notify_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_tasks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.notify_tasks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.task.TaskInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_tasks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.notify_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.notify_tasks} notify_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_tasks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_tasks message.
         * @function verify
         * @memberof task.notify_tasks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_tasks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.task.TaskInfo.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_tasks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.notify_tasks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.notify_tasks} notify_tasks
         */
        notify_tasks.fromObject = function fromObject(object) {
            if (object instanceof $root.task.notify_tasks)
                return object;
            var message = new $root.task.notify_tasks();
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".task.notify_tasks.tasks: array expected");
                message.tasks = [];
                for (var i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".task.notify_tasks.tasks: object expected");
                    message.tasks[i] = $root.task.TaskInfo.fromObject(object.tasks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_tasks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.notify_tasks
         * @static
         * @param {task.notify_tasks} message notify_tasks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_tasks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (var j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.task.TaskInfo.toObject(message.tasks[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_tasks to JSON.
         * @function toJSON
         * @memberof task.notify_tasks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_tasks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_tasks
         * @function getTypeUrl
         * @memberof task.notify_tasks
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_tasks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.notify_tasks";
        };

        return notify_tasks;
    })();

    task.notify_remove_tasks = (function() {

        /**
         * Properties of a notify_remove_tasks.
         * @memberof task
         * @interface Inotify_remove_tasks
         * @property {Array.<number>|null} [taskIds] notify_remove_tasks taskIds
         */

        /**
         * Constructs a new notify_remove_tasks.
         * @memberof task
         * @classdesc Represents a notify_remove_tasks.
         * @implements Inotify_remove_tasks
         * @constructor
         * @param {task.Inotify_remove_tasks=} [properties] Properties to set
         */
        function notify_remove_tasks(properties) {
            this.taskIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_remove_tasks taskIds.
         * @member {Array.<number>} taskIds
         * @memberof task.notify_remove_tasks
         * @instance
         */
        notify_remove_tasks.prototype.taskIds = $util.emptyArray;

        /**
         * Creates a new notify_remove_tasks instance using the specified properties.
         * @function create
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.Inotify_remove_tasks=} [properties] Properties to set
         * @returns {task.notify_remove_tasks} notify_remove_tasks instance
         */
        notify_remove_tasks.create = function create(properties) {
            return new notify_remove_tasks(properties);
        };

        /**
         * Encodes the specified notify_remove_tasks message. Does not implicitly {@link task.notify_remove_tasks.verify|verify} messages.
         * @function encode
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.Inotify_remove_tasks} message notify_remove_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_remove_tasks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskIds != null && message.taskIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.taskIds.length; ++i)
                    writer.int32(message.taskIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified notify_remove_tasks message, length delimited. Does not implicitly {@link task.notify_remove_tasks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.Inotify_remove_tasks} message notify_remove_tasks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_remove_tasks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_remove_tasks message from the specified reader or buffer.
         * @function decode
         * @memberof task.notify_remove_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {task.notify_remove_tasks} notify_remove_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_remove_tasks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.task.notify_remove_tasks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.taskIds && message.taskIds.length))
                            message.taskIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.taskIds.push(reader.int32());
                        } else
                            message.taskIds.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_remove_tasks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof task.notify_remove_tasks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {task.notify_remove_tasks} notify_remove_tasks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_remove_tasks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_remove_tasks message.
         * @function verify
         * @memberof task.notify_remove_tasks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_remove_tasks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskIds != null && message.hasOwnProperty("taskIds")) {
                if (!Array.isArray(message.taskIds))
                    return "taskIds: array expected";
                for (var i = 0; i < message.taskIds.length; ++i)
                    if (!$util.isInteger(message.taskIds[i]))
                        return "taskIds: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_remove_tasks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof task.notify_remove_tasks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {task.notify_remove_tasks} notify_remove_tasks
         */
        notify_remove_tasks.fromObject = function fromObject(object) {
            if (object instanceof $root.task.notify_remove_tasks)
                return object;
            var message = new $root.task.notify_remove_tasks();
            if (object.taskIds) {
                if (!Array.isArray(object.taskIds))
                    throw TypeError(".task.notify_remove_tasks.taskIds: array expected");
                message.taskIds = [];
                for (var i = 0; i < object.taskIds.length; ++i)
                    message.taskIds[i] = object.taskIds[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_remove_tasks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof task.notify_remove_tasks
         * @static
         * @param {task.notify_remove_tasks} message notify_remove_tasks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_remove_tasks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskIds = [];
            if (message.taskIds && message.taskIds.length) {
                object.taskIds = [];
                for (var j = 0; j < message.taskIds.length; ++j)
                    object.taskIds[j] = message.taskIds[j];
            }
            return object;
        };

        /**
         * Converts this notify_remove_tasks to JSON.
         * @function toJSON
         * @memberof task.notify_remove_tasks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_remove_tasks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_remove_tasks
         * @function getTypeUrl
         * @memberof task.notify_remove_tasks
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_remove_tasks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/task.notify_remove_tasks";
        };

        return notify_remove_tasks;
    })();

    return task;
})();

$root.troop = (function() {

    /**
     * Namespace troop.
     * @exports troop
     * @namespace
     */
    var troop = {};

    troop.Troop = (function() {

        /**
         * Properties of a Troop.
         * @memberof troop
         * @interface ITroop
         * @property {number|null} [idx] Troop idx
         * @property {number|null} [eid] Troop eid
         * @property {number|null} [heroUid] Troop heroUid
         */

        /**
         * Constructs a new Troop.
         * @memberof troop
         * @classdesc Represents a Troop.
         * @implements ITroop
         * @constructor
         * @param {troop.ITroop=} [properties] Properties to set
         */
        function Troop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Troop idx.
         * @member {number} idx
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.idx = 0;

        /**
         * Troop eid.
         * @member {number} eid
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.eid = 0;

        /**
         * Troop heroUid.
         * @member {number} heroUid
         * @memberof troop.Troop
         * @instance
         */
        Troop.prototype.heroUid = 0;

        /**
         * Creates a new Troop instance using the specified properties.
         * @function create
         * @memberof troop.Troop
         * @static
         * @param {troop.ITroop=} [properties] Properties to set
         * @returns {troop.Troop} Troop instance
         */
        Troop.create = function create(properties) {
            return new Troop(properties);
        };

        /**
         * Encodes the specified Troop message. Does not implicitly {@link troop.Troop.verify|verify} messages.
         * @function encode
         * @memberof troop.Troop
         * @static
         * @param {troop.ITroop} message Troop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Troop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idx);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.eid);
            if (message.heroUid != null && Object.hasOwnProperty.call(message, "heroUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heroUid);
            return writer;
        };

        /**
         * Encodes the specified Troop message, length delimited. Does not implicitly {@link troop.Troop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof troop.Troop
         * @static
         * @param {troop.ITroop} message Troop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Troop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Troop message from the specified reader or buffer.
         * @function decode
         * @memberof troop.Troop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {troop.Troop} Troop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Troop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.troop.Troop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idx = reader.uint32();
                        break;
                    }
                case 2: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.heroUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Troop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof troop.Troop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {troop.Troop} Troop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Troop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Troop message.
         * @function verify
         * @memberof troop.Troop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Troop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.heroUid != null && message.hasOwnProperty("heroUid"))
                if (!$util.isInteger(message.heroUid))
                    return "heroUid: integer expected";
            return null;
        };

        /**
         * Creates a Troop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof troop.Troop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {troop.Troop} Troop
         */
        Troop.fromObject = function fromObject(object) {
            if (object instanceof $root.troop.Troop)
                return object;
            var message = new $root.troop.Troop();
            if (object.idx != null)
                message.idx = object.idx >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.heroUid != null)
                message.heroUid = object.heroUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Troop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof troop.Troop
         * @static
         * @param {troop.Troop} message Troop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Troop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.idx = 0;
                object.eid = 0;
                object.heroUid = 0;
            }
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.heroUid != null && message.hasOwnProperty("heroUid"))
                object.heroUid = message.heroUid;
            return object;
        };

        /**
         * Converts this Troop to JSON.
         * @function toJSON
         * @memberof troop.Troop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Troop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Troop
         * @function getTypeUrl
         * @memberof troop.Troop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Troop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/troop.Troop";
        };

        return Troop;
    })();

    troop.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof troop
         * @interface Ic2s_load
         */

        /**
         * Constructs a new c2s_load.
         * @memberof troop
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {troop.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof troop.c2s_load
         * @static
         * @param {troop.Ic2s_load=} [properties] Properties to set
         * @returns {troop.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link troop.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof troop.c2s_load
         * @static
         * @param {troop.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link troop.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof troop.c2s_load
         * @static
         * @param {troop.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof troop.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {troop.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.troop.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof troop.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {troop.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof troop.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof troop.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {troop.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.troop.c2s_load)
                return object;
            return new $root.troop.c2s_load();
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof troop.c2s_load
         * @static
         * @param {troop.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof troop.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof troop.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/troop.c2s_load";
        };

        return c2s_load;
    })();

    troop.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof troop
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {Array.<troop.ITroop>|null} [troopList] s2c_load troopList
         */

        /**
         * Constructs a new s2c_load.
         * @memberof troop
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {troop.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            this.troopList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof troop.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load troopList.
         * @member {Array.<troop.ITroop>} troopList
         * @memberof troop.s2c_load
         * @instance
         */
        s2c_load.prototype.troopList = $util.emptyArray;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof troop.s2c_load
         * @static
         * @param {troop.Is2c_load=} [properties] Properties to set
         * @returns {troop.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link troop.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof troop.s2c_load
         * @static
         * @param {troop.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.troopList != null && message.troopList.length)
                for (var i = 0; i < message.troopList.length; ++i)
                    $root.troop.Troop.encode(message.troopList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link troop.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof troop.s2c_load
         * @static
         * @param {troop.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof troop.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {troop.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.troop.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.troopList && message.troopList.length))
                            message.troopList = [];
                        message.troopList.push($root.troop.Troop.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof troop.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {troop.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof troop.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.troopList != null && message.hasOwnProperty("troopList")) {
                if (!Array.isArray(message.troopList))
                    return "troopList: array expected";
                for (var i = 0; i < message.troopList.length; ++i) {
                    var error = $root.troop.Troop.verify(message.troopList[i]);
                    if (error)
                        return "troopList." + error;
                }
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof troop.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {troop.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.troop.s2c_load)
                return object;
            var message = new $root.troop.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.troopList) {
                if (!Array.isArray(object.troopList))
                    throw TypeError(".troop.s2c_load.troopList: array expected");
                message.troopList = [];
                for (var i = 0; i < object.troopList.length; ++i) {
                    if (typeof object.troopList[i] !== "object")
                        throw TypeError(".troop.s2c_load.troopList: object expected");
                    message.troopList[i] = $root.troop.Troop.fromObject(object.troopList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof troop.s2c_load
         * @static
         * @param {troop.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.troopList = [];
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.troopList && message.troopList.length) {
                object.troopList = [];
                for (var j = 0; j < message.troopList.length; ++j)
                    object.troopList[j] = $root.troop.Troop.toObject(message.troopList[j], options);
            }
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof troop.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof troop.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/troop.s2c_load";
        };

        return s2c_load;
    })();

    return troop;
})();

$root.user = (function() {

    /**
     * Namespace user.
     * @exports user
     * @namespace
     */
    var user = {};

    user.UserInfo = (function() {

        /**
         * Properties of a UserInfo.
         * @memberof user
         * @interface IUserInfo
         * @property {string|null} [uid] UserInfo uid
         */

        /**
         * Constructs a new UserInfo.
         * @memberof user
         * @classdesc Represents a UserInfo.
         * @implements IUserInfo
         * @constructor
         * @param {user.IUserInfo=} [properties] Properties to set
         */
        function UserInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserInfo uid.
         * @member {string} uid
         * @memberof user.UserInfo
         * @instance
         */
        UserInfo.prototype.uid = "";

        /**
         * Creates a new UserInfo instance using the specified properties.
         * @function create
         * @memberof user.UserInfo
         * @static
         * @param {user.IUserInfo=} [properties] Properties to set
         * @returns {user.UserInfo} UserInfo instance
         */
        UserInfo.create = function create(properties) {
            return new UserInfo(properties);
        };

        /**
         * Encodes the specified UserInfo message. Does not implicitly {@link user.UserInfo.verify|verify} messages.
         * @function encode
         * @memberof user.UserInfo
         * @static
         * @param {user.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
            return writer;
        };

        /**
         * Encodes the specified UserInfo message, length delimited. Does not implicitly {@link user.UserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.UserInfo
         * @static
         * @param {user.IUserInfo} message UserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof user.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.UserInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.UserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.UserInfo} UserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserInfo message.
         * @function verify
         * @memberof user.UserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isString(message.uid))
                    return "uid: string expected";
            return null;
        };

        /**
         * Creates a UserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.UserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.UserInfo} UserInfo
         */
        UserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.user.UserInfo)
                return object;
            var message = new $root.user.UserInfo();
            if (object.uid != null)
                message.uid = String(object.uid);
            return message;
        };

        /**
         * Creates a plain object from a UserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.UserInfo
         * @static
         * @param {user.UserInfo} message UserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.uid = "";
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            return object;
        };

        /**
         * Converts this UserInfo to JSON.
         * @function toJSON
         * @memberof user.UserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserInfo
         * @function getTypeUrl
         * @memberof user.UserInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.UserInfo";
        };

        return UserInfo;
    })();

    user.RoleInfo = (function() {

        /**
         * Properties of a RoleInfo.
         * @memberof user
         * @interface IRoleInfo
         * @property {number|null} [rid] RoleInfo rid
         */

        /**
         * Constructs a new RoleInfo.
         * @memberof user
         * @classdesc Represents a RoleInfo.
         * @implements IRoleInfo
         * @constructor
         * @param {user.IRoleInfo=} [properties] Properties to set
         */
        function RoleInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoleInfo rid.
         * @member {number} rid
         * @memberof user.RoleInfo
         * @instance
         */
        RoleInfo.prototype.rid = 0;

        /**
         * Creates a new RoleInfo instance using the specified properties.
         * @function create
         * @memberof user.RoleInfo
         * @static
         * @param {user.IRoleInfo=} [properties] Properties to set
         * @returns {user.RoleInfo} RoleInfo instance
         */
        RoleInfo.create = function create(properties) {
            return new RoleInfo(properties);
        };

        /**
         * Encodes the specified RoleInfo message. Does not implicitly {@link user.RoleInfo.verify|verify} messages.
         * @function encode
         * @memberof user.RoleInfo
         * @static
         * @param {user.IRoleInfo} message RoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            return writer;
        };

        /**
         * Encodes the specified RoleInfo message, length delimited. Does not implicitly {@link user.RoleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.RoleInfo
         * @static
         * @param {user.IRoleInfo} message RoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof user.RoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.RoleInfo} RoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.RoleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.RoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.RoleInfo} RoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoleInfo message.
         * @function verify
         * @memberof user.RoleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            return null;
        };

        /**
         * Creates a RoleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.RoleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.RoleInfo} RoleInfo
         */
        RoleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.user.RoleInfo)
                return object;
            var message = new $root.user.RoleInfo();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a RoleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.RoleInfo
         * @static
         * @param {user.RoleInfo} message RoleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rid = 0;
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            return object;
        };

        /**
         * Converts this RoleInfo to JSON.
         * @function toJSON
         * @memberof user.RoleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RoleInfo
         * @function getTypeUrl
         * @memberof user.RoleInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.RoleInfo";
        };

        return RoleInfo;
    })();

    user.c2s_login = (function() {

        /**
         * Properties of a c2s_login.
         * @memberof user
         * @interface Ic2s_login
         * @property {string|null} [uid] c2s_login uid
         */

        /**
         * Constructs a new c2s_login.
         * @memberof user
         * @classdesc Represents a c2s_login.
         * @implements Ic2s_login
         * @constructor
         * @param {user.Ic2s_login=} [properties] Properties to set
         */
        function c2s_login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_login uid.
         * @member {string} uid
         * @memberof user.c2s_login
         * @instance
         */
        c2s_login.prototype.uid = "";

        /**
         * Creates a new c2s_login instance using the specified properties.
         * @function create
         * @memberof user.c2s_login
         * @static
         * @param {user.Ic2s_login=} [properties] Properties to set
         * @returns {user.c2s_login} c2s_login instance
         */
        c2s_login.create = function create(properties) {
            return new c2s_login(properties);
        };

        /**
         * Encodes the specified c2s_login message. Does not implicitly {@link user.c2s_login.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_login
         * @static
         * @param {user.Ic2s_login} message c2s_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
            return writer;
        };

        /**
         * Encodes the specified c2s_login message, length delimited. Does not implicitly {@link user.c2s_login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_login
         * @static
         * @param {user.Ic2s_login} message c2s_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_login message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_login} c2s_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_login} c2s_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_login message.
         * @function verify
         * @memberof user.c2s_login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isString(message.uid))
                    return "uid: string expected";
            return null;
        };

        /**
         * Creates a c2s_login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_login} c2s_login
         */
        c2s_login.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_login)
                return object;
            var message = new $root.user.c2s_login();
            if (object.uid != null)
                message.uid = String(object.uid);
            return message;
        };

        /**
         * Creates a plain object from a c2s_login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_login
         * @static
         * @param {user.c2s_login} message c2s_login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.uid = "";
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            return object;
        };

        /**
         * Converts this c2s_login to JSON.
         * @function toJSON
         * @memberof user.c2s_login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_login
         * @function getTypeUrl
         * @memberof user.c2s_login
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_login.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_login";
        };

        return c2s_login;
    })();

    user.s2c_login = (function() {

        /**
         * Properties of a s2c_login.
         * @memberof user
         * @interface Is2c_login
         * @property {number|null} [err] s2c_login err
         * @property {user.IUserInfo|null} [info] s2c_login info
         * @property {user.IRoleInfo|null} [role] s2c_login role
         */

        /**
         * Constructs a new s2c_login.
         * @memberof user
         * @classdesc Represents a s2c_login.
         * @implements Is2c_login
         * @constructor
         * @param {user.Is2c_login=} [properties] Properties to set
         */
        function s2c_login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_login err.
         * @member {number} err
         * @memberof user.s2c_login
         * @instance
         */
        s2c_login.prototype.err = 0;

        /**
         * s2c_login info.
         * @member {user.IUserInfo|null|undefined} info
         * @memberof user.s2c_login
         * @instance
         */
        s2c_login.prototype.info = null;

        /**
         * s2c_login role.
         * @member {user.IRoleInfo|null|undefined} role
         * @memberof user.s2c_login
         * @instance
         */
        s2c_login.prototype.role = null;

        /**
         * Creates a new s2c_login instance using the specified properties.
         * @function create
         * @memberof user.s2c_login
         * @static
         * @param {user.Is2c_login=} [properties] Properties to set
         * @returns {user.s2c_login} s2c_login instance
         */
        s2c_login.create = function create(properties) {
            return new s2c_login(properties);
        };

        /**
         * Encodes the specified s2c_login message. Does not implicitly {@link user.s2c_login.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_login
         * @static
         * @param {user.Is2c_login} message s2c_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                $root.user.UserInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                $root.user.RoleInfo.encode(message.role, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_login message, length delimited. Does not implicitly {@link user.s2c_login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_login
         * @static
         * @param {user.Is2c_login} message s2c_login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_login message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_login} s2c_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.info = $root.user.UserInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.role = $root.user.RoleInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_login} s2c_login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_login message.
         * @function verify
         * @memberof user.s2c_login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.user.UserInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.role != null && message.hasOwnProperty("role")) {
                var error = $root.user.RoleInfo.verify(message.role);
                if (error)
                    return "role." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_login} s2c_login
         */
        s2c_login.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_login)
                return object;
            var message = new $root.user.s2c_login();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.info != null) {
                if (typeof object.info !== "object")
                    throw TypeError(".user.s2c_login.info: object expected");
                message.info = $root.user.UserInfo.fromObject(object.info);
            }
            if (object.role != null) {
                if (typeof object.role !== "object")
                    throw TypeError(".user.s2c_login.role: object expected");
                message.role = $root.user.RoleInfo.fromObject(object.role);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_login
         * @static
         * @param {user.s2c_login} message s2c_login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.info = null;
                object.role = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = $root.user.UserInfo.toObject(message.info, options);
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = $root.user.RoleInfo.toObject(message.role, options);
            return object;
        };

        /**
         * Converts this s2c_login to JSON.
         * @function toJSON
         * @memberof user.s2c_login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_login
         * @function getTypeUrl
         * @memberof user.s2c_login
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_login.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_login";
        };

        return s2c_login;
    })();

    user.c2s_random_name = (function() {

        /**
         * Properties of a c2s_random_name.
         * @memberof user
         * @interface Ic2s_random_name
         */

        /**
         * Constructs a new c2s_random_name.
         * @memberof user
         * @classdesc Represents a c2s_random_name.
         * @implements Ic2s_random_name
         * @constructor
         * @param {user.Ic2s_random_name=} [properties] Properties to set
         */
        function c2s_random_name(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_random_name instance using the specified properties.
         * @function create
         * @memberof user.c2s_random_name
         * @static
         * @param {user.Ic2s_random_name=} [properties] Properties to set
         * @returns {user.c2s_random_name} c2s_random_name instance
         */
        c2s_random_name.create = function create(properties) {
            return new c2s_random_name(properties);
        };

        /**
         * Encodes the specified c2s_random_name message. Does not implicitly {@link user.c2s_random_name.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_random_name
         * @static
         * @param {user.Ic2s_random_name} message c2s_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_random_name.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_random_name message, length delimited. Does not implicitly {@link user.c2s_random_name.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_random_name
         * @static
         * @param {user.Ic2s_random_name} message c2s_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_random_name.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_random_name message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_random_name} c2s_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_random_name.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_random_name();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_random_name message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_random_name} c2s_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_random_name.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_random_name message.
         * @function verify
         * @memberof user.c2s_random_name
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_random_name.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_random_name message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_random_name
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_random_name} c2s_random_name
         */
        c2s_random_name.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_random_name)
                return object;
            return new $root.user.c2s_random_name();
        };

        /**
         * Creates a plain object from a c2s_random_name message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_random_name
         * @static
         * @param {user.c2s_random_name} message c2s_random_name
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_random_name.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_random_name to JSON.
         * @function toJSON
         * @memberof user.c2s_random_name
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_random_name.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_random_name
         * @function getTypeUrl
         * @memberof user.c2s_random_name
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_random_name.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_random_name";
        };

        return c2s_random_name;
    })();

    user.s2c_random_name = (function() {

        /**
         * Properties of a s2c_random_name.
         * @memberof user
         * @interface Is2c_random_name
         * @property {number|null} [err] s2c_random_name err
         * @property {string|null} [name] s2c_random_name name
         */

        /**
         * Constructs a new s2c_random_name.
         * @memberof user
         * @classdesc Represents a s2c_random_name.
         * @implements Is2c_random_name
         * @constructor
         * @param {user.Is2c_random_name=} [properties] Properties to set
         */
        function s2c_random_name(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_random_name err.
         * @member {number} err
         * @memberof user.s2c_random_name
         * @instance
         */
        s2c_random_name.prototype.err = 0;

        /**
         * s2c_random_name name.
         * @member {string} name
         * @memberof user.s2c_random_name
         * @instance
         */
        s2c_random_name.prototype.name = "";

        /**
         * Creates a new s2c_random_name instance using the specified properties.
         * @function create
         * @memberof user.s2c_random_name
         * @static
         * @param {user.Is2c_random_name=} [properties] Properties to set
         * @returns {user.s2c_random_name} s2c_random_name instance
         */
        s2c_random_name.create = function create(properties) {
            return new s2c_random_name(properties);
        };

        /**
         * Encodes the specified s2c_random_name message. Does not implicitly {@link user.s2c_random_name.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_random_name
         * @static
         * @param {user.Is2c_random_name} message s2c_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_random_name.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified s2c_random_name message, length delimited. Does not implicitly {@link user.s2c_random_name.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_random_name
         * @static
         * @param {user.Is2c_random_name} message s2c_random_name message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_random_name.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_random_name message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_random_name} s2c_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_random_name.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_random_name();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_random_name message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_random_name
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_random_name} s2c_random_name
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_random_name.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_random_name message.
         * @function verify
         * @memberof user.s2c_random_name
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_random_name.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a s2c_random_name message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_random_name
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_random_name} s2c_random_name
         */
        s2c_random_name.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_random_name)
                return object;
            var message = new $root.user.s2c_random_name();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a s2c_random_name message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_random_name
         * @static
         * @param {user.s2c_random_name} message s2c_random_name
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_random_name.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.name = "";
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this s2c_random_name to JSON.
         * @function toJSON
         * @memberof user.s2c_random_name
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_random_name.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_random_name
         * @function getTypeUrl
         * @memberof user.s2c_random_name
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_random_name.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_random_name";
        };

        return s2c_random_name;
    })();

    user.c2s_ping = (function() {

        /**
         * Properties of a c2s_ping.
         * @memberof user
         * @interface Ic2s_ping
         */

        /**
         * Constructs a new c2s_ping.
         * @memberof user
         * @classdesc Represents a c2s_ping.
         * @implements Ic2s_ping
         * @constructor
         * @param {user.Ic2s_ping=} [properties] Properties to set
         */
        function c2s_ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new c2s_ping instance using the specified properties.
         * @function create
         * @memberof user.c2s_ping
         * @static
         * @param {user.Ic2s_ping=} [properties] Properties to set
         * @returns {user.c2s_ping} c2s_ping instance
         */
        c2s_ping.create = function create(properties) {
            return new c2s_ping(properties);
        };

        /**
         * Encodes the specified c2s_ping message. Does not implicitly {@link user.c2s_ping.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_ping
         * @static
         * @param {user.Ic2s_ping} message c2s_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified c2s_ping message, length delimited. Does not implicitly {@link user.c2s_ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_ping
         * @static
         * @param {user.Ic2s_ping} message c2s_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_ping message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_ping} c2s_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_ping} c2s_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_ping message.
         * @function verify
         * @memberof user.c2s_ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a c2s_ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_ping} c2s_ping
         */
        c2s_ping.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_ping)
                return object;
            return new $root.user.c2s_ping();
        };

        /**
         * Creates a plain object from a c2s_ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_ping
         * @static
         * @param {user.c2s_ping} message c2s_ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_ping.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this c2s_ping to JSON.
         * @function toJSON
         * @memberof user.c2s_ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_ping
         * @function getTypeUrl
         * @memberof user.c2s_ping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_ping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_ping";
        };

        return c2s_ping;
    })();

    user.s2c_ping = (function() {

        /**
         * Properties of a s2c_ping.
         * @memberof user
         * @interface Is2c_ping
         * @property {number|null} [err] s2c_ping err
         */

        /**
         * Constructs a new s2c_ping.
         * @memberof user
         * @classdesc Represents a s2c_ping.
         * @implements Is2c_ping
         * @constructor
         * @param {user.Is2c_ping=} [properties] Properties to set
         */
        function s2c_ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_ping err.
         * @member {number} err
         * @memberof user.s2c_ping
         * @instance
         */
        s2c_ping.prototype.err = 0;

        /**
         * Creates a new s2c_ping instance using the specified properties.
         * @function create
         * @memberof user.s2c_ping
         * @static
         * @param {user.Is2c_ping=} [properties] Properties to set
         * @returns {user.s2c_ping} s2c_ping instance
         */
        s2c_ping.create = function create(properties) {
            return new s2c_ping(properties);
        };

        /**
         * Encodes the specified s2c_ping message. Does not implicitly {@link user.s2c_ping.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_ping
         * @static
         * @param {user.Is2c_ping} message s2c_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_ping message, length delimited. Does not implicitly {@link user.s2c_ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_ping
         * @static
         * @param {user.Is2c_ping} message s2c_ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_ping message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_ping} s2c_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_ping} s2c_ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_ping message.
         * @function verify
         * @memberof user.s2c_ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_ping} s2c_ping
         */
        s2c_ping.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_ping)
                return object;
            var message = new $root.user.s2c_ping();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_ping
         * @static
         * @param {user.s2c_ping} message s2c_ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_ping.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_ping to JSON.
         * @function toJSON
         * @memberof user.s2c_ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_ping
         * @function getTypeUrl
         * @memberof user.s2c_ping
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_ping.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_ping";
        };

        return s2c_ping;
    })();

    user.c2s_gm = (function() {

        /**
         * Properties of a c2s_gm.
         * @memberof user
         * @interface Ic2s_gm
         * @property {string|null} [cmd] c2s_gm cmd
         */

        /**
         * Constructs a new c2s_gm.
         * @memberof user
         * @classdesc Represents a c2s_gm.
         * @implements Ic2s_gm
         * @constructor
         * @param {user.Ic2s_gm=} [properties] Properties to set
         */
        function c2s_gm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_gm cmd.
         * @member {string} cmd
         * @memberof user.c2s_gm
         * @instance
         */
        c2s_gm.prototype.cmd = "";

        /**
         * Creates a new c2s_gm instance using the specified properties.
         * @function create
         * @memberof user.c2s_gm
         * @static
         * @param {user.Ic2s_gm=} [properties] Properties to set
         * @returns {user.c2s_gm} c2s_gm instance
         */
        c2s_gm.create = function create(properties) {
            return new c2s_gm(properties);
        };

        /**
         * Encodes the specified c2s_gm message. Does not implicitly {@link user.c2s_gm.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_gm
         * @static
         * @param {user.Ic2s_gm} message c2s_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_gm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            return writer;
        };

        /**
         * Encodes the specified c2s_gm message, length delimited. Does not implicitly {@link user.c2s_gm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_gm
         * @static
         * @param {user.Ic2s_gm} message c2s_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_gm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_gm message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_gm} c2s_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_gm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_gm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cmd = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_gm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_gm} c2s_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_gm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_gm message.
         * @function verify
         * @memberof user.c2s_gm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_gm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isString(message.cmd))
                    return "cmd: string expected";
            return null;
        };

        /**
         * Creates a c2s_gm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_gm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_gm} c2s_gm
         */
        c2s_gm.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_gm)
                return object;
            var message = new $root.user.c2s_gm();
            if (object.cmd != null)
                message.cmd = String(object.cmd);
            return message;
        };

        /**
         * Creates a plain object from a c2s_gm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_gm
         * @static
         * @param {user.c2s_gm} message c2s_gm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_gm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.cmd = "";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            return object;
        };

        /**
         * Converts this c2s_gm to JSON.
         * @function toJSON
         * @memberof user.c2s_gm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_gm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_gm
         * @function getTypeUrl
         * @memberof user.c2s_gm
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_gm.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_gm";
        };

        return c2s_gm;
    })();

    user.s2c_gm = (function() {

        /**
         * Properties of a s2c_gm.
         * @memberof user
         * @interface Is2c_gm
         * @property {number|null} [err] s2c_gm err
         * @property {string|null} [msg] s2c_gm msg
         */

        /**
         * Constructs a new s2c_gm.
         * @memberof user
         * @classdesc Represents a s2c_gm.
         * @implements Is2c_gm
         * @constructor
         * @param {user.Is2c_gm=} [properties] Properties to set
         */
        function s2c_gm(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_gm err.
         * @member {number} err
         * @memberof user.s2c_gm
         * @instance
         */
        s2c_gm.prototype.err = 0;

        /**
         * s2c_gm msg.
         * @member {string} msg
         * @memberof user.s2c_gm
         * @instance
         */
        s2c_gm.prototype.msg = "";

        /**
         * Creates a new s2c_gm instance using the specified properties.
         * @function create
         * @memberof user.s2c_gm
         * @static
         * @param {user.Is2c_gm=} [properties] Properties to set
         * @returns {user.s2c_gm} s2c_gm instance
         */
        s2c_gm.create = function create(properties) {
            return new s2c_gm(properties);
        };

        /**
         * Encodes the specified s2c_gm message. Does not implicitly {@link user.s2c_gm.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_gm
         * @static
         * @param {user.Is2c_gm} message s2c_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_gm.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
            return writer;
        };

        /**
         * Encodes the specified s2c_gm message, length delimited. Does not implicitly {@link user.s2c_gm.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_gm
         * @static
         * @param {user.Is2c_gm} message s2c_gm message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_gm.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_gm message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_gm} s2c_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_gm.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_gm();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.msg = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_gm message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_gm
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_gm} s2c_gm
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_gm.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_gm message.
         * @function verify
         * @memberof user.s2c_gm
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_gm.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!$util.isString(message.msg))
                    return "msg: string expected";
            return null;
        };

        /**
         * Creates a s2c_gm message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_gm
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_gm} s2c_gm
         */
        s2c_gm.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_gm)
                return object;
            var message = new $root.user.s2c_gm();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.msg != null)
                message.msg = String(object.msg);
            return message;
        };

        /**
         * Creates a plain object from a s2c_gm message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_gm
         * @static
         * @param {user.s2c_gm} message s2c_gm
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_gm.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.msg = "";
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = message.msg;
            return object;
        };

        /**
         * Converts this s2c_gm to JSON.
         * @function toJSON
         * @memberof user.s2c_gm
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_gm.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_gm
         * @function getTypeUrl
         * @memberof user.s2c_gm
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_gm.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_gm";
        };

        return s2c_gm;
    })();

    user.c2s_rename = (function() {

        /**
         * Properties of a c2s_rename.
         * @memberof user
         * @interface Ic2s_rename
         * @property {string|null} [name] c2s_rename name
         */

        /**
         * Constructs a new c2s_rename.
         * @memberof user
         * @classdesc Represents a c2s_rename.
         * @implements Ic2s_rename
         * @constructor
         * @param {user.Ic2s_rename=} [properties] Properties to set
         */
        function c2s_rename(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_rename name.
         * @member {string} name
         * @memberof user.c2s_rename
         * @instance
         */
        c2s_rename.prototype.name = "";

        /**
         * Creates a new c2s_rename instance using the specified properties.
         * @function create
         * @memberof user.c2s_rename
         * @static
         * @param {user.Ic2s_rename=} [properties] Properties to set
         * @returns {user.c2s_rename} c2s_rename instance
         */
        c2s_rename.create = function create(properties) {
            return new c2s_rename(properties);
        };

        /**
         * Encodes the specified c2s_rename message. Does not implicitly {@link user.c2s_rename.verify|verify} messages.
         * @function encode
         * @memberof user.c2s_rename
         * @static
         * @param {user.Ic2s_rename} message c2s_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_rename.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified c2s_rename message, length delimited. Does not implicitly {@link user.c2s_rename.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.c2s_rename
         * @static
         * @param {user.Ic2s_rename} message c2s_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_rename.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_rename message from the specified reader or buffer.
         * @function decode
         * @memberof user.c2s_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.c2s_rename} c2s_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_rename.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.c2s_rename();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_rename message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.c2s_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.c2s_rename} c2s_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_rename.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_rename message.
         * @function verify
         * @memberof user.c2s_rename
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_rename.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a c2s_rename message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.c2s_rename
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.c2s_rename} c2s_rename
         */
        c2s_rename.fromObject = function fromObject(object) {
            if (object instanceof $root.user.c2s_rename)
                return object;
            var message = new $root.user.c2s_rename();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a c2s_rename message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.c2s_rename
         * @static
         * @param {user.c2s_rename} message c2s_rename
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_rename.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this c2s_rename to JSON.
         * @function toJSON
         * @memberof user.c2s_rename
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_rename.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_rename
         * @function getTypeUrl
         * @memberof user.c2s_rename
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_rename.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.c2s_rename";
        };

        return c2s_rename;
    })();

    user.s2c_rename = (function() {

        /**
         * Properties of a s2c_rename.
         * @memberof user
         * @interface Is2c_rename
         * @property {number|null} [err] s2c_rename err
         */

        /**
         * Constructs a new s2c_rename.
         * @memberof user
         * @classdesc Represents a s2c_rename.
         * @implements Is2c_rename
         * @constructor
         * @param {user.Is2c_rename=} [properties] Properties to set
         */
        function s2c_rename(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_rename err.
         * @member {number} err
         * @memberof user.s2c_rename
         * @instance
         */
        s2c_rename.prototype.err = 0;

        /**
         * Creates a new s2c_rename instance using the specified properties.
         * @function create
         * @memberof user.s2c_rename
         * @static
         * @param {user.Is2c_rename=} [properties] Properties to set
         * @returns {user.s2c_rename} s2c_rename instance
         */
        s2c_rename.create = function create(properties) {
            return new s2c_rename(properties);
        };

        /**
         * Encodes the specified s2c_rename message. Does not implicitly {@link user.s2c_rename.verify|verify} messages.
         * @function encode
         * @memberof user.s2c_rename
         * @static
         * @param {user.Is2c_rename} message s2c_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_rename.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_rename message, length delimited. Does not implicitly {@link user.s2c_rename.verify|verify} messages.
         * @function encodeDelimited
         * @memberof user.s2c_rename
         * @static
         * @param {user.Is2c_rename} message s2c_rename message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_rename.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_rename message from the specified reader or buffer.
         * @function decode
         * @memberof user.s2c_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {user.s2c_rename} s2c_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_rename.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.user.s2c_rename();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_rename message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof user.s2c_rename
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {user.s2c_rename} s2c_rename
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_rename.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_rename message.
         * @function verify
         * @memberof user.s2c_rename
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_rename.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_rename message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof user.s2c_rename
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {user.s2c_rename} s2c_rename
         */
        s2c_rename.fromObject = function fromObject(object) {
            if (object instanceof $root.user.s2c_rename)
                return object;
            var message = new $root.user.s2c_rename();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_rename message. Also converts values to other types if specified.
         * @function toObject
         * @memberof user.s2c_rename
         * @static
         * @param {user.s2c_rename} message s2c_rename
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_rename.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_rename to JSON.
         * @function toJSON
         * @memberof user.s2c_rename
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_rename.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_rename
         * @function getTypeUrl
         * @memberof user.s2c_rename
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_rename.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/user.s2c_rename";
        };

        return s2c_rename;
    })();

    return user;
})();

$root.world = (function() {

    /**
     * Namespace world.
     * @exports world
     * @namespace
     */
    var world = {};

    world.Role = (function() {

        /**
         * Properties of a Role.
         * @memberof world
         * @interface IRole
         * @property {number|null} [rid] Role rid
         * @property {string|null} [name] Role name
         * @property {number|null} [aid] Role aid
         */

        /**
         * Constructs a new Role.
         * @memberof world
         * @classdesc Represents a Role.
         * @implements IRole
         * @constructor
         * @param {world.IRole=} [properties] Properties to set
         */
        function Role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Role rid.
         * @member {number} rid
         * @memberof world.Role
         * @instance
         */
        Role.prototype.rid = 0;

        /**
         * Role name.
         * @member {string} name
         * @memberof world.Role
         * @instance
         */
        Role.prototype.name = "";

        /**
         * Role aid.
         * @member {number} aid
         * @memberof world.Role
         * @instance
         */
        Role.prototype.aid = 0;

        /**
         * Creates a new Role instance using the specified properties.
         * @function create
         * @memberof world.Role
         * @static
         * @param {world.IRole=} [properties] Properties to set
         * @returns {world.Role} Role instance
         */
        Role.create = function create(properties) {
            return new Role(properties);
        };

        /**
         * Encodes the specified Role message. Does not implicitly {@link world.Role.verify|verify} messages.
         * @function encode
         * @memberof world.Role
         * @static
         * @param {world.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.aid);
            return writer;
        };

        /**
         * Encodes the specified Role message, length delimited. Does not implicitly {@link world.Role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Role
         * @static
         * @param {world.IRole} message Role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Role message from the specified reader or buffer.
         * @function decode
         * @memberof world.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.aid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Role} Role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Role message.
         * @function verify
         * @memberof world.Role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            return null;
        };

        /**
         * Creates a Role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Role} Role
         */
        Role.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Role)
                return object;
            var message = new $root.world.Role();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Role
         * @static
         * @param {world.Role} message Role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rid = 0;
                object.name = "";
                object.aid = 0;
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            return object;
        };

        /**
         * Converts this Role to JSON.
         * @function toJSON
         * @memberof world.Role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Role
         * @function getTypeUrl
         * @memberof world.Role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Role";
        };

        return Role;
    })();

    world.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof world
         * @interface IPosition
         * @property {number|null} [x] Position x
         * @property {number|null} [y] Position y
         */

        /**
         * Constructs a new Position.
         * @memberof world
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {world.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position x.
         * @member {number} x
         * @memberof world.Position
         * @instance
         */
        Position.prototype.x = 0;

        /**
         * Position y.
         * @member {number} y
         * @memberof world.Position
         * @instance
         */
        Position.prototype.y = 0;

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof world.Position
         * @static
         * @param {world.IPosition=} [properties] Properties to set
         * @returns {world.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link world.Position.verify|verify} messages.
         * @function encode
         * @memberof world.Position
         * @static
         * @param {world.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link world.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Position
         * @static
         * @param {world.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof world.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Position();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof world.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Position)
                return object;
            var message = new $root.world.Position();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Position
         * @static
         * @param {world.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof world.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof world.Position
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Position";
        };

        return Position;
    })();

    world.Alliance = (function() {

        /**
         * Properties of an Alliance.
         * @memberof world
         * @interface IAlliance
         * @property {number|null} [aid] Alliance aid
         * @property {string|null} [name] Alliance name
         */

        /**
         * Constructs a new Alliance.
         * @memberof world
         * @classdesc Represents an Alliance.
         * @implements IAlliance
         * @constructor
         * @param {world.IAlliance=} [properties] Properties to set
         */
        function Alliance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Alliance aid.
         * @member {number} aid
         * @memberof world.Alliance
         * @instance
         */
        Alliance.prototype.aid = 0;

        /**
         * Alliance name.
         * @member {string} name
         * @memberof world.Alliance
         * @instance
         */
        Alliance.prototype.name = "";

        /**
         * Creates a new Alliance instance using the specified properties.
         * @function create
         * @memberof world.Alliance
         * @static
         * @param {world.IAlliance=} [properties] Properties to set
         * @returns {world.Alliance} Alliance instance
         */
        Alliance.create = function create(properties) {
            return new Alliance(properties);
        };

        /**
         * Encodes the specified Alliance message. Does not implicitly {@link world.Alliance.verify|verify} messages.
         * @function encode
         * @memberof world.Alliance
         * @static
         * @param {world.IAlliance} message Alliance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Alliance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.aid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Alliance message, length delimited. Does not implicitly {@link world.Alliance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Alliance
         * @static
         * @param {world.IAlliance} message Alliance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Alliance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Alliance message from the specified reader or buffer.
         * @function decode
         * @memberof world.Alliance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Alliance} Alliance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Alliance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Alliance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.aid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Alliance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Alliance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Alliance} Alliance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Alliance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Alliance message.
         * @function verify
         * @memberof world.Alliance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Alliance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates an Alliance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Alliance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Alliance} Alliance
         */
        Alliance.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Alliance)
                return object;
            var message = new $root.world.Alliance();
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from an Alliance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Alliance
         * @static
         * @param {world.Alliance} message Alliance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Alliance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.aid = 0;
                object.name = "";
            }
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Alliance to JSON.
         * @function toJSON
         * @memberof world.Alliance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Alliance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Alliance
         * @function getTypeUrl
         * @memberof world.Alliance
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Alliance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Alliance";
        };

        return Alliance;
    })();

    world.TroopComponent = (function() {

        /**
         * Properties of a TroopComponent.
         * @memberof world
         * @interface ITroopComponent
         * @property {number|null} [heroId] TroopComponent heroId
         * @property {number|null} [soldierId] TroopComponent soldierId
         * @property {number|null} [cmd] TroopComponent cmd
         * @property {number|null} [insideEid] TroopComponent insideEid
         * @property {number|null} [homeEid] TroopComponent homeEid
         * @property {number|null} [battleEid] TroopComponent battleEid
         * @property {number|null} [maxHp] TroopComponent maxHp
         * @property {number|null} [hp] TroopComponent hp
         * @property {number|null} [state] TroopComponent state
         */

        /**
         * Constructs a new TroopComponent.
         * @memberof world
         * @classdesc Represents a TroopComponent.
         * @implements ITroopComponent
         * @constructor
         * @param {world.ITroopComponent=} [properties] Properties to set
         */
        function TroopComponent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TroopComponent heroId.
         * @member {number} heroId
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.heroId = 0;

        /**
         * TroopComponent soldierId.
         * @member {number} soldierId
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.soldierId = 0;

        /**
         * TroopComponent cmd.
         * @member {number} cmd
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.cmd = 0;

        /**
         * TroopComponent insideEid.
         * @member {number} insideEid
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.insideEid = 0;

        /**
         * TroopComponent homeEid.
         * @member {number} homeEid
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.homeEid = 0;

        /**
         * TroopComponent battleEid.
         * @member {number} battleEid
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.battleEid = 0;

        /**
         * TroopComponent maxHp.
         * @member {number} maxHp
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.maxHp = 0;

        /**
         * TroopComponent hp.
         * @member {number} hp
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.hp = 0;

        /**
         * TroopComponent state.
         * @member {number} state
         * @memberof world.TroopComponent
         * @instance
         */
        TroopComponent.prototype.state = 0;

        /**
         * Creates a new TroopComponent instance using the specified properties.
         * @function create
         * @memberof world.TroopComponent
         * @static
         * @param {world.ITroopComponent=} [properties] Properties to set
         * @returns {world.TroopComponent} TroopComponent instance
         */
        TroopComponent.create = function create(properties) {
            return new TroopComponent(properties);
        };

        /**
         * Encodes the specified TroopComponent message. Does not implicitly {@link world.TroopComponent.verify|verify} messages.
         * @function encode
         * @memberof world.TroopComponent
         * @static
         * @param {world.ITroopComponent} message TroopComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TroopComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.heroId);
            if (message.soldierId != null && Object.hasOwnProperty.call(message, "soldierId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.soldierId);
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.cmd);
            if (message.insideEid != null && Object.hasOwnProperty.call(message, "insideEid"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.insideEid);
            if (message.homeEid != null && Object.hasOwnProperty.call(message, "homeEid"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.homeEid);
            if (message.battleEid != null && Object.hasOwnProperty.call(message, "battleEid"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.battleEid);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.maxHp);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.hp);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.state);
            return writer;
        };

        /**
         * Encodes the specified TroopComponent message, length delimited. Does not implicitly {@link world.TroopComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.TroopComponent
         * @static
         * @param {world.ITroopComponent} message TroopComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TroopComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TroopComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.TroopComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.TroopComponent} TroopComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TroopComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.TroopComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.heroId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.soldierId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.cmd = reader.uint32();
                        break;
                    }
                case 4: {
                        message.insideEid = reader.uint32();
                        break;
                    }
                case 5: {
                        message.homeEid = reader.uint32();
                        break;
                    }
                case 6: {
                        message.battleEid = reader.uint32();
                        break;
                    }
                case 7: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 8: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 9: {
                        message.state = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TroopComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.TroopComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.TroopComponent} TroopComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TroopComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TroopComponent message.
         * @function verify
         * @memberof world.TroopComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TroopComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                if (!$util.isInteger(message.soldierId))
                    return "soldierId: integer expected";
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                if (!$util.isInteger(message.cmd))
                    return "cmd: integer expected";
            if (message.insideEid != null && message.hasOwnProperty("insideEid"))
                if (!$util.isInteger(message.insideEid))
                    return "insideEid: integer expected";
            if (message.homeEid != null && message.hasOwnProperty("homeEid"))
                if (!$util.isInteger(message.homeEid))
                    return "homeEid: integer expected";
            if (message.battleEid != null && message.hasOwnProperty("battleEid"))
                if (!$util.isInteger(message.battleEid))
                    return "battleEid: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };

        /**
         * Creates a TroopComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.TroopComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.TroopComponent} TroopComponent
         */
        TroopComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.TroopComponent)
                return object;
            var message = new $root.world.TroopComponent();
            if (object.heroId != null)
                message.heroId = object.heroId >>> 0;
            if (object.soldierId != null)
                message.soldierId = object.soldierId >>> 0;
            if (object.cmd != null)
                message.cmd = object.cmd >>> 0;
            if (object.insideEid != null)
                message.insideEid = object.insideEid >>> 0;
            if (object.homeEid != null)
                message.homeEid = object.homeEid >>> 0;
            if (object.battleEid != null)
                message.battleEid = object.battleEid >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.state != null)
                message.state = object.state >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TroopComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.TroopComponent
         * @static
         * @param {world.TroopComponent} message TroopComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TroopComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroId = 0;
                object.soldierId = 0;
                object.cmd = 0;
                object.insideEid = 0;
                object.homeEid = 0;
                object.battleEid = 0;
                object.maxHp = 0;
                object.hp = 0;
                object.state = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.soldierId != null && message.hasOwnProperty("soldierId"))
                object.soldierId = message.soldierId;
            if (message.cmd != null && message.hasOwnProperty("cmd"))
                object.cmd = message.cmd;
            if (message.insideEid != null && message.hasOwnProperty("insideEid"))
                object.insideEid = message.insideEid;
            if (message.homeEid != null && message.hasOwnProperty("homeEid"))
                object.homeEid = message.homeEid;
            if (message.battleEid != null && message.hasOwnProperty("battleEid"))
                object.battleEid = message.battleEid;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };

        /**
         * Converts this TroopComponent to JSON.
         * @function toJSON
         * @memberof world.TroopComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TroopComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TroopComponent
         * @function getTypeUrl
         * @memberof world.TroopComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TroopComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.TroopComponent";
        };

        return TroopComponent;
    })();

    world.OwnerComponent = (function() {

        /**
         * Properties of an OwnerComponent.
         * @memberof world
         * @interface IOwnerComponent
         * @property {number|null} [rid] OwnerComponent rid
         * @property {number|null} [aid] OwnerComponent aid
         * @property {number|null} [eid] OwnerComponent eid
         * @property {boolean|null} [isRobot] OwnerComponent isRobot
         * @property {string|null} [roleName] OwnerComponent roleName
         * @property {string|null} [allianceName] OwnerComponent allianceName
         */

        /**
         * Constructs a new OwnerComponent.
         * @memberof world
         * @classdesc Represents an OwnerComponent.
         * @implements IOwnerComponent
         * @constructor
         * @param {world.IOwnerComponent=} [properties] Properties to set
         */
        function OwnerComponent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OwnerComponent rid.
         * @member {number} rid
         * @memberof world.OwnerComponent
         * @instance
         */
        OwnerComponent.prototype.rid = 0;

        /**
         * OwnerComponent aid.
         * @member {number} aid
         * @memberof world.OwnerComponent
         * @instance
         */
        OwnerComponent.prototype.aid = 0;

        /**
         * OwnerComponent eid.
         * @member {number} eid
         * @memberof world.OwnerComponent
         * @instance
         */
        OwnerComponent.prototype.eid = 0;

        /**
         * OwnerComponent isRobot.
         * @member {boolean} isRobot
         * @memberof world.OwnerComponent
         * @instance
         */
        OwnerComponent.prototype.isRobot = false;

        /**
         * OwnerComponent roleName.
         * @member {string} roleName
         * @memberof world.OwnerComponent
         * @instance
         */
        OwnerComponent.prototype.roleName = "";

        /**
         * OwnerComponent allianceName.
         * @member {string} allianceName
         * @memberof world.OwnerComponent
         * @instance
         */
        OwnerComponent.prototype.allianceName = "";

        /**
         * Creates a new OwnerComponent instance using the specified properties.
         * @function create
         * @memberof world.OwnerComponent
         * @static
         * @param {world.IOwnerComponent=} [properties] Properties to set
         * @returns {world.OwnerComponent} OwnerComponent instance
         */
        OwnerComponent.create = function create(properties) {
            return new OwnerComponent(properties);
        };

        /**
         * Encodes the specified OwnerComponent message. Does not implicitly {@link world.OwnerComponent.verify|verify} messages.
         * @function encode
         * @memberof world.OwnerComponent
         * @static
         * @param {world.IOwnerComponent} message OwnerComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rid);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.aid);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.eid);
            if (message.isRobot != null && Object.hasOwnProperty.call(message, "isRobot"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isRobot);
            if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.roleName);
            if (message.allianceName != null && Object.hasOwnProperty.call(message, "allianceName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.allianceName);
            return writer;
        };

        /**
         * Encodes the specified OwnerComponent message, length delimited. Does not implicitly {@link world.OwnerComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.OwnerComponent
         * @static
         * @param {world.IOwnerComponent} message OwnerComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OwnerComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.OwnerComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.OwnerComponent} OwnerComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.OwnerComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.aid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 4: {
                        message.isRobot = reader.bool();
                        break;
                    }
                case 5: {
                        message.roleName = reader.string();
                        break;
                    }
                case 6: {
                        message.allianceName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OwnerComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.OwnerComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.OwnerComponent} OwnerComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OwnerComponent message.
         * @function verify
         * @memberof world.OwnerComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OwnerComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.isRobot != null && message.hasOwnProperty("isRobot"))
                if (typeof message.isRobot !== "boolean")
                    return "isRobot: boolean expected";
            if (message.roleName != null && message.hasOwnProperty("roleName"))
                if (!$util.isString(message.roleName))
                    return "roleName: string expected";
            if (message.allianceName != null && message.hasOwnProperty("allianceName"))
                if (!$util.isString(message.allianceName))
                    return "allianceName: string expected";
            return null;
        };

        /**
         * Creates an OwnerComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.OwnerComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.OwnerComponent} OwnerComponent
         */
        OwnerComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.OwnerComponent)
                return object;
            var message = new $root.world.OwnerComponent();
            if (object.rid != null)
                message.rid = object.rid >>> 0;
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.isRobot != null)
                message.isRobot = Boolean(object.isRobot);
            if (object.roleName != null)
                message.roleName = String(object.roleName);
            if (object.allianceName != null)
                message.allianceName = String(object.allianceName);
            return message;
        };

        /**
         * Creates a plain object from an OwnerComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.OwnerComponent
         * @static
         * @param {world.OwnerComponent} message OwnerComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OwnerComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rid = 0;
                object.aid = 0;
                object.eid = 0;
                object.isRobot = false;
                object.roleName = "";
                object.allianceName = "";
            }
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.isRobot != null && message.hasOwnProperty("isRobot"))
                object.isRobot = message.isRobot;
            if (message.roleName != null && message.hasOwnProperty("roleName"))
                object.roleName = message.roleName;
            if (message.allianceName != null && message.hasOwnProperty("allianceName"))
                object.allianceName = message.allianceName;
            return object;
        };

        /**
         * Converts this OwnerComponent to JSON.
         * @function toJSON
         * @memberof world.OwnerComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OwnerComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OwnerComponent
         * @function getTypeUrl
         * @memberof world.OwnerComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OwnerComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.OwnerComponent";
        };

        return OwnerComponent;
    })();

    world.Timer = (function() {

        /**
         * Properties of a Timer.
         * @memberof world
         * @interface ITimer
         * @property {number|null} [type] Timer type
         * @property {number|null} [start] Timer start
         * @property {number|null} [expire] Timer expire
         */

        /**
         * Constructs a new Timer.
         * @memberof world
         * @classdesc Represents a Timer.
         * @implements ITimer
         * @constructor
         * @param {world.ITimer=} [properties] Properties to set
         */
        function Timer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timer type.
         * @member {number} type
         * @memberof world.Timer
         * @instance
         */
        Timer.prototype.type = 0;

        /**
         * Timer start.
         * @member {number} start
         * @memberof world.Timer
         * @instance
         */
        Timer.prototype.start = 0;

        /**
         * Timer expire.
         * @member {number} expire
         * @memberof world.Timer
         * @instance
         */
        Timer.prototype.expire = 0;

        /**
         * Creates a new Timer instance using the specified properties.
         * @function create
         * @memberof world.Timer
         * @static
         * @param {world.ITimer=} [properties] Properties to set
         * @returns {world.Timer} Timer instance
         */
        Timer.create = function create(properties) {
            return new Timer(properties);
        };

        /**
         * Encodes the specified Timer message. Does not implicitly {@link world.Timer.verify|verify} messages.
         * @function encode
         * @memberof world.Timer
         * @static
         * @param {world.ITimer} message Timer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.start);
            if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expire);
            return writer;
        };

        /**
         * Encodes the specified Timer message, length delimited. Does not implicitly {@link world.Timer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Timer
         * @static
         * @param {world.ITimer} message Timer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timer message from the specified reader or buffer.
         * @function decode
         * @memberof world.Timer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Timer} Timer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Timer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.uint32();
                        break;
                    }
                case 2: {
                        message.start = reader.uint32();
                        break;
                    }
                case 3: {
                        message.expire = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Timer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Timer} Timer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timer message.
         * @function verify
         * @memberof world.Timer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (!$util.isInteger(message.start))
                    return "start: integer expected";
            if (message.expire != null && message.hasOwnProperty("expire"))
                if (!$util.isInteger(message.expire))
                    return "expire: integer expected";
            return null;
        };

        /**
         * Creates a Timer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Timer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Timer} Timer
         */
        Timer.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Timer)
                return object;
            var message = new $root.world.Timer();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.start != null)
                message.start = object.start >>> 0;
            if (object.expire != null)
                message.expire = object.expire >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Timer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Timer
         * @static
         * @param {world.Timer} message Timer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.start = 0;
                object.expire = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = message.start;
            if (message.expire != null && message.hasOwnProperty("expire"))
                object.expire = message.expire;
            return object;
        };

        /**
         * Converts this Timer to JSON.
         * @function toJSON
         * @memberof world.Timer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Timer
         * @function getTypeUrl
         * @memberof world.Timer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Timer";
        };

        return Timer;
    })();

    world.TimerComponent = (function() {

        /**
         * Properties of a TimerComponent.
         * @memberof world
         * @interface ITimerComponent
         * @property {Object.<string,world.ITimer>|null} [timers] TimerComponent timers
         */

        /**
         * Constructs a new TimerComponent.
         * @memberof world
         * @classdesc Represents a TimerComponent.
         * @implements ITimerComponent
         * @constructor
         * @param {world.ITimerComponent=} [properties] Properties to set
         */
        function TimerComponent(properties) {
            this.timers = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimerComponent timers.
         * @member {Object.<string,world.ITimer>} timers
         * @memberof world.TimerComponent
         * @instance
         */
        TimerComponent.prototype.timers = $util.emptyObject;

        /**
         * Creates a new TimerComponent instance using the specified properties.
         * @function create
         * @memberof world.TimerComponent
         * @static
         * @param {world.ITimerComponent=} [properties] Properties to set
         * @returns {world.TimerComponent} TimerComponent instance
         */
        TimerComponent.create = function create(properties) {
            return new TimerComponent(properties);
        };

        /**
         * Encodes the specified TimerComponent message. Does not implicitly {@link world.TimerComponent.verify|verify} messages.
         * @function encode
         * @memberof world.TimerComponent
         * @static
         * @param {world.ITimerComponent} message TimerComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimerComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timers != null && Object.hasOwnProperty.call(message, "timers"))
                for (var keys = Object.keys(message.timers), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.world.Timer.encode(message.timers[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified TimerComponent message, length delimited. Does not implicitly {@link world.TimerComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.TimerComponent
         * @static
         * @param {world.ITimerComponent} message TimerComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimerComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TimerComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.TimerComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.TimerComponent} TimerComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimerComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.TimerComponent(), key, value;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.timers === $util.emptyObject)
                            message.timers = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.world.Timer.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.timers[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TimerComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.TimerComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.TimerComponent} TimerComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimerComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TimerComponent message.
         * @function verify
         * @memberof world.TimerComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimerComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timers != null && message.hasOwnProperty("timers")) {
                if (!$util.isObject(message.timers))
                    return "timers: object expected";
                var key = Object.keys(message.timers);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "timers: integer key{k:uint32} expected";
                    {
                        var error = $root.world.Timer.verify(message.timers[key[i]]);
                        if (error)
                            return "timers." + error;
                    }
                }
            }
            return null;
        };

        /**
         * Creates a TimerComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.TimerComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.TimerComponent} TimerComponent
         */
        TimerComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.TimerComponent)
                return object;
            var message = new $root.world.TimerComponent();
            if (object.timers) {
                if (typeof object.timers !== "object")
                    throw TypeError(".world.TimerComponent.timers: object expected");
                message.timers = {};
                for (var keys = Object.keys(object.timers), i = 0; i < keys.length; ++i) {
                    if (typeof object.timers[keys[i]] !== "object")
                        throw TypeError(".world.TimerComponent.timers: object expected");
                    message.timers[keys[i]] = $root.world.Timer.fromObject(object.timers[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TimerComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.TimerComponent
         * @static
         * @param {world.TimerComponent} message TimerComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimerComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.timers = {};
            var keys2;
            if (message.timers && (keys2 = Object.keys(message.timers)).length) {
                object.timers = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.timers[keys2[j]] = $root.world.Timer.toObject(message.timers[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this TimerComponent to JSON.
         * @function toJSON
         * @memberof world.TimerComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimerComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TimerComponent
         * @function getTypeUrl
         * @memberof world.TimerComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TimerComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.TimerComponent";
        };

        return TimerComponent;
    })();

    world.MoveComponent = (function() {

        /**
         * Properties of a MoveComponent.
         * @memberof world
         * @interface IMoveComponent
         * @property {number|null} [startMs] MoveComponent startMs
         * @property {Array.<world.IPosition>|null} [path] MoveComponent path
         * @property {number|null} [speed] MoveComponent speed
         * @property {number|null} [degree] MoveComponent degree
         */

        /**
         * Constructs a new MoveComponent.
         * @memberof world
         * @classdesc Represents a MoveComponent.
         * @implements IMoveComponent
         * @constructor
         * @param {world.IMoveComponent=} [properties] Properties to set
         */
        function MoveComponent(properties) {
            this.path = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveComponent startMs.
         * @member {number} startMs
         * @memberof world.MoveComponent
         * @instance
         */
        MoveComponent.prototype.startMs = 0;

        /**
         * MoveComponent path.
         * @member {Array.<world.IPosition>} path
         * @memberof world.MoveComponent
         * @instance
         */
        MoveComponent.prototype.path = $util.emptyArray;

        /**
         * MoveComponent speed.
         * @member {number} speed
         * @memberof world.MoveComponent
         * @instance
         */
        MoveComponent.prototype.speed = 0;

        /**
         * MoveComponent degree.
         * @member {number} degree
         * @memberof world.MoveComponent
         * @instance
         */
        MoveComponent.prototype.degree = 0;

        /**
         * Creates a new MoveComponent instance using the specified properties.
         * @function create
         * @memberof world.MoveComponent
         * @static
         * @param {world.IMoveComponent=} [properties] Properties to set
         * @returns {world.MoveComponent} MoveComponent instance
         */
        MoveComponent.create = function create(properties) {
            return new MoveComponent(properties);
        };

        /**
         * Encodes the specified MoveComponent message. Does not implicitly {@link world.MoveComponent.verify|verify} messages.
         * @function encode
         * @memberof world.MoveComponent
         * @static
         * @param {world.IMoveComponent} message MoveComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startMs != null && Object.hasOwnProperty.call(message, "startMs"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.startMs);
            if (message.path != null && message.path.length)
                for (var i = 0; i < message.path.length; ++i)
                    $root.world.Position.encode(message.path[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.speed);
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.degree);
            return writer;
        };

        /**
         * Encodes the specified MoveComponent message, length delimited. Does not implicitly {@link world.MoveComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.MoveComponent
         * @static
         * @param {world.IMoveComponent} message MoveComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.MoveComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.MoveComponent} MoveComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.MoveComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.startMs = reader.uint32();
                        break;
                    }
                case 3: {
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push($root.world.Position.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.speed = reader.float();
                        break;
                    }
                case 5: {
                        message.degree = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.MoveComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.MoveComponent} MoveComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveComponent message.
         * @function verify
         * @memberof world.MoveComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                if (!$util.isInteger(message.startMs))
                    return "startMs: integer expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (var i = 0; i < message.path.length; ++i) {
                    var error = $root.world.Position.verify(message.path[i]);
                    if (error)
                        return "path." + error;
                }
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (typeof message.speed !== "number")
                    return "speed: number expected";
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (typeof message.degree !== "number")
                    return "degree: number expected";
            return null;
        };

        /**
         * Creates a MoveComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.MoveComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.MoveComponent} MoveComponent
         */
        MoveComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.MoveComponent)
                return object;
            var message = new $root.world.MoveComponent();
            if (object.startMs != null)
                message.startMs = object.startMs >>> 0;
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".world.MoveComponent.path: array expected");
                message.path = [];
                for (var i = 0; i < object.path.length; ++i) {
                    if (typeof object.path[i] !== "object")
                        throw TypeError(".world.MoveComponent.path: object expected");
                    message.path[i] = $root.world.Position.fromObject(object.path[i]);
                }
            }
            if (object.speed != null)
                message.speed = Number(object.speed);
            if (object.degree != null)
                message.degree = Number(object.degree);
            return message;
        };

        /**
         * Creates a plain object from a MoveComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.MoveComponent
         * @static
         * @param {world.MoveComponent} message MoveComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoveComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (options.defaults) {
                object.startMs = 0;
                object.speed = 0;
                object.degree = 0;
            }
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                object.startMs = message.startMs;
            if (message.path && message.path.length) {
                object.path = [];
                for (var j = 0; j < message.path.length; ++j)
                    object.path[j] = $root.world.Position.toObject(message.path[j], options);
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = options.json && !isFinite(message.degree) ? String(message.degree) : message.degree;
            return object;
        };

        /**
         * Converts this MoveComponent to JSON.
         * @function toJSON
         * @memberof world.MoveComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoveComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MoveComponent
         * @function getTypeUrl
         * @memberof world.MoveComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MoveComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.MoveComponent";
        };

        return MoveComponent;
    })();

    world.BuildingComponent = (function() {

        /**
         * Properties of a BuildingComponent.
         * @memberof world
         * @interface IBuildingComponent
         * @property {number|null} [bid] BuildingComponent bid
         * @property {number|null} [hp] BuildingComponent hp
         * @property {number|null} [maxHp] BuildingComponent maxHp
         * @property {number|null} [autoHpMs] BuildingComponent autoHpMs
         * @property {number|null} [autoHp] BuildingComponent autoHp
         * @property {number|null} [autoHpInr] BuildingComponent autoHpInr
         * @property {string|null} [name] BuildingComponent name
         */

        /**
         * Constructs a new BuildingComponent.
         * @memberof world
         * @classdesc Represents a BuildingComponent.
         * @implements IBuildingComponent
         * @constructor
         * @param {world.IBuildingComponent=} [properties] Properties to set
         */
        function BuildingComponent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuildingComponent bid.
         * @member {number} bid
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.bid = 0;

        /**
         * BuildingComponent hp.
         * @member {number} hp
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.hp = 0;

        /**
         * BuildingComponent maxHp.
         * @member {number} maxHp
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.maxHp = 0;

        /**
         * BuildingComponent autoHpMs.
         * @member {number} autoHpMs
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.autoHpMs = 0;

        /**
         * BuildingComponent autoHp.
         * @member {number} autoHp
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.autoHp = 0;

        /**
         * BuildingComponent autoHpInr.
         * @member {number} autoHpInr
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.autoHpInr = 0;

        /**
         * BuildingComponent name.
         * @member {string} name
         * @memberof world.BuildingComponent
         * @instance
         */
        BuildingComponent.prototype.name = "";

        /**
         * Creates a new BuildingComponent instance using the specified properties.
         * @function create
         * @memberof world.BuildingComponent
         * @static
         * @param {world.IBuildingComponent=} [properties] Properties to set
         * @returns {world.BuildingComponent} BuildingComponent instance
         */
        BuildingComponent.create = function create(properties) {
            return new BuildingComponent(properties);
        };

        /**
         * Encodes the specified BuildingComponent message. Does not implicitly {@link world.BuildingComponent.verify|verify} messages.
         * @function encode
         * @memberof world.BuildingComponent
         * @static
         * @param {world.IBuildingComponent} message BuildingComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bid);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.hp);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxHp);
            if (message.autoHpMs != null && Object.hasOwnProperty.call(message, "autoHpMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.autoHpMs);
            if (message.autoHp != null && Object.hasOwnProperty.call(message, "autoHp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.autoHp);
            if (message.autoHpInr != null && Object.hasOwnProperty.call(message, "autoHpInr"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.autoHpInr);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified BuildingComponent message, length delimited. Does not implicitly {@link world.BuildingComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.BuildingComponent
         * @static
         * @param {world.IBuildingComponent} message BuildingComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuildingComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuildingComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.BuildingComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.BuildingComponent} BuildingComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.BuildingComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.hp = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxHp = reader.uint32();
                        break;
                    }
                case 4: {
                        message.autoHpMs = reader.uint32();
                        break;
                    }
                case 5: {
                        message.autoHp = reader.int32();
                        break;
                    }
                case 6: {
                        message.autoHpInr = reader.uint32();
                        break;
                    }
                case 9: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuildingComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.BuildingComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.BuildingComponent} BuildingComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuildingComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuildingComponent message.
         * @function verify
         * @memberof world.BuildingComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuildingComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bid != null && message.hasOwnProperty("bid"))
                if (!$util.isInteger(message.bid))
                    return "bid: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                if (!$util.isInteger(message.maxHp))
                    return "maxHp: integer expected";
            if (message.autoHpMs != null && message.hasOwnProperty("autoHpMs"))
                if (!$util.isInteger(message.autoHpMs))
                    return "autoHpMs: integer expected";
            if (message.autoHp != null && message.hasOwnProperty("autoHp"))
                if (!$util.isInteger(message.autoHp))
                    return "autoHp: integer expected";
            if (message.autoHpInr != null && message.hasOwnProperty("autoHpInr"))
                if (!$util.isInteger(message.autoHpInr))
                    return "autoHpInr: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a BuildingComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.BuildingComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.BuildingComponent} BuildingComponent
         */
        BuildingComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.BuildingComponent)
                return object;
            var message = new $root.world.BuildingComponent();
            if (object.bid != null)
                message.bid = object.bid >>> 0;
            if (object.hp != null)
                message.hp = object.hp >>> 0;
            if (object.maxHp != null)
                message.maxHp = object.maxHp >>> 0;
            if (object.autoHpMs != null)
                message.autoHpMs = object.autoHpMs >>> 0;
            if (object.autoHp != null)
                message.autoHp = object.autoHp | 0;
            if (object.autoHpInr != null)
                message.autoHpInr = object.autoHpInr >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a BuildingComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.BuildingComponent
         * @static
         * @param {world.BuildingComponent} message BuildingComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuildingComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bid = 0;
                object.hp = 0;
                object.maxHp = 0;
                object.autoHpMs = 0;
                object.autoHp = 0;
                object.autoHpInr = 0;
                object.name = "";
            }
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = message.bid;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.maxHp != null && message.hasOwnProperty("maxHp"))
                object.maxHp = message.maxHp;
            if (message.autoHpMs != null && message.hasOwnProperty("autoHpMs"))
                object.autoHpMs = message.autoHpMs;
            if (message.autoHp != null && message.hasOwnProperty("autoHp"))
                object.autoHp = message.autoHp;
            if (message.autoHpInr != null && message.hasOwnProperty("autoHpInr"))
                object.autoHpInr = message.autoHpInr;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this BuildingComponent to JSON.
         * @function toJSON
         * @memberof world.BuildingComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuildingComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BuildingComponent
         * @function getTypeUrl
         * @memberof world.BuildingComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BuildingComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.BuildingComponent";
        };

        return BuildingComponent;
    })();

    world.BattleComponent = (function() {

        /**
         * Properties of a BattleComponent.
         * @memberof world
         * @interface IBattleComponent
         * @property {number|null} [battleUid] BattleComponent battleUid
         * @property {Array.<number>|null} [fighterEids] BattleComponent fighterEids
         * @property {number|null} [startTs] BattleComponent startTs
         */

        /**
         * Constructs a new BattleComponent.
         * @memberof world
         * @classdesc Represents a BattleComponent.
         * @implements IBattleComponent
         * @constructor
         * @param {world.IBattleComponent=} [properties] Properties to set
         */
        function BattleComponent(properties) {
            this.fighterEids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleComponent battleUid.
         * @member {number} battleUid
         * @memberof world.BattleComponent
         * @instance
         */
        BattleComponent.prototype.battleUid = 0;

        /**
         * BattleComponent fighterEids.
         * @member {Array.<number>} fighterEids
         * @memberof world.BattleComponent
         * @instance
         */
        BattleComponent.prototype.fighterEids = $util.emptyArray;

        /**
         * BattleComponent startTs.
         * @member {number} startTs
         * @memberof world.BattleComponent
         * @instance
         */
        BattleComponent.prototype.startTs = 0;

        /**
         * Creates a new BattleComponent instance using the specified properties.
         * @function create
         * @memberof world.BattleComponent
         * @static
         * @param {world.IBattleComponent=} [properties] Properties to set
         * @returns {world.BattleComponent} BattleComponent instance
         */
        BattleComponent.create = function create(properties) {
            return new BattleComponent(properties);
        };

        /**
         * Encodes the specified BattleComponent message. Does not implicitly {@link world.BattleComponent.verify|verify} messages.
         * @function encode
         * @memberof world.BattleComponent
         * @static
         * @param {world.IBattleComponent} message BattleComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.fighterEids != null && message.fighterEids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.fighterEids.length; ++i)
                    writer.uint32(message.fighterEids[i]);
                writer.ldelim();
            }
            if (message.startTs != null && Object.hasOwnProperty.call(message, "startTs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.startTs);
            return writer;
        };

        /**
         * Encodes the specified BattleComponent message, length delimited. Does not implicitly {@link world.BattleComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.BattleComponent
         * @static
         * @param {world.IBattleComponent} message BattleComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.BattleComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.BattleComponent} BattleComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.BattleComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.fighterEids && message.fighterEids.length))
                            message.fighterEids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.fighterEids.push(reader.uint32());
                        } else
                            message.fighterEids.push(reader.uint32());
                        break;
                    }
                case 3: {
                        message.startTs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.BattleComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.BattleComponent} BattleComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleComponent message.
         * @function verify
         * @memberof world.BattleComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.fighterEids != null && message.hasOwnProperty("fighterEids")) {
                if (!Array.isArray(message.fighterEids))
                    return "fighterEids: array expected";
                for (var i = 0; i < message.fighterEids.length; ++i)
                    if (!$util.isInteger(message.fighterEids[i]))
                        return "fighterEids: integer[] expected";
            }
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                if (!$util.isInteger(message.startTs))
                    return "startTs: integer expected";
            return null;
        };

        /**
         * Creates a BattleComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.BattleComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.BattleComponent} BattleComponent
         */
        BattleComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.BattleComponent)
                return object;
            var message = new $root.world.BattleComponent();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.fighterEids) {
                if (!Array.isArray(object.fighterEids))
                    throw TypeError(".world.BattleComponent.fighterEids: array expected");
                message.fighterEids = [];
                for (var i = 0; i < object.fighterEids.length; ++i)
                    message.fighterEids[i] = object.fighterEids[i] >>> 0;
            }
            if (object.startTs != null)
                message.startTs = object.startTs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BattleComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.BattleComponent
         * @static
         * @param {world.BattleComponent} message BattleComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BattleComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fighterEids = [];
            if (options.defaults) {
                object.battleUid = 0;
                object.startTs = 0;
            }
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.fighterEids && message.fighterEids.length) {
                object.fighterEids = [];
                for (var j = 0; j < message.fighterEids.length; ++j)
                    object.fighterEids[j] = message.fighterEids[j];
            }
            if (message.startTs != null && message.hasOwnProperty("startTs"))
                object.startTs = message.startTs;
            return object;
        };

        /**
         * Converts this BattleComponent to JSON.
         * @function toJSON
         * @memberof world.BattleComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BattleComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BattleComponent
         * @function getTypeUrl
         * @memberof world.BattleComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BattleComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.BattleComponent";
        };

        return BattleComponent;
    })();

    world.BagItem = (function() {

        /**
         * Properties of a BagItem.
         * @memberof world
         * @interface IBagItem
         * @property {number|null} [id] BagItem id
         * @property {number|null} [num] BagItem num
         */

        /**
         * Constructs a new BagItem.
         * @memberof world
         * @classdesc Represents a BagItem.
         * @implements IBagItem
         * @constructor
         * @param {world.IBagItem=} [properties] Properties to set
         */
        function BagItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BagItem id.
         * @member {number} id
         * @memberof world.BagItem
         * @instance
         */
        BagItem.prototype.id = 0;

        /**
         * BagItem num.
         * @member {number} num
         * @memberof world.BagItem
         * @instance
         */
        BagItem.prototype.num = 0;

        /**
         * Creates a new BagItem instance using the specified properties.
         * @function create
         * @memberof world.BagItem
         * @static
         * @param {world.IBagItem=} [properties] Properties to set
         * @returns {world.BagItem} BagItem instance
         */
        BagItem.create = function create(properties) {
            return new BagItem(properties);
        };

        /**
         * Encodes the specified BagItem message. Does not implicitly {@link world.BagItem.verify|verify} messages.
         * @function encode
         * @memberof world.BagItem
         * @static
         * @param {world.IBagItem} message BagItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BagItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified BagItem message, length delimited. Does not implicitly {@link world.BagItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.BagItem
         * @static
         * @param {world.IBagItem} message BagItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BagItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BagItem message from the specified reader or buffer.
         * @function decode
         * @memberof world.BagItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.BagItem} BagItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BagItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.BagItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BagItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.BagItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.BagItem} BagItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BagItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BagItem message.
         * @function verify
         * @memberof world.BagItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BagItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates a BagItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.BagItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.BagItem} BagItem
         */
        BagItem.fromObject = function fromObject(object) {
            if (object instanceof $root.world.BagItem)
                return object;
            var message = new $root.world.BagItem();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BagItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.BagItem
         * @static
         * @param {world.BagItem} message BagItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BagItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this BagItem to JSON.
         * @function toJSON
         * @memberof world.BagItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BagItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BagItem
         * @function getTypeUrl
         * @memberof world.BagItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BagItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.BagItem";
        };

        return BagItem;
    })();

    world.BagComponent = (function() {

        /**
         * Properties of a BagComponent.
         * @memberof world
         * @interface IBagComponent
         * @property {Array.<world.IBagItem>|null} [items] BagComponent items
         * @property {number|null} [touchEid] BagComponent touchEid
         */

        /**
         * Constructs a new BagComponent.
         * @memberof world
         * @classdesc Represents a BagComponent.
         * @implements IBagComponent
         * @constructor
         * @param {world.IBagComponent=} [properties] Properties to set
         */
        function BagComponent(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BagComponent items.
         * @member {Array.<world.IBagItem>} items
         * @memberof world.BagComponent
         * @instance
         */
        BagComponent.prototype.items = $util.emptyArray;

        /**
         * BagComponent touchEid.
         * @member {number} touchEid
         * @memberof world.BagComponent
         * @instance
         */
        BagComponent.prototype.touchEid = 0;

        /**
         * Creates a new BagComponent instance using the specified properties.
         * @function create
         * @memberof world.BagComponent
         * @static
         * @param {world.IBagComponent=} [properties] Properties to set
         * @returns {world.BagComponent} BagComponent instance
         */
        BagComponent.create = function create(properties) {
            return new BagComponent(properties);
        };

        /**
         * Encodes the specified BagComponent message. Does not implicitly {@link world.BagComponent.verify|verify} messages.
         * @function encode
         * @memberof world.BagComponent
         * @static
         * @param {world.IBagComponent} message BagComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BagComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.world.BagItem.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.touchEid != null && Object.hasOwnProperty.call(message, "touchEid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.touchEid);
            return writer;
        };

        /**
         * Encodes the specified BagComponent message, length delimited. Does not implicitly {@link world.BagComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.BagComponent
         * @static
         * @param {world.IBagComponent} message BagComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BagComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BagComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.BagComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.BagComponent} BagComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BagComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.BagComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.world.BagItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.touchEid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BagComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.BagComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.BagComponent} BagComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BagComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BagComponent message.
         * @function verify
         * @memberof world.BagComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BagComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.world.BagItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.touchEid != null && message.hasOwnProperty("touchEid"))
                if (!$util.isInteger(message.touchEid))
                    return "touchEid: integer expected";
            return null;
        };

        /**
         * Creates a BagComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.BagComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.BagComponent} BagComponent
         */
        BagComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.BagComponent)
                return object;
            var message = new $root.world.BagComponent();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".world.BagComponent.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".world.BagComponent.items: object expected");
                    message.items[i] = $root.world.BagItem.fromObject(object.items[i]);
                }
            }
            if (object.touchEid != null)
                message.touchEid = object.touchEid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BagComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.BagComponent
         * @static
         * @param {world.BagComponent} message BagComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BagComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.items = [];
            if (options.defaults)
                object.touchEid = 0;
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.world.BagItem.toObject(message.items[j], options);
            }
            if (message.touchEid != null && message.hasOwnProperty("touchEid"))
                object.touchEid = message.touchEid;
            return object;
        };

        /**
         * Converts this BagComponent to JSON.
         * @function toJSON
         * @memberof world.BagComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BagComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BagComponent
         * @function getTypeUrl
         * @memberof world.BagComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BagComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.BagComponent";
        };

        return BagComponent;
    })();

    world.ItemComponent = (function() {

        /**
         * Properties of an ItemComponent.
         * @memberof world
         * @interface IItemComponent
         * @property {number|null} [id] ItemComponent id
         * @property {number|null} [num] ItemComponent num
         */

        /**
         * Constructs a new ItemComponent.
         * @memberof world
         * @classdesc Represents an ItemComponent.
         * @implements IItemComponent
         * @constructor
         * @param {world.IItemComponent=} [properties] Properties to set
         */
        function ItemComponent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemComponent id.
         * @member {number} id
         * @memberof world.ItemComponent
         * @instance
         */
        ItemComponent.prototype.id = 0;

        /**
         * ItemComponent num.
         * @member {number} num
         * @memberof world.ItemComponent
         * @instance
         */
        ItemComponent.prototype.num = 0;

        /**
         * Creates a new ItemComponent instance using the specified properties.
         * @function create
         * @memberof world.ItemComponent
         * @static
         * @param {world.IItemComponent=} [properties] Properties to set
         * @returns {world.ItemComponent} ItemComponent instance
         */
        ItemComponent.create = function create(properties) {
            return new ItemComponent(properties);
        };

        /**
         * Encodes the specified ItemComponent message. Does not implicitly {@link world.ItemComponent.verify|verify} messages.
         * @function encode
         * @memberof world.ItemComponent
         * @static
         * @param {world.IItemComponent} message ItemComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            return writer;
        };

        /**
         * Encodes the specified ItemComponent message, length delimited. Does not implicitly {@link world.ItemComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.ItemComponent
         * @static
         * @param {world.IItemComponent} message ItemComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemComponent message from the specified reader or buffer.
         * @function decode
         * @memberof world.ItemComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.ItemComponent} ItemComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.ItemComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.ItemComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.ItemComponent} ItemComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemComponent message.
         * @function verify
         * @memberof world.ItemComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };

        /**
         * Creates an ItemComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.ItemComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.ItemComponent} ItemComponent
         */
        ItemComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.world.ItemComponent)
                return object;
            var message = new $root.world.ItemComponent();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an ItemComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.ItemComponent
         * @static
         * @param {world.ItemComponent} message ItemComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ItemComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };

        /**
         * Converts this ItemComponent to JSON.
         * @function toJSON
         * @memberof world.ItemComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ItemComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ItemComponent
         * @function getTypeUrl
         * @memberof world.ItemComponent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ItemComponent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.ItemComponent";
        };

        return ItemComponent;
    })();

    world.Entity = (function() {

        /**
         * Properties of an Entity.
         * @memberof world
         * @interface IEntity
         * @property {number|null} [eid] Entity eid
         * @property {number|null} [etype] Entity etype
         * @property {world.IPosition|null} [pos] Entity pos
         * @property {world.ITimerComponent|null} [timer] Entity timer
         * @property {world.IMoveComponent|null} [move] Entity move
         * @property {world.IBuildingComponent|null} [building] Entity building
         * @property {world.IOwnerComponent|null} [owner] Entity owner
         * @property {world.ITroopComponent|null} [troop] Entity troop
         * @property {world.IBattleComponent|null} [battle] Entity battle
         * @property {world.IBagComponent|null} [bag] Entity bag
         * @property {world.IItemComponent|null} [item] Entity item
         */

        /**
         * Constructs a new Entity.
         * @memberof world
         * @classdesc Represents an Entity.
         * @implements IEntity
         * @constructor
         * @param {world.IEntity=} [properties] Properties to set
         */
        function Entity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Entity eid.
         * @member {number} eid
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.eid = 0;

        /**
         * Entity etype.
         * @member {number} etype
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.etype = 0;

        /**
         * Entity pos.
         * @member {world.IPosition|null|undefined} pos
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.pos = null;

        /**
         * Entity timer.
         * @member {world.ITimerComponent|null|undefined} timer
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.timer = null;

        /**
         * Entity move.
         * @member {world.IMoveComponent|null|undefined} move
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.move = null;

        /**
         * Entity building.
         * @member {world.IBuildingComponent|null|undefined} building
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.building = null;

        /**
         * Entity owner.
         * @member {world.IOwnerComponent|null|undefined} owner
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.owner = null;

        /**
         * Entity troop.
         * @member {world.ITroopComponent|null|undefined} troop
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.troop = null;

        /**
         * Entity battle.
         * @member {world.IBattleComponent|null|undefined} battle
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.battle = null;

        /**
         * Entity bag.
         * @member {world.IBagComponent|null|undefined} bag
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.bag = null;

        /**
         * Entity item.
         * @member {world.IItemComponent|null|undefined} item
         * @memberof world.Entity
         * @instance
         */
        Entity.prototype.item = null;

        /**
         * Creates a new Entity instance using the specified properties.
         * @function create
         * @memberof world.Entity
         * @static
         * @param {world.IEntity=} [properties] Properties to set
         * @returns {world.Entity} Entity instance
         */
        Entity.create = function create(properties) {
            return new Entity(properties);
        };

        /**
         * Encodes the specified Entity message. Does not implicitly {@link world.Entity.verify|verify} messages.
         * @function encode
         * @memberof world.Entity
         * @static
         * @param {world.IEntity} message Entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Entity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.etype != null && Object.hasOwnProperty.call(message, "etype"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.etype);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.world.Position.encode(message.pos, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timer != null && Object.hasOwnProperty.call(message, "timer"))
                $root.world.TimerComponent.encode(message.timer, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.move != null && Object.hasOwnProperty.call(message, "move"))
                $root.world.MoveComponent.encode(message.move, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.building != null && Object.hasOwnProperty.call(message, "building"))
                $root.world.BuildingComponent.encode(message.building, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                $root.world.OwnerComponent.encode(message.owner, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.troop != null && Object.hasOwnProperty.call(message, "troop"))
                $root.world.TroopComponent.encode(message.troop, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.battle != null && Object.hasOwnProperty.call(message, "battle"))
                $root.world.BattleComponent.encode(message.battle, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.bag != null && Object.hasOwnProperty.call(message, "bag"))
                $root.world.BagComponent.encode(message.bag, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.world.ItemComponent.encode(message.item, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Entity message, length delimited. Does not implicitly {@link world.Entity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.Entity
         * @static
         * @param {world.IEntity} message Entity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Entity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Entity message from the specified reader or buffer.
         * @function decode
         * @memberof world.Entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.Entity} Entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.Entity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.etype = reader.uint32();
                        break;
                    }
                case 3: {
                        message.pos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.timer = $root.world.TimerComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.move = $root.world.MoveComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.building = $root.world.BuildingComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.owner = $root.world.OwnerComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.troop = $root.world.TroopComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.battle = $root.world.BattleComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.bag = $root.world.BagComponent.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.item = $root.world.ItemComponent.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Entity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.Entity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.Entity} Entity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Entity message.
         * @function verify
         * @memberof world.Entity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Entity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.etype != null && message.hasOwnProperty("etype"))
                if (!$util.isInteger(message.etype))
                    return "etype: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.world.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.timer != null && message.hasOwnProperty("timer")) {
                var error = $root.world.TimerComponent.verify(message.timer);
                if (error)
                    return "timer." + error;
            }
            if (message.move != null && message.hasOwnProperty("move")) {
                var error = $root.world.MoveComponent.verify(message.move);
                if (error)
                    return "move." + error;
            }
            if (message.building != null && message.hasOwnProperty("building")) {
                var error = $root.world.BuildingComponent.verify(message.building);
                if (error)
                    return "building." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.world.OwnerComponent.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.troop != null && message.hasOwnProperty("troop")) {
                var error = $root.world.TroopComponent.verify(message.troop);
                if (error)
                    return "troop." + error;
            }
            if (message.battle != null && message.hasOwnProperty("battle")) {
                var error = $root.world.BattleComponent.verify(message.battle);
                if (error)
                    return "battle." + error;
            }
            if (message.bag != null && message.hasOwnProperty("bag")) {
                var error = $root.world.BagComponent.verify(message.bag);
                if (error)
                    return "bag." + error;
            }
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.world.ItemComponent.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an Entity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.Entity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.Entity} Entity
         */
        Entity.fromObject = function fromObject(object) {
            if (object instanceof $root.world.Entity)
                return object;
            var message = new $root.world.Entity();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.etype != null)
                message.etype = object.etype >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".world.Entity.pos: object expected");
                message.pos = $root.world.Position.fromObject(object.pos);
            }
            if (object.timer != null) {
                if (typeof object.timer !== "object")
                    throw TypeError(".world.Entity.timer: object expected");
                message.timer = $root.world.TimerComponent.fromObject(object.timer);
            }
            if (object.move != null) {
                if (typeof object.move !== "object")
                    throw TypeError(".world.Entity.move: object expected");
                message.move = $root.world.MoveComponent.fromObject(object.move);
            }
            if (object.building != null) {
                if (typeof object.building !== "object")
                    throw TypeError(".world.Entity.building: object expected");
                message.building = $root.world.BuildingComponent.fromObject(object.building);
            }
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".world.Entity.owner: object expected");
                message.owner = $root.world.OwnerComponent.fromObject(object.owner);
            }
            if (object.troop != null) {
                if (typeof object.troop !== "object")
                    throw TypeError(".world.Entity.troop: object expected");
                message.troop = $root.world.TroopComponent.fromObject(object.troop);
            }
            if (object.battle != null) {
                if (typeof object.battle !== "object")
                    throw TypeError(".world.Entity.battle: object expected");
                message.battle = $root.world.BattleComponent.fromObject(object.battle);
            }
            if (object.bag != null) {
                if (typeof object.bag !== "object")
                    throw TypeError(".world.Entity.bag: object expected");
                message.bag = $root.world.BagComponent.fromObject(object.bag);
            }
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".world.Entity.item: object expected");
                message.item = $root.world.ItemComponent.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an Entity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.Entity
         * @static
         * @param {world.Entity} message Entity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Entity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eid = 0;
                object.etype = 0;
                object.pos = null;
                object.timer = null;
                object.move = null;
                object.building = null;
                object.owner = null;
                object.troop = null;
                object.battle = null;
                object.bag = null;
                object.item = null;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.etype != null && message.hasOwnProperty("etype"))
                object.etype = message.etype;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.world.Position.toObject(message.pos, options);
            if (message.timer != null && message.hasOwnProperty("timer"))
                object.timer = $root.world.TimerComponent.toObject(message.timer, options);
            if (message.move != null && message.hasOwnProperty("move"))
                object.move = $root.world.MoveComponent.toObject(message.move, options);
            if (message.building != null && message.hasOwnProperty("building"))
                object.building = $root.world.BuildingComponent.toObject(message.building, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.world.OwnerComponent.toObject(message.owner, options);
            if (message.troop != null && message.hasOwnProperty("troop"))
                object.troop = $root.world.TroopComponent.toObject(message.troop, options);
            if (message.battle != null && message.hasOwnProperty("battle"))
                object.battle = $root.world.BattleComponent.toObject(message.battle, options);
            if (message.bag != null && message.hasOwnProperty("bag"))
                object.bag = $root.world.BagComponent.toObject(message.bag, options);
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.world.ItemComponent.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this Entity to JSON.
         * @function toJSON
         * @memberof world.Entity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Entity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Entity
         * @function getTypeUrl
         * @memberof world.Entity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Entity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.Entity";
        };

        return Entity;
    })();

    world.c2s_load = (function() {

        /**
         * Properties of a c2s_load.
         * @memberof world
         * @interface Ic2s_load
         * @property {number|null} [worldUid] c2s_load worldUid
         */

        /**
         * Constructs a new c2s_load.
         * @memberof world
         * @classdesc Represents a c2s_load.
         * @implements Ic2s_load
         * @constructor
         * @param {world.Ic2s_load=} [properties] Properties to set
         */
        function c2s_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load worldUid.
         * @member {number} worldUid
         * @memberof world.c2s_load
         * @instance
         */
        c2s_load.prototype.worldUid = 0;

        /**
         * Creates a new c2s_load instance using the specified properties.
         * @function create
         * @memberof world.c2s_load
         * @static
         * @param {world.Ic2s_load=} [properties] Properties to set
         * @returns {world.c2s_load} c2s_load instance
         */
        c2s_load.create = function create(properties) {
            return new c2s_load(properties);
        };

        /**
         * Encodes the specified c2s_load message. Does not implicitly {@link world.c2s_load.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_load
         * @static
         * @param {world.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldUid != null && Object.hasOwnProperty.call(message, "worldUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.worldUid);
            return writer;
        };

        /**
         * Encodes the specified c2s_load message, length delimited. Does not implicitly {@link world.c2s_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_load
         * @static
         * @param {world.Ic2s_load} message c2s_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.worldUid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_load} c2s_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load message.
         * @function verify
         * @memberof world.c2s_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldUid != null && message.hasOwnProperty("worldUid"))
                if (!$util.isInteger(message.worldUid))
                    return "worldUid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_load} c2s_load
         */
        c2s_load.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_load)
                return object;
            var message = new $root.world.c2s_load();
            if (object.worldUid != null)
                message.worldUid = object.worldUid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_load
         * @static
         * @param {world.c2s_load} message c2s_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.worldUid = 0;
            if (message.worldUid != null && message.hasOwnProperty("worldUid"))
                object.worldUid = message.worldUid;
            return object;
        };

        /**
         * Converts this c2s_load to JSON.
         * @function toJSON
         * @memberof world.c2s_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load
         * @function getTypeUrl
         * @memberof world.c2s_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_load";
        };

        return c2s_load;
    })();

    world.s2c_load = (function() {

        /**
         * Properties of a s2c_load.
         * @memberof world
         * @interface Is2c_load
         * @property {number|null} [err] s2c_load err
         * @property {number|null} [mapId] s2c_load mapId
         * @property {number|null} [homeEid] s2c_load homeEid
         * @property {world.IPosition|null} [homePos] s2c_load homePos
         */

        /**
         * Constructs a new s2c_load.
         * @memberof world
         * @classdesc Represents a s2c_load.
         * @implements Is2c_load
         * @constructor
         * @param {world.Is2c_load=} [properties] Properties to set
         */
        function s2c_load(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load err.
         * @member {number} err
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.err = 0;

        /**
         * s2c_load mapId.
         * @member {number} mapId
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.mapId = 0;

        /**
         * s2c_load homeEid.
         * @member {number} homeEid
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.homeEid = 0;

        /**
         * s2c_load homePos.
         * @member {world.IPosition|null|undefined} homePos
         * @memberof world.s2c_load
         * @instance
         */
        s2c_load.prototype.homePos = null;

        /**
         * Creates a new s2c_load instance using the specified properties.
         * @function create
         * @memberof world.s2c_load
         * @static
         * @param {world.Is2c_load=} [properties] Properties to set
         * @returns {world.s2c_load} s2c_load instance
         */
        s2c_load.create = function create(properties) {
            return new s2c_load(properties);
        };

        /**
         * Encodes the specified s2c_load message. Does not implicitly {@link world.s2c_load.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_load
         * @static
         * @param {world.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.mapId != null && Object.hasOwnProperty.call(message, "mapId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.mapId);
            if (message.homeEid != null && Object.hasOwnProperty.call(message, "homeEid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.homeEid);
            if (message.homePos != null && Object.hasOwnProperty.call(message, "homePos"))
                $root.world.Position.encode(message.homePos, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified s2c_load message, length delimited. Does not implicitly {@link world.s2c_load.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_load
         * @static
         * @param {world.Is2c_load} message s2c_load message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_load();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.mapId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.homeEid = reader.uint32();
                        break;
                    }
                case 4: {
                        message.homePos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_load
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_load} s2c_load
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load message.
         * @function verify
         * @memberof world.s2c_load
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.mapId != null && message.hasOwnProperty("mapId"))
                if (!$util.isInteger(message.mapId))
                    return "mapId: integer expected";
            if (message.homeEid != null && message.hasOwnProperty("homeEid"))
                if (!$util.isInteger(message.homeEid))
                    return "homeEid: integer expected";
            if (message.homePos != null && message.hasOwnProperty("homePos")) {
                var error = $root.world.Position.verify(message.homePos);
                if (error)
                    return "homePos." + error;
            }
            return null;
        };

        /**
         * Creates a s2c_load message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_load
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_load} s2c_load
         */
        s2c_load.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_load)
                return object;
            var message = new $root.world.s2c_load();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.mapId != null)
                message.mapId = object.mapId >>> 0;
            if (object.homeEid != null)
                message.homeEid = object.homeEid >>> 0;
            if (object.homePos != null) {
                if (typeof object.homePos !== "object")
                    throw TypeError(".world.s2c_load.homePos: object expected");
                message.homePos = $root.world.Position.fromObject(object.homePos);
            }
            return message;
        };

        /**
         * Creates a plain object from a s2c_load message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_load
         * @static
         * @param {world.s2c_load} message s2c_load
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.mapId = 0;
                object.homeEid = 0;
                object.homePos = null;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.mapId != null && message.hasOwnProperty("mapId"))
                object.mapId = message.mapId;
            if (message.homeEid != null && message.hasOwnProperty("homeEid"))
                object.homeEid = message.homeEid;
            if (message.homePos != null && message.hasOwnProperty("homePos"))
                object.homePos = $root.world.Position.toObject(message.homePos, options);
            return object;
        };

        /**
         * Converts this s2c_load to JSON.
         * @function toJSON
         * @memberof world.s2c_load
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load
         * @function getTypeUrl
         * @memberof world.s2c_load
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_load";
        };

        return s2c_load;
    })();

    world.c2s_change_viewport = (function() {

        /**
         * Properties of a c2s_change_viewport.
         * @memberof world
         * @interface Ic2s_change_viewport
         * @property {number|null} [worldUid] c2s_change_viewport worldUid
         * @property {world.IPosition|null} [pos] c2s_change_viewport pos
         */

        /**
         * Constructs a new c2s_change_viewport.
         * @memberof world
         * @classdesc Represents a c2s_change_viewport.
         * @implements Ic2s_change_viewport
         * @constructor
         * @param {world.Ic2s_change_viewport=} [properties] Properties to set
         */
        function c2s_change_viewport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_change_viewport worldUid.
         * @member {number} worldUid
         * @memberof world.c2s_change_viewport
         * @instance
         */
        c2s_change_viewport.prototype.worldUid = 0;

        /**
         * c2s_change_viewport pos.
         * @member {world.IPosition|null|undefined} pos
         * @memberof world.c2s_change_viewport
         * @instance
         */
        c2s_change_viewport.prototype.pos = null;

        /**
         * Creates a new c2s_change_viewport instance using the specified properties.
         * @function create
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.Ic2s_change_viewport=} [properties] Properties to set
         * @returns {world.c2s_change_viewport} c2s_change_viewport instance
         */
        c2s_change_viewport.create = function create(properties) {
            return new c2s_change_viewport(properties);
        };

        /**
         * Encodes the specified c2s_change_viewport message. Does not implicitly {@link world.c2s_change_viewport.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.Ic2s_change_viewport} message c2s_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_change_viewport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.worldUid != null && Object.hasOwnProperty.call(message, "worldUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.worldUid);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.world.Position.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified c2s_change_viewport message, length delimited. Does not implicitly {@link world.c2s_change_viewport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.Ic2s_change_viewport} message c2s_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_change_viewport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_change_viewport message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_change_viewport} c2s_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_change_viewport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_change_viewport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.worldUid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.pos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_change_viewport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_change_viewport} c2s_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_change_viewport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_change_viewport message.
         * @function verify
         * @memberof world.c2s_change_viewport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_change_viewport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.worldUid != null && message.hasOwnProperty("worldUid"))
                if (!$util.isInteger(message.worldUid))
                    return "worldUid: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.world.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a c2s_change_viewport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_change_viewport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_change_viewport} c2s_change_viewport
         */
        c2s_change_viewport.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_change_viewport)
                return object;
            var message = new $root.world.c2s_change_viewport();
            if (object.worldUid != null)
                message.worldUid = object.worldUid >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".world.c2s_change_viewport.pos: object expected");
                message.pos = $root.world.Position.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_change_viewport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_change_viewport
         * @static
         * @param {world.c2s_change_viewport} message c2s_change_viewport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_change_viewport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.worldUid = 0;
                object.pos = null;
            }
            if (message.worldUid != null && message.hasOwnProperty("worldUid"))
                object.worldUid = message.worldUid;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.world.Position.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this c2s_change_viewport to JSON.
         * @function toJSON
         * @memberof world.c2s_change_viewport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_change_viewport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_change_viewport
         * @function getTypeUrl
         * @memberof world.c2s_change_viewport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_change_viewport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_change_viewport";
        };

        return c2s_change_viewport;
    })();

    world.s2c_change_viewport = (function() {

        /**
         * Properties of a s2c_change_viewport.
         * @memberof world
         * @interface Is2c_change_viewport
         * @property {number|null} [err] s2c_change_viewport err
         */

        /**
         * Constructs a new s2c_change_viewport.
         * @memberof world
         * @classdesc Represents a s2c_change_viewport.
         * @implements Is2c_change_viewport
         * @constructor
         * @param {world.Is2c_change_viewport=} [properties] Properties to set
         */
        function s2c_change_viewport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_change_viewport err.
         * @member {number} err
         * @memberof world.s2c_change_viewport
         * @instance
         */
        s2c_change_viewport.prototype.err = 0;

        /**
         * Creates a new s2c_change_viewport instance using the specified properties.
         * @function create
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.Is2c_change_viewport=} [properties] Properties to set
         * @returns {world.s2c_change_viewport} s2c_change_viewport instance
         */
        s2c_change_viewport.create = function create(properties) {
            return new s2c_change_viewport(properties);
        };

        /**
         * Encodes the specified s2c_change_viewport message. Does not implicitly {@link world.s2c_change_viewport.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.Is2c_change_viewport} message s2c_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_change_viewport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_change_viewport message, length delimited. Does not implicitly {@link world.s2c_change_viewport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.Is2c_change_viewport} message s2c_change_viewport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_change_viewport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_change_viewport message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_change_viewport} s2c_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_change_viewport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_change_viewport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_change_viewport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_change_viewport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_change_viewport} s2c_change_viewport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_change_viewport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_change_viewport message.
         * @function verify
         * @memberof world.s2c_change_viewport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_change_viewport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_change_viewport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_change_viewport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_change_viewport} s2c_change_viewport
         */
        s2c_change_viewport.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_change_viewport)
                return object;
            var message = new $root.world.s2c_change_viewport();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_change_viewport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_change_viewport
         * @static
         * @param {world.s2c_change_viewport} message s2c_change_viewport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_change_viewport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_change_viewport to JSON.
         * @function toJSON
         * @memberof world.s2c_change_viewport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_change_viewport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_change_viewport
         * @function getTypeUrl
         * @memberof world.s2c_change_viewport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_change_viewport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_change_viewport";
        };

        return s2c_change_viewport;
    })();

    world.c2s_giveup = (function() {

        /**
         * Properties of a c2s_giveup.
         * @memberof world
         * @interface Ic2s_giveup
         * @property {number|null} [eid] c2s_giveup eid
         */

        /**
         * Constructs a new c2s_giveup.
         * @memberof world
         * @classdesc Represents a c2s_giveup.
         * @implements Ic2s_giveup
         * @constructor
         * @param {world.Ic2s_giveup=} [properties] Properties to set
         */
        function c2s_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_giveup eid.
         * @member {number} eid
         * @memberof world.c2s_giveup
         * @instance
         */
        c2s_giveup.prototype.eid = 0;

        /**
         * Creates a new c2s_giveup instance using the specified properties.
         * @function create
         * @memberof world.c2s_giveup
         * @static
         * @param {world.Ic2s_giveup=} [properties] Properties to set
         * @returns {world.c2s_giveup} c2s_giveup instance
         */
        c2s_giveup.create = function create(properties) {
            return new c2s_giveup(properties);
        };

        /**
         * Encodes the specified c2s_giveup message. Does not implicitly {@link world.c2s_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_giveup
         * @static
         * @param {world.Ic2s_giveup} message c2s_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified c2s_giveup message, length delimited. Does not implicitly {@link world.c2s_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_giveup
         * @static
         * @param {world.Ic2s_giveup} message c2s_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_giveup} c2s_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_giveup} c2s_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_giveup message.
         * @function verify
         * @memberof world.c2s_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_giveup} c2s_giveup
         */
        c2s_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_giveup)
                return object;
            var message = new $root.world.c2s_giveup();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_giveup
         * @static
         * @param {world.c2s_giveup} message c2s_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this c2s_giveup to JSON.
         * @function toJSON
         * @memberof world.c2s_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_giveup
         * @function getTypeUrl
         * @memberof world.c2s_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_giveup";
        };

        return c2s_giveup;
    })();

    world.s2c_giveup = (function() {

        /**
         * Properties of a s2c_giveup.
         * @memberof world
         * @interface Is2c_giveup
         * @property {number|null} [err] s2c_giveup err
         */

        /**
         * Constructs a new s2c_giveup.
         * @memberof world
         * @classdesc Represents a s2c_giveup.
         * @implements Is2c_giveup
         * @constructor
         * @param {world.Is2c_giveup=} [properties] Properties to set
         */
        function s2c_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_giveup err.
         * @member {number} err
         * @memberof world.s2c_giveup
         * @instance
         */
        s2c_giveup.prototype.err = 0;

        /**
         * Creates a new s2c_giveup instance using the specified properties.
         * @function create
         * @memberof world.s2c_giveup
         * @static
         * @param {world.Is2c_giveup=} [properties] Properties to set
         * @returns {world.s2c_giveup} s2c_giveup instance
         */
        s2c_giveup.create = function create(properties) {
            return new s2c_giveup(properties);
        };

        /**
         * Encodes the specified s2c_giveup message. Does not implicitly {@link world.s2c_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_giveup
         * @static
         * @param {world.Is2c_giveup} message s2c_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_giveup message, length delimited. Does not implicitly {@link world.s2c_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_giveup
         * @static
         * @param {world.Is2c_giveup} message s2c_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_giveup} s2c_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_giveup} s2c_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_giveup message.
         * @function verify
         * @memberof world.s2c_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_giveup} s2c_giveup
         */
        s2c_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_giveup)
                return object;
            var message = new $root.world.s2c_giveup();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_giveup
         * @static
         * @param {world.s2c_giveup} message s2c_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_giveup to JSON.
         * @function toJSON
         * @memberof world.s2c_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_giveup
         * @function getTypeUrl
         * @memberof world.s2c_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_giveup";
        };

        return s2c_giveup;
    })();

    world.c2s_cancel_giveup = (function() {

        /**
         * Properties of a c2s_cancel_giveup.
         * @memberof world
         * @interface Ic2s_cancel_giveup
         * @property {number|null} [eid] c2s_cancel_giveup eid
         */

        /**
         * Constructs a new c2s_cancel_giveup.
         * @memberof world
         * @classdesc Represents a c2s_cancel_giveup.
         * @implements Ic2s_cancel_giveup
         * @constructor
         * @param {world.Ic2s_cancel_giveup=} [properties] Properties to set
         */
        function c2s_cancel_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_cancel_giveup eid.
         * @member {number} eid
         * @memberof world.c2s_cancel_giveup
         * @instance
         */
        c2s_cancel_giveup.prototype.eid = 0;

        /**
         * Creates a new c2s_cancel_giveup instance using the specified properties.
         * @function create
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.Ic2s_cancel_giveup=} [properties] Properties to set
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup instance
         */
        c2s_cancel_giveup.create = function create(properties) {
            return new c2s_cancel_giveup(properties);
        };

        /**
         * Encodes the specified c2s_cancel_giveup message. Does not implicitly {@link world.c2s_cancel_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.Ic2s_cancel_giveup} message c2s_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_cancel_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified c2s_cancel_giveup message, length delimited. Does not implicitly {@link world.c2s_cancel_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.Ic2s_cancel_giveup} message c2s_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_cancel_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_cancel_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_cancel_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_cancel_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_cancel_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_cancel_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_cancel_giveup message.
         * @function verify
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_cancel_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_cancel_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_cancel_giveup} c2s_cancel_giveup
         */
        c2s_cancel_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_cancel_giveup)
                return object;
            var message = new $root.world.c2s_cancel_giveup();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_cancel_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {world.c2s_cancel_giveup} message c2s_cancel_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_cancel_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this c2s_cancel_giveup to JSON.
         * @function toJSON
         * @memberof world.c2s_cancel_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_cancel_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_cancel_giveup
         * @function getTypeUrl
         * @memberof world.c2s_cancel_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_cancel_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_cancel_giveup";
        };

        return c2s_cancel_giveup;
    })();

    world.s2c_cancel_giveup = (function() {

        /**
         * Properties of a s2c_cancel_giveup.
         * @memberof world
         * @interface Is2c_cancel_giveup
         * @property {number|null} [err] s2c_cancel_giveup err
         */

        /**
         * Constructs a new s2c_cancel_giveup.
         * @memberof world
         * @classdesc Represents a s2c_cancel_giveup.
         * @implements Is2c_cancel_giveup
         * @constructor
         * @param {world.Is2c_cancel_giveup=} [properties] Properties to set
         */
        function s2c_cancel_giveup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_cancel_giveup err.
         * @member {number} err
         * @memberof world.s2c_cancel_giveup
         * @instance
         */
        s2c_cancel_giveup.prototype.err = 0;

        /**
         * Creates a new s2c_cancel_giveup instance using the specified properties.
         * @function create
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.Is2c_cancel_giveup=} [properties] Properties to set
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup instance
         */
        s2c_cancel_giveup.create = function create(properties) {
            return new s2c_cancel_giveup(properties);
        };

        /**
         * Encodes the specified s2c_cancel_giveup message. Does not implicitly {@link world.s2c_cancel_giveup.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.Is2c_cancel_giveup} message s2c_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_cancel_giveup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_cancel_giveup message, length delimited. Does not implicitly {@link world.s2c_cancel_giveup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.Is2c_cancel_giveup} message s2c_cancel_giveup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_cancel_giveup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_cancel_giveup message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_cancel_giveup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_cancel_giveup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_cancel_giveup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_cancel_giveup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_cancel_giveup message.
         * @function verify
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_cancel_giveup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_cancel_giveup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_cancel_giveup} s2c_cancel_giveup
         */
        s2c_cancel_giveup.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_cancel_giveup)
                return object;
            var message = new $root.world.s2c_cancel_giveup();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_cancel_giveup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {world.s2c_cancel_giveup} message s2c_cancel_giveup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_cancel_giveup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_cancel_giveup to JSON.
         * @function toJSON
         * @memberof world.s2c_cancel_giveup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_cancel_giveup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_cancel_giveup
         * @function getTypeUrl
         * @memberof world.s2c_cancel_giveup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_cancel_giveup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_cancel_giveup";
        };

        return s2c_cancel_giveup;
    })();

    world.c2s_load_detect_info = (function() {

        /**
         * Properties of a c2s_load_detect_info.
         * @memberof world
         * @interface Ic2s_load_detect_info
         * @property {world.IPosition|null} [pos] c2s_load_detect_info pos
         */

        /**
         * Constructs a new c2s_load_detect_info.
         * @memberof world
         * @classdesc Represents a c2s_load_detect_info.
         * @implements Ic2s_load_detect_info
         * @constructor
         * @param {world.Ic2s_load_detect_info=} [properties] Properties to set
         */
        function c2s_load_detect_info(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_load_detect_info pos.
         * @member {world.IPosition|null|undefined} pos
         * @memberof world.c2s_load_detect_info
         * @instance
         */
        c2s_load_detect_info.prototype.pos = null;

        /**
         * Creates a new c2s_load_detect_info instance using the specified properties.
         * @function create
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.Ic2s_load_detect_info=} [properties] Properties to set
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info instance
         */
        c2s_load_detect_info.create = function create(properties) {
            return new c2s_load_detect_info(properties);
        };

        /**
         * Encodes the specified c2s_load_detect_info message. Does not implicitly {@link world.c2s_load_detect_info.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.Ic2s_load_detect_info} message c2s_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_detect_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.world.Position.encode(message.pos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified c2s_load_detect_info message, length delimited. Does not implicitly {@link world.c2s_load_detect_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.Ic2s_load_detect_info} message c2s_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_load_detect_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_load_detect_info message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_detect_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_load_detect_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_load_detect_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_load_detect_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_load_detect_info message.
         * @function verify
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_load_detect_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                var error = $root.world.Position.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            return null;
        };

        /**
         * Creates a c2s_load_detect_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_load_detect_info} c2s_load_detect_info
         */
        c2s_load_detect_info.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_load_detect_info)
                return object;
            var message = new $root.world.c2s_load_detect_info();
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".world.c2s_load_detect_info.pos: object expected");
                message.pos = $root.world.Position.fromObject(object.pos);
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_load_detect_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {world.c2s_load_detect_info} message c2s_load_detect_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_load_detect_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.pos = null;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.world.Position.toObject(message.pos, options);
            return object;
        };

        /**
         * Converts this c2s_load_detect_info to JSON.
         * @function toJSON
         * @memberof world.c2s_load_detect_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_load_detect_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_load_detect_info
         * @function getTypeUrl
         * @memberof world.c2s_load_detect_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_load_detect_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_load_detect_info";
        };

        return c2s_load_detect_info;
    })();

    world.s2c_load_detect_info = (function() {

        /**
         * Properties of a s2c_load_detect_info.
         * @memberof world
         * @interface Is2c_load_detect_info
         * @property {number|null} [err] s2c_load_detect_info err
         * @property {number|null} [dungeonId] s2c_load_detect_info dungeonId
         * @property {number|null} [aliveCount] s2c_load_detect_info aliveCount
         */

        /**
         * Constructs a new s2c_load_detect_info.
         * @memberof world
         * @classdesc Represents a s2c_load_detect_info.
         * @implements Is2c_load_detect_info
         * @constructor
         * @param {world.Is2c_load_detect_info=} [properties] Properties to set
         */
        function s2c_load_detect_info(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_load_detect_info err.
         * @member {number} err
         * @memberof world.s2c_load_detect_info
         * @instance
         */
        s2c_load_detect_info.prototype.err = 0;

        /**
         * s2c_load_detect_info dungeonId.
         * @member {number} dungeonId
         * @memberof world.s2c_load_detect_info
         * @instance
         */
        s2c_load_detect_info.prototype.dungeonId = 0;

        /**
         * s2c_load_detect_info aliveCount.
         * @member {number} aliveCount
         * @memberof world.s2c_load_detect_info
         * @instance
         */
        s2c_load_detect_info.prototype.aliveCount = 0;

        /**
         * Creates a new s2c_load_detect_info instance using the specified properties.
         * @function create
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.Is2c_load_detect_info=} [properties] Properties to set
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info instance
         */
        s2c_load_detect_info.create = function create(properties) {
            return new s2c_load_detect_info(properties);
        };

        /**
         * Encodes the specified s2c_load_detect_info message. Does not implicitly {@link world.s2c_load_detect_info.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.Is2c_load_detect_info} message s2c_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_detect_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            if (message.dungeonId != null && Object.hasOwnProperty.call(message, "dungeonId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dungeonId);
            if (message.aliveCount != null && Object.hasOwnProperty.call(message, "aliveCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.aliveCount);
            return writer;
        };

        /**
         * Encodes the specified s2c_load_detect_info message, length delimited. Does not implicitly {@link world.s2c_load_detect_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.Is2c_load_detect_info} message s2c_load_detect_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_load_detect_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_load_detect_info message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_detect_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_load_detect_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                case 2: {
                        message.dungeonId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.aliveCount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_load_detect_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_load_detect_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_load_detect_info message.
         * @function verify
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_load_detect_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                if (!$util.isInteger(message.dungeonId))
                    return "dungeonId: integer expected";
            if (message.aliveCount != null && message.hasOwnProperty("aliveCount"))
                if (!$util.isInteger(message.aliveCount))
                    return "aliveCount: integer expected";
            return null;
        };

        /**
         * Creates a s2c_load_detect_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_load_detect_info} s2c_load_detect_info
         */
        s2c_load_detect_info.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_load_detect_info)
                return object;
            var message = new $root.world.s2c_load_detect_info();
            if (object.err != null)
                message.err = object.err >>> 0;
            if (object.dungeonId != null)
                message.dungeonId = object.dungeonId >>> 0;
            if (object.aliveCount != null)
                message.aliveCount = object.aliveCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_load_detect_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {world.s2c_load_detect_info} message s2c_load_detect_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_load_detect_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.err = 0;
                object.dungeonId = 0;
                object.aliveCount = 0;
            }
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            if (message.dungeonId != null && message.hasOwnProperty("dungeonId"))
                object.dungeonId = message.dungeonId;
            if (message.aliveCount != null && message.hasOwnProperty("aliveCount"))
                object.aliveCount = message.aliveCount;
            return object;
        };

        /**
         * Converts this s2c_load_detect_info to JSON.
         * @function toJSON
         * @memberof world.s2c_load_detect_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_load_detect_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_load_detect_info
         * @function getTypeUrl
         * @memberof world.s2c_load_detect_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_load_detect_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_load_detect_info";
        };

        return s2c_load_detect_info;
    })();

    world.c2s_troop_move_to = (function() {

        /**
         * Properties of a c2s_troop_move_to.
         * @memberof world
         * @interface Ic2s_troop_move_to
         * @property {number|null} [troopEid] c2s_troop_move_to troopEid
         * @property {world.IPosition|null} [dstPos] c2s_troop_move_to dstPos
         */

        /**
         * Constructs a new c2s_troop_move_to.
         * @memberof world
         * @classdesc Represents a c2s_troop_move_to.
         * @implements Ic2s_troop_move_to
         * @constructor
         * @param {world.Ic2s_troop_move_to=} [properties] Properties to set
         */
        function c2s_troop_move_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_move_to troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_move_to
         * @instance
         */
        c2s_troop_move_to.prototype.troopEid = 0;

        /**
         * c2s_troop_move_to dstPos.
         * @member {world.IPosition|null|undefined} dstPos
         * @memberof world.c2s_troop_move_to
         * @instance
         */
        c2s_troop_move_to.prototype.dstPos = null;

        /**
         * Creates a new c2s_troop_move_to instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.Ic2s_troop_move_to=} [properties] Properties to set
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to instance
         */
        c2s_troop_move_to.create = function create(properties) {
            return new c2s_troop_move_to(properties);
        };

        /**
         * Encodes the specified c2s_troop_move_to message. Does not implicitly {@link world.c2s_troop_move_to.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.Ic2s_troop_move_to} message c2s_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            if (message.dstPos != null && Object.hasOwnProperty.call(message, "dstPos"))
                $root.world.Position.encode(message.dstPos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_move_to message, length delimited. Does not implicitly {@link world.c2s_troop_move_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.Ic2s_troop_move_to} message c2s_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_move_to message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_move_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.dstPos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_move_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_move_to message.
         * @function verify
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_move_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            if (message.dstPos != null && message.hasOwnProperty("dstPos")) {
                var error = $root.world.Position.verify(message.dstPos);
                if (error)
                    return "dstPos." + error;
            }
            return null;
        };

        /**
         * Creates a c2s_troop_move_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_move_to} c2s_troop_move_to
         */
        c2s_troop_move_to.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_move_to)
                return object;
            var message = new $root.world.c2s_troop_move_to();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            if (object.dstPos != null) {
                if (typeof object.dstPos !== "object")
                    throw TypeError(".world.c2s_troop_move_to.dstPos: object expected");
                message.dstPos = $root.world.Position.fromObject(object.dstPos);
            }
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_move_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {world.c2s_troop_move_to} message c2s_troop_move_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_move_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.troopEid = 0;
                object.dstPos = null;
            }
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            if (message.dstPos != null && message.hasOwnProperty("dstPos"))
                object.dstPos = $root.world.Position.toObject(message.dstPos, options);
            return object;
        };

        /**
         * Converts this c2s_troop_move_to to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_move_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_move_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_move_to
         * @function getTypeUrl
         * @memberof world.c2s_troop_move_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_move_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_move_to";
        };

        return c2s_troop_move_to;
    })();

    world.s2c_troop_move_to = (function() {

        /**
         * Properties of a s2c_troop_move_to.
         * @memberof world
         * @interface Is2c_troop_move_to
         * @property {number|null} [err] s2c_troop_move_to err
         */

        /**
         * Constructs a new s2c_troop_move_to.
         * @memberof world
         * @classdesc Represents a s2c_troop_move_to.
         * @implements Is2c_troop_move_to
         * @constructor
         * @param {world.Is2c_troop_move_to=} [properties] Properties to set
         */
        function s2c_troop_move_to(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_move_to err.
         * @member {number} err
         * @memberof world.s2c_troop_move_to
         * @instance
         */
        s2c_troop_move_to.prototype.err = 0;

        /**
         * Creates a new s2c_troop_move_to instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.Is2c_troop_move_to=} [properties] Properties to set
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to instance
         */
        s2c_troop_move_to.create = function create(properties) {
            return new s2c_troop_move_to(properties);
        };

        /**
         * Encodes the specified s2c_troop_move_to message. Does not implicitly {@link world.s2c_troop_move_to.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.Is2c_troop_move_to} message s2c_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_to.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_move_to message, length delimited. Does not implicitly {@link world.s2c_troop_move_to.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.Is2c_troop_move_to} message s2c_troop_move_to message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_to.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_move_to message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_to.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_move_to();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_move_to message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_to.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_move_to message.
         * @function verify
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_move_to.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_move_to message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_move_to} s2c_troop_move_to
         */
        s2c_troop_move_to.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_move_to)
                return object;
            var message = new $root.world.s2c_troop_move_to();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_move_to message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {world.s2c_troop_move_to} message s2c_troop_move_to
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_move_to.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_move_to to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_move_to
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_move_to.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_move_to
         * @function getTypeUrl
         * @memberof world.s2c_troop_move_to
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_move_to.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_move_to";
        };

        return s2c_troop_move_to;
    })();

    world.c2s_troop_move_by = (function() {

        /**
         * Properties of a c2s_troop_move_by.
         * @memberof world
         * @interface Ic2s_troop_move_by
         * @property {number|null} [troopEid] c2s_troop_move_by troopEid
         * @property {number|null} [degree] c2s_troop_move_by degree
         */

        /**
         * Constructs a new c2s_troop_move_by.
         * @memberof world
         * @classdesc Represents a c2s_troop_move_by.
         * @implements Ic2s_troop_move_by
         * @constructor
         * @param {world.Ic2s_troop_move_by=} [properties] Properties to set
         */
        function c2s_troop_move_by(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_move_by troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_move_by
         * @instance
         */
        c2s_troop_move_by.prototype.troopEid = 0;

        /**
         * c2s_troop_move_by degree.
         * @member {number} degree
         * @memberof world.c2s_troop_move_by
         * @instance
         */
        c2s_troop_move_by.prototype.degree = 0;

        /**
         * Creates a new c2s_troop_move_by instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.Ic2s_troop_move_by=} [properties] Properties to set
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by instance
         */
        c2s_troop_move_by.create = function create(properties) {
            return new c2s_troop_move_by(properties);
        };

        /**
         * Encodes the specified c2s_troop_move_by message. Does not implicitly {@link world.c2s_troop_move_by.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.Ic2s_troop_move_by} message c2s_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_by.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.degree);
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_move_by message, length delimited. Does not implicitly {@link world.c2s_troop_move_by.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.Ic2s_troop_move_by} message c2s_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_by.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_move_by message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_by.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_move_by();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.degree = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_move_by message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_by.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_move_by message.
         * @function verify
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_move_by.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (typeof message.degree !== "number")
                    return "degree: number expected";
            return null;
        };

        /**
         * Creates a c2s_troop_move_by message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_move_by} c2s_troop_move_by
         */
        c2s_troop_move_by.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_move_by)
                return object;
            var message = new $root.world.c2s_troop_move_by();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            if (object.degree != null)
                message.degree = Number(object.degree);
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_move_by message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {world.c2s_troop_move_by} message c2s_troop_move_by
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_move_by.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.troopEid = 0;
                object.degree = 0;
            }
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = options.json && !isFinite(message.degree) ? String(message.degree) : message.degree;
            return object;
        };

        /**
         * Converts this c2s_troop_move_by to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_move_by
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_move_by.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_move_by
         * @function getTypeUrl
         * @memberof world.c2s_troop_move_by
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_move_by.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_move_by";
        };

        return c2s_troop_move_by;
    })();

    world.s2c_troop_move_by = (function() {

        /**
         * Properties of a s2c_troop_move_by.
         * @memberof world
         * @interface Is2c_troop_move_by
         * @property {number|null} [err] s2c_troop_move_by err
         */

        /**
         * Constructs a new s2c_troop_move_by.
         * @memberof world
         * @classdesc Represents a s2c_troop_move_by.
         * @implements Is2c_troop_move_by
         * @constructor
         * @param {world.Is2c_troop_move_by=} [properties] Properties to set
         */
        function s2c_troop_move_by(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_move_by err.
         * @member {number} err
         * @memberof world.s2c_troop_move_by
         * @instance
         */
        s2c_troop_move_by.prototype.err = 0;

        /**
         * Creates a new s2c_troop_move_by instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.Is2c_troop_move_by=} [properties] Properties to set
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by instance
         */
        s2c_troop_move_by.create = function create(properties) {
            return new s2c_troop_move_by(properties);
        };

        /**
         * Encodes the specified s2c_troop_move_by message. Does not implicitly {@link world.s2c_troop_move_by.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.Is2c_troop_move_by} message s2c_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_by.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_move_by message, length delimited. Does not implicitly {@link world.s2c_troop_move_by.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.Is2c_troop_move_by} message s2c_troop_move_by message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_by.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_move_by message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_by.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_move_by();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_move_by message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_by.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_move_by message.
         * @function verify
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_move_by.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_move_by message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_move_by} s2c_troop_move_by
         */
        s2c_troop_move_by.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_move_by)
                return object;
            var message = new $root.world.s2c_troop_move_by();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_move_by message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {world.s2c_troop_move_by} message s2c_troop_move_by
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_move_by.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_move_by to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_move_by
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_move_by.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_move_by
         * @function getTypeUrl
         * @memberof world.s2c_troop_move_by
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_move_by.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_move_by";
        };

        return s2c_troop_move_by;
    })();

    world.c2s_troop_move_stop = (function() {

        /**
         * Properties of a c2s_troop_move_stop.
         * @memberof world
         * @interface Ic2s_troop_move_stop
         * @property {number|null} [troopEid] c2s_troop_move_stop troopEid
         */

        /**
         * Constructs a new c2s_troop_move_stop.
         * @memberof world
         * @classdesc Represents a c2s_troop_move_stop.
         * @implements Ic2s_troop_move_stop
         * @constructor
         * @param {world.Ic2s_troop_move_stop=} [properties] Properties to set
         */
        function c2s_troop_move_stop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_move_stop troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_move_stop
         * @instance
         */
        c2s_troop_move_stop.prototype.troopEid = 0;

        /**
         * Creates a new c2s_troop_move_stop instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.Ic2s_troop_move_stop=} [properties] Properties to set
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop instance
         */
        c2s_troop_move_stop.create = function create(properties) {
            return new c2s_troop_move_stop(properties);
        };

        /**
         * Encodes the specified c2s_troop_move_stop message. Does not implicitly {@link world.c2s_troop_move_stop.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.Ic2s_troop_move_stop} message c2s_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_stop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_move_stop message, length delimited. Does not implicitly {@link world.c2s_troop_move_stop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.Ic2s_troop_move_stop} message c2s_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_move_stop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_move_stop message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_stop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_move_stop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_move_stop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_move_stop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_move_stop message.
         * @function verify
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_move_stop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_troop_move_stop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_move_stop} c2s_troop_move_stop
         */
        c2s_troop_move_stop.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_move_stop)
                return object;
            var message = new $root.world.c2s_troop_move_stop();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_move_stop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {world.c2s_troop_move_stop} message c2s_troop_move_stop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_move_stop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.troopEid = 0;
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            return object;
        };

        /**
         * Converts this c2s_troop_move_stop to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_move_stop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_move_stop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_move_stop
         * @function getTypeUrl
         * @memberof world.c2s_troop_move_stop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_move_stop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_move_stop";
        };

        return c2s_troop_move_stop;
    })();

    world.s2c_troop_move_stop = (function() {

        /**
         * Properties of a s2c_troop_move_stop.
         * @memberof world
         * @interface Is2c_troop_move_stop
         * @property {number|null} [err] s2c_troop_move_stop err
         */

        /**
         * Constructs a new s2c_troop_move_stop.
         * @memberof world
         * @classdesc Represents a s2c_troop_move_stop.
         * @implements Is2c_troop_move_stop
         * @constructor
         * @param {world.Is2c_troop_move_stop=} [properties] Properties to set
         */
        function s2c_troop_move_stop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_move_stop err.
         * @member {number} err
         * @memberof world.s2c_troop_move_stop
         * @instance
         */
        s2c_troop_move_stop.prototype.err = 0;

        /**
         * Creates a new s2c_troop_move_stop instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.Is2c_troop_move_stop=} [properties] Properties to set
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop instance
         */
        s2c_troop_move_stop.create = function create(properties) {
            return new s2c_troop_move_stop(properties);
        };

        /**
         * Encodes the specified s2c_troop_move_stop message. Does not implicitly {@link world.s2c_troop_move_stop.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.Is2c_troop_move_stop} message s2c_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_stop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_move_stop message, length delimited. Does not implicitly {@link world.s2c_troop_move_stop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.Is2c_troop_move_stop} message s2c_troop_move_stop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_move_stop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_move_stop message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_stop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_move_stop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_move_stop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_move_stop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_move_stop message.
         * @function verify
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_move_stop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_move_stop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_move_stop} s2c_troop_move_stop
         */
        s2c_troop_move_stop.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_move_stop)
                return object;
            var message = new $root.world.s2c_troop_move_stop();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_move_stop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {world.s2c_troop_move_stop} message s2c_troop_move_stop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_move_stop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_move_stop to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_move_stop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_move_stop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_move_stop
         * @function getTypeUrl
         * @memberof world.s2c_troop_move_stop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_move_stop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_move_stop";
        };

        return s2c_troop_move_stop;
    })();

    world.c2s_troop_retreat = (function() {

        /**
         * Properties of a c2s_troop_retreat.
         * @memberof world
         * @interface Ic2s_troop_retreat
         * @property {number|null} [troopEid] c2s_troop_retreat troopEid
         */

        /**
         * Constructs a new c2s_troop_retreat.
         * @memberof world
         * @classdesc Represents a c2s_troop_retreat.
         * @implements Ic2s_troop_retreat
         * @constructor
         * @param {world.Ic2s_troop_retreat=} [properties] Properties to set
         */
        function c2s_troop_retreat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * c2s_troop_retreat troopEid.
         * @member {number} troopEid
         * @memberof world.c2s_troop_retreat
         * @instance
         */
        c2s_troop_retreat.prototype.troopEid = 0;

        /**
         * Creates a new c2s_troop_retreat instance using the specified properties.
         * @function create
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {world.Ic2s_troop_retreat=} [properties] Properties to set
         * @returns {world.c2s_troop_retreat} c2s_troop_retreat instance
         */
        c2s_troop_retreat.create = function create(properties) {
            return new c2s_troop_retreat(properties);
        };

        /**
         * Encodes the specified c2s_troop_retreat message. Does not implicitly {@link world.c2s_troop_retreat.verify|verify} messages.
         * @function encode
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {world.Ic2s_troop_retreat} message c2s_troop_retreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_retreat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.troopEid != null && Object.hasOwnProperty.call(message, "troopEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.troopEid);
            return writer;
        };

        /**
         * Encodes the specified c2s_troop_retreat message, length delimited. Does not implicitly {@link world.c2s_troop_retreat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {world.Ic2s_troop_retreat} message c2s_troop_retreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        c2s_troop_retreat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a c2s_troop_retreat message from the specified reader or buffer.
         * @function decode
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.c2s_troop_retreat} c2s_troop_retreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_retreat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.c2s_troop_retreat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.troopEid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a c2s_troop_retreat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.c2s_troop_retreat} c2s_troop_retreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        c2s_troop_retreat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a c2s_troop_retreat message.
         * @function verify
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        c2s_troop_retreat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                if (!$util.isInteger(message.troopEid))
                    return "troopEid: integer expected";
            return null;
        };

        /**
         * Creates a c2s_troop_retreat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.c2s_troop_retreat} c2s_troop_retreat
         */
        c2s_troop_retreat.fromObject = function fromObject(object) {
            if (object instanceof $root.world.c2s_troop_retreat)
                return object;
            var message = new $root.world.c2s_troop_retreat();
            if (object.troopEid != null)
                message.troopEid = object.troopEid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a c2s_troop_retreat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {world.c2s_troop_retreat} message c2s_troop_retreat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        c2s_troop_retreat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.troopEid = 0;
            if (message.troopEid != null && message.hasOwnProperty("troopEid"))
                object.troopEid = message.troopEid;
            return object;
        };

        /**
         * Converts this c2s_troop_retreat to JSON.
         * @function toJSON
         * @memberof world.c2s_troop_retreat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        c2s_troop_retreat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for c2s_troop_retreat
         * @function getTypeUrl
         * @memberof world.c2s_troop_retreat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        c2s_troop_retreat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.c2s_troop_retreat";
        };

        return c2s_troop_retreat;
    })();

    world.s2c_troop_retreat = (function() {

        /**
         * Properties of a s2c_troop_retreat.
         * @memberof world
         * @interface Is2c_troop_retreat
         * @property {number|null} [err] s2c_troop_retreat err
         */

        /**
         * Constructs a new s2c_troop_retreat.
         * @memberof world
         * @classdesc Represents a s2c_troop_retreat.
         * @implements Is2c_troop_retreat
         * @constructor
         * @param {world.Is2c_troop_retreat=} [properties] Properties to set
         */
        function s2c_troop_retreat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * s2c_troop_retreat err.
         * @member {number} err
         * @memberof world.s2c_troop_retreat
         * @instance
         */
        s2c_troop_retreat.prototype.err = 0;

        /**
         * Creates a new s2c_troop_retreat instance using the specified properties.
         * @function create
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {world.Is2c_troop_retreat=} [properties] Properties to set
         * @returns {world.s2c_troop_retreat} s2c_troop_retreat instance
         */
        s2c_troop_retreat.create = function create(properties) {
            return new s2c_troop_retreat(properties);
        };

        /**
         * Encodes the specified s2c_troop_retreat message. Does not implicitly {@link world.s2c_troop_retreat.verify|verify} messages.
         * @function encode
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {world.Is2c_troop_retreat} message s2c_troop_retreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_retreat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.err);
            return writer;
        };

        /**
         * Encodes the specified s2c_troop_retreat message, length delimited. Does not implicitly {@link world.s2c_troop_retreat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {world.Is2c_troop_retreat} message s2c_troop_retreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        s2c_troop_retreat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a s2c_troop_retreat message from the specified reader or buffer.
         * @function decode
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.s2c_troop_retreat} s2c_troop_retreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_retreat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.s2c_troop_retreat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.err = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a s2c_troop_retreat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.s2c_troop_retreat} s2c_troop_retreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        s2c_troop_retreat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a s2c_troop_retreat message.
         * @function verify
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        s2c_troop_retreat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.err != null && message.hasOwnProperty("err"))
                if (!$util.isInteger(message.err))
                    return "err: integer expected";
            return null;
        };

        /**
         * Creates a s2c_troop_retreat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.s2c_troop_retreat} s2c_troop_retreat
         */
        s2c_troop_retreat.fromObject = function fromObject(object) {
            if (object instanceof $root.world.s2c_troop_retreat)
                return object;
            var message = new $root.world.s2c_troop_retreat();
            if (object.err != null)
                message.err = object.err >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a s2c_troop_retreat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {world.s2c_troop_retreat} message s2c_troop_retreat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        s2c_troop_retreat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.err = 0;
            if (message.err != null && message.hasOwnProperty("err"))
                object.err = message.err;
            return object;
        };

        /**
         * Converts this s2c_troop_retreat to JSON.
         * @function toJSON
         * @memberof world.s2c_troop_retreat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        s2c_troop_retreat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for s2c_troop_retreat
         * @function getTypeUrl
         * @memberof world.s2c_troop_retreat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        s2c_troop_retreat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.s2c_troop_retreat";
        };

        return s2c_troop_retreat;
    })();

    world.notify_alliances = (function() {

        /**
         * Properties of a notify_alliances.
         * @memberof world
         * @interface Inotify_alliances
         * @property {Array.<world.IAlliance>|null} [alliances] notify_alliances alliances
         */

        /**
         * Constructs a new notify_alliances.
         * @memberof world
         * @classdesc Represents a notify_alliances.
         * @implements Inotify_alliances
         * @constructor
         * @param {world.Inotify_alliances=} [properties] Properties to set
         */
        function notify_alliances(properties) {
            this.alliances = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_alliances alliances.
         * @member {Array.<world.IAlliance>} alliances
         * @memberof world.notify_alliances
         * @instance
         */
        notify_alliances.prototype.alliances = $util.emptyArray;

        /**
         * Creates a new notify_alliances instance using the specified properties.
         * @function create
         * @memberof world.notify_alliances
         * @static
         * @param {world.Inotify_alliances=} [properties] Properties to set
         * @returns {world.notify_alliances} notify_alliances instance
         */
        notify_alliances.create = function create(properties) {
            return new notify_alliances(properties);
        };

        /**
         * Encodes the specified notify_alliances message. Does not implicitly {@link world.notify_alliances.verify|verify} messages.
         * @function encode
         * @memberof world.notify_alliances
         * @static
         * @param {world.Inotify_alliances} message notify_alliances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_alliances.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alliances != null && message.alliances.length)
                for (var i = 0; i < message.alliances.length; ++i)
                    $root.world.Alliance.encode(message.alliances[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_alliances message, length delimited. Does not implicitly {@link world.notify_alliances.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_alliances
         * @static
         * @param {world.Inotify_alliances} message notify_alliances message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_alliances.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_alliances message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_alliances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_alliances} notify_alliances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_alliances.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_alliances();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.alliances && message.alliances.length))
                            message.alliances = [];
                        message.alliances.push($root.world.Alliance.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_alliances message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_alliances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_alliances} notify_alliances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_alliances.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_alliances message.
         * @function verify
         * @memberof world.notify_alliances
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_alliances.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.alliances != null && message.hasOwnProperty("alliances")) {
                if (!Array.isArray(message.alliances))
                    return "alliances: array expected";
                for (var i = 0; i < message.alliances.length; ++i) {
                    var error = $root.world.Alliance.verify(message.alliances[i]);
                    if (error)
                        return "alliances." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_alliances message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_alliances
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_alliances} notify_alliances
         */
        notify_alliances.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_alliances)
                return object;
            var message = new $root.world.notify_alliances();
            if (object.alliances) {
                if (!Array.isArray(object.alliances))
                    throw TypeError(".world.notify_alliances.alliances: array expected");
                message.alliances = [];
                for (var i = 0; i < object.alliances.length; ++i) {
                    if (typeof object.alliances[i] !== "object")
                        throw TypeError(".world.notify_alliances.alliances: object expected");
                    message.alliances[i] = $root.world.Alliance.fromObject(object.alliances[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_alliances message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_alliances
         * @static
         * @param {world.notify_alliances} message notify_alliances
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_alliances.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.alliances = [];
            if (message.alliances && message.alliances.length) {
                object.alliances = [];
                for (var j = 0; j < message.alliances.length; ++j)
                    object.alliances[j] = $root.world.Alliance.toObject(message.alliances[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_alliances to JSON.
         * @function toJSON
         * @memberof world.notify_alliances
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_alliances.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_alliances
         * @function getTypeUrl
         * @memberof world.notify_alliances
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_alliances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_alliances";
        };

        return notify_alliances;
    })();

    world.notify_roles = (function() {

        /**
         * Properties of a notify_roles.
         * @memberof world
         * @interface Inotify_roles
         * @property {Array.<world.IRole>|null} [roles] notify_roles roles
         */

        /**
         * Constructs a new notify_roles.
         * @memberof world
         * @classdesc Represents a notify_roles.
         * @implements Inotify_roles
         * @constructor
         * @param {world.Inotify_roles=} [properties] Properties to set
         */
        function notify_roles(properties) {
            this.roles = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_roles roles.
         * @member {Array.<world.IRole>} roles
         * @memberof world.notify_roles
         * @instance
         */
        notify_roles.prototype.roles = $util.emptyArray;

        /**
         * Creates a new notify_roles instance using the specified properties.
         * @function create
         * @memberof world.notify_roles
         * @static
         * @param {world.Inotify_roles=} [properties] Properties to set
         * @returns {world.notify_roles} notify_roles instance
         */
        notify_roles.create = function create(properties) {
            return new notify_roles(properties);
        };

        /**
         * Encodes the specified notify_roles message. Does not implicitly {@link world.notify_roles.verify|verify} messages.
         * @function encode
         * @memberof world.notify_roles
         * @static
         * @param {world.Inotify_roles} message notify_roles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_roles.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roles != null && message.roles.length)
                for (var i = 0; i < message.roles.length; ++i)
                    $root.world.Role.encode(message.roles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_roles message, length delimited. Does not implicitly {@link world.notify_roles.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_roles
         * @static
         * @param {world.Inotify_roles} message notify_roles message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_roles.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_roles message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_roles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_roles} notify_roles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_roles.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_roles();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push($root.world.Role.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_roles message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_roles
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_roles} notify_roles
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_roles.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_roles message.
         * @function verify
         * @memberof world.notify_roles
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_roles.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (var i = 0; i < message.roles.length; ++i) {
                    var error = $root.world.Role.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_roles message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_roles
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_roles} notify_roles
         */
        notify_roles.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_roles)
                return object;
            var message = new $root.world.notify_roles();
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".world.notify_roles.roles: array expected");
                message.roles = [];
                for (var i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".world.notify_roles.roles: object expected");
                    message.roles[i] = $root.world.Role.fromObject(object.roles[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_roles message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_roles
         * @static
         * @param {world.notify_roles} message notify_roles
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_roles.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.roles = [];
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (var j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.world.Role.toObject(message.roles[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_roles to JSON.
         * @function toJSON
         * @memberof world.notify_roles
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_roles.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_roles
         * @function getTypeUrl
         * @memberof world.notify_roles
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_roles.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_roles";
        };

        return notify_roles;
    })();

    world.AddEntityAction = (function() {

        /**
         * Properties of an AddEntityAction.
         * @memberof world
         * @interface IAddEntityAction
         * @property {world.IEntity|null} [entity] AddEntityAction entity
         */

        /**
         * Constructs a new AddEntityAction.
         * @memberof world
         * @classdesc Represents an AddEntityAction.
         * @implements IAddEntityAction
         * @constructor
         * @param {world.IAddEntityAction=} [properties] Properties to set
         */
        function AddEntityAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddEntityAction entity.
         * @member {world.IEntity|null|undefined} entity
         * @memberof world.AddEntityAction
         * @instance
         */
        AddEntityAction.prototype.entity = null;

        /**
         * Creates a new AddEntityAction instance using the specified properties.
         * @function create
         * @memberof world.AddEntityAction
         * @static
         * @param {world.IAddEntityAction=} [properties] Properties to set
         * @returns {world.AddEntityAction} AddEntityAction instance
         */
        AddEntityAction.create = function create(properties) {
            return new AddEntityAction(properties);
        };

        /**
         * Encodes the specified AddEntityAction message. Does not implicitly {@link world.AddEntityAction.verify|verify} messages.
         * @function encode
         * @memberof world.AddEntityAction
         * @static
         * @param {world.IAddEntityAction} message AddEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddEntityAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                $root.world.Entity.encode(message.entity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddEntityAction message, length delimited. Does not implicitly {@link world.AddEntityAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.AddEntityAction
         * @static
         * @param {world.IAddEntityAction} message AddEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddEntityAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddEntityAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.AddEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.AddEntityAction} AddEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddEntityAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.AddEntityAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.entity = $root.world.Entity.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddEntityAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.AddEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.AddEntityAction} AddEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddEntityAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddEntityAction message.
         * @function verify
         * @memberof world.AddEntityAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddEntityAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entity != null && message.hasOwnProperty("entity")) {
                var error = $root.world.Entity.verify(message.entity);
                if (error)
                    return "entity." + error;
            }
            return null;
        };

        /**
         * Creates an AddEntityAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.AddEntityAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.AddEntityAction} AddEntityAction
         */
        AddEntityAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.AddEntityAction)
                return object;
            var message = new $root.world.AddEntityAction();
            if (object.entity != null) {
                if (typeof object.entity !== "object")
                    throw TypeError(".world.AddEntityAction.entity: object expected");
                message.entity = $root.world.Entity.fromObject(object.entity);
            }
            return message;
        };

        /**
         * Creates a plain object from an AddEntityAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.AddEntityAction
         * @static
         * @param {world.AddEntityAction} message AddEntityAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddEntityAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.entity = null;
            if (message.entity != null && message.hasOwnProperty("entity"))
                object.entity = $root.world.Entity.toObject(message.entity, options);
            return object;
        };

        /**
         * Converts this AddEntityAction to JSON.
         * @function toJSON
         * @memberof world.AddEntityAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddEntityAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AddEntityAction
         * @function getTypeUrl
         * @memberof world.AddEntityAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AddEntityAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.AddEntityAction";
        };

        return AddEntityAction;
    })();

    world.DelEntityAction = (function() {

        /**
         * Properties of a DelEntityAction.
         * @memberof world
         * @interface IDelEntityAction
         * @property {number|null} [eid] DelEntityAction eid
         */

        /**
         * Constructs a new DelEntityAction.
         * @memberof world
         * @classdesc Represents a DelEntityAction.
         * @implements IDelEntityAction
         * @constructor
         * @param {world.IDelEntityAction=} [properties] Properties to set
         */
        function DelEntityAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelEntityAction eid.
         * @member {number} eid
         * @memberof world.DelEntityAction
         * @instance
         */
        DelEntityAction.prototype.eid = 0;

        /**
         * Creates a new DelEntityAction instance using the specified properties.
         * @function create
         * @memberof world.DelEntityAction
         * @static
         * @param {world.IDelEntityAction=} [properties] Properties to set
         * @returns {world.DelEntityAction} DelEntityAction instance
         */
        DelEntityAction.create = function create(properties) {
            return new DelEntityAction(properties);
        };

        /**
         * Encodes the specified DelEntityAction message. Does not implicitly {@link world.DelEntityAction.verify|verify} messages.
         * @function encode
         * @memberof world.DelEntityAction
         * @static
         * @param {world.IDelEntityAction} message DelEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelEntityAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified DelEntityAction message, length delimited. Does not implicitly {@link world.DelEntityAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.DelEntityAction
         * @static
         * @param {world.IDelEntityAction} message DelEntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelEntityAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelEntityAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.DelEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.DelEntityAction} DelEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelEntityAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.DelEntityAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelEntityAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.DelEntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.DelEntityAction} DelEntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelEntityAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelEntityAction message.
         * @function verify
         * @memberof world.DelEntityAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelEntityAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a DelEntityAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.DelEntityAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.DelEntityAction} DelEntityAction
         */
        DelEntityAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.DelEntityAction)
                return object;
            var message = new $root.world.DelEntityAction();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DelEntityAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.DelEntityAction
         * @static
         * @param {world.DelEntityAction} message DelEntityAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelEntityAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.eid = 0;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this DelEntityAction to JSON.
         * @function toJSON
         * @memberof world.DelEntityAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelEntityAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DelEntityAction
         * @function getTypeUrl
         * @memberof world.DelEntityAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DelEntityAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.DelEntityAction";
        };

        return DelEntityAction;
    })();

    world.MoveAction = (function() {

        /**
         * Properties of a MoveAction.
         * @memberof world
         * @interface IMoveAction
         * @property {number|null} [eid] MoveAction eid
         * @property {Array.<world.IPosition>|null} [path] MoveAction path
         * @property {number|null} [speed] MoveAction speed
         * @property {number|null} [startMs] MoveAction startMs
         * @property {world.IPosition|null} [curPos] MoveAction curPos
         * @property {number|null} [degree] MoveAction degree
         */

        /**
         * Constructs a new MoveAction.
         * @memberof world
         * @classdesc Represents a MoveAction.
         * @implements IMoveAction
         * @constructor
         * @param {world.IMoveAction=} [properties] Properties to set
         */
        function MoveAction(properties) {
            this.path = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveAction eid.
         * @member {number} eid
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.eid = 0;

        /**
         * MoveAction path.
         * @member {Array.<world.IPosition>} path
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.path = $util.emptyArray;

        /**
         * MoveAction speed.
         * @member {number} speed
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.speed = 0;

        /**
         * MoveAction startMs.
         * @member {number} startMs
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.startMs = 0;

        /**
         * MoveAction curPos.
         * @member {world.IPosition|null|undefined} curPos
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.curPos = null;

        /**
         * MoveAction degree.
         * @member {number} degree
         * @memberof world.MoveAction
         * @instance
         */
        MoveAction.prototype.degree = 0;

        /**
         * Creates a new MoveAction instance using the specified properties.
         * @function create
         * @memberof world.MoveAction
         * @static
         * @param {world.IMoveAction=} [properties] Properties to set
         * @returns {world.MoveAction} MoveAction instance
         */
        MoveAction.create = function create(properties) {
            return new MoveAction(properties);
        };

        /**
         * Encodes the specified MoveAction message. Does not implicitly {@link world.MoveAction.verify|verify} messages.
         * @function encode
         * @memberof world.MoveAction
         * @static
         * @param {world.IMoveAction} message MoveAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.eid);
            if (message.path != null && message.path.length)
                for (var i = 0; i < message.path.length; ++i)
                    $root.world.Position.encode(message.path[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.speed);
            if (message.startMs != null && Object.hasOwnProperty.call(message, "startMs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.startMs);
            if (message.curPos != null && Object.hasOwnProperty.call(message, "curPos"))
                $root.world.Position.encode(message.curPos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.degree);
            return writer;
        };

        /**
         * Encodes the specified MoveAction message, length delimited. Does not implicitly {@link world.MoveAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.MoveAction
         * @static
         * @param {world.IMoveAction} message MoveAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.MoveAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.MoveAction} MoveAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.MoveAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.eid = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push($root.world.Position.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.speed = reader.uint32();
                        break;
                    }
                case 4: {
                        message.startMs = reader.uint32();
                        break;
                    }
                case 5: {
                        message.curPos = $root.world.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.degree = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.MoveAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.MoveAction} MoveAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveAction message.
         * @function verify
         * @memberof world.MoveAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (var i = 0; i < message.path.length; ++i) {
                    var error = $root.world.Position.verify(message.path[i]);
                    if (error)
                        return "path." + error;
                }
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                if (!$util.isInteger(message.speed))
                    return "speed: integer expected";
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                if (!$util.isInteger(message.startMs))
                    return "startMs: integer expected";
            if (message.curPos != null && message.hasOwnProperty("curPos")) {
                var error = $root.world.Position.verify(message.curPos);
                if (error)
                    return "curPos." + error;
            }
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (typeof message.degree !== "number")
                    return "degree: number expected";
            return null;
        };

        /**
         * Creates a MoveAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.MoveAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.MoveAction} MoveAction
         */
        MoveAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.MoveAction)
                return object;
            var message = new $root.world.MoveAction();
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".world.MoveAction.path: array expected");
                message.path = [];
                for (var i = 0; i < object.path.length; ++i) {
                    if (typeof object.path[i] !== "object")
                        throw TypeError(".world.MoveAction.path: object expected");
                    message.path[i] = $root.world.Position.fromObject(object.path[i]);
                }
            }
            if (object.speed != null)
                message.speed = object.speed >>> 0;
            if (object.startMs != null)
                message.startMs = object.startMs >>> 0;
            if (object.curPos != null) {
                if (typeof object.curPos !== "object")
                    throw TypeError(".world.MoveAction.curPos: object expected");
                message.curPos = $root.world.Position.fromObject(object.curPos);
            }
            if (object.degree != null)
                message.degree = Number(object.degree);
            return message;
        };

        /**
         * Creates a plain object from a MoveAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.MoveAction
         * @static
         * @param {world.MoveAction} message MoveAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MoveAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (options.defaults) {
                object.eid = 0;
                object.speed = 0;
                object.startMs = 0;
                object.curPos = null;
                object.degree = 0;
            }
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.path && message.path.length) {
                object.path = [];
                for (var j = 0; j < message.path.length; ++j)
                    object.path[j] = $root.world.Position.toObject(message.path[j], options);
            }
            if (message.speed != null && message.hasOwnProperty("speed"))
                object.speed = message.speed;
            if (message.startMs != null && message.hasOwnProperty("startMs"))
                object.startMs = message.startMs;
            if (message.curPos != null && message.hasOwnProperty("curPos"))
                object.curPos = $root.world.Position.toObject(message.curPos, options);
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = options.json && !isFinite(message.degree) ? String(message.degree) : message.degree;
            return object;
        };

        /**
         * Converts this MoveAction to JSON.
         * @function toJSON
         * @memberof world.MoveAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MoveAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MoveAction
         * @function getTypeUrl
         * @memberof world.MoveAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MoveAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.MoveAction";
        };

        return MoveAction;
    })();

    world.StartBattleAction = (function() {

        /**
         * Properties of a StartBattleAction.
         * @memberof world
         * @interface IStartBattleAction
         * @property {number|null} [battleUid] StartBattleAction battleUid
         * @property {Array.<number>|null} [troopEids] StartBattleAction troopEids
         */

        /**
         * Constructs a new StartBattleAction.
         * @memberof world
         * @classdesc Represents a StartBattleAction.
         * @implements IStartBattleAction
         * @constructor
         * @param {world.IStartBattleAction=} [properties] Properties to set
         */
        function StartBattleAction(properties) {
            this.troopEids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartBattleAction battleUid.
         * @member {number} battleUid
         * @memberof world.StartBattleAction
         * @instance
         */
        StartBattleAction.prototype.battleUid = 0;

        /**
         * StartBattleAction troopEids.
         * @member {Array.<number>} troopEids
         * @memberof world.StartBattleAction
         * @instance
         */
        StartBattleAction.prototype.troopEids = $util.emptyArray;

        /**
         * Creates a new StartBattleAction instance using the specified properties.
         * @function create
         * @memberof world.StartBattleAction
         * @static
         * @param {world.IStartBattleAction=} [properties] Properties to set
         * @returns {world.StartBattleAction} StartBattleAction instance
         */
        StartBattleAction.create = function create(properties) {
            return new StartBattleAction(properties);
        };

        /**
         * Encodes the specified StartBattleAction message. Does not implicitly {@link world.StartBattleAction.verify|verify} messages.
         * @function encode
         * @memberof world.StartBattleAction
         * @static
         * @param {world.IStartBattleAction} message StartBattleAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartBattleAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.troopEids != null && message.troopEids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.troopEids.length; ++i)
                    writer.uint32(message.troopEids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified StartBattleAction message, length delimited. Does not implicitly {@link world.StartBattleAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.StartBattleAction
         * @static
         * @param {world.IStartBattleAction} message StartBattleAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartBattleAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartBattleAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.StartBattleAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.StartBattleAction} StartBattleAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartBattleAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.StartBattleAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.troopEids && message.troopEids.length))
                            message.troopEids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.troopEids.push(reader.uint32());
                        } else
                            message.troopEids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartBattleAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.StartBattleAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.StartBattleAction} StartBattleAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartBattleAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartBattleAction message.
         * @function verify
         * @memberof world.StartBattleAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartBattleAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.troopEids != null && message.hasOwnProperty("troopEids")) {
                if (!Array.isArray(message.troopEids))
                    return "troopEids: array expected";
                for (var i = 0; i < message.troopEids.length; ++i)
                    if (!$util.isInteger(message.troopEids[i]))
                        return "troopEids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a StartBattleAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.StartBattleAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.StartBattleAction} StartBattleAction
         */
        StartBattleAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.StartBattleAction)
                return object;
            var message = new $root.world.StartBattleAction();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.troopEids) {
                if (!Array.isArray(object.troopEids))
                    throw TypeError(".world.StartBattleAction.troopEids: array expected");
                message.troopEids = [];
                for (var i = 0; i < object.troopEids.length; ++i)
                    message.troopEids[i] = object.troopEids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a StartBattleAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.StartBattleAction
         * @static
         * @param {world.StartBattleAction} message StartBattleAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartBattleAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.troopEids = [];
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.troopEids && message.troopEids.length) {
                object.troopEids = [];
                for (var j = 0; j < message.troopEids.length; ++j)
                    object.troopEids[j] = message.troopEids[j];
            }
            return object;
        };

        /**
         * Converts this StartBattleAction to JSON.
         * @function toJSON
         * @memberof world.StartBattleAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartBattleAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StartBattleAction
         * @function getTypeUrl
         * @memberof world.StartBattleAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StartBattleAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.StartBattleAction";
        };

        return StartBattleAction;
    })();

    world.LeaveBattleAction = (function() {

        /**
         * Properties of a LeaveBattleAction.
         * @memberof world
         * @interface ILeaveBattleAction
         * @property {number|null} [battleUid] LeaveBattleAction battleUid
         * @property {Array.<number>|null} [troopEids] LeaveBattleAction troopEids
         */

        /**
         * Constructs a new LeaveBattleAction.
         * @memberof world
         * @classdesc Represents a LeaveBattleAction.
         * @implements ILeaveBattleAction
         * @constructor
         * @param {world.ILeaveBattleAction=} [properties] Properties to set
         */
        function LeaveBattleAction(properties) {
            this.troopEids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LeaveBattleAction battleUid.
         * @member {number} battleUid
         * @memberof world.LeaveBattleAction
         * @instance
         */
        LeaveBattleAction.prototype.battleUid = 0;

        /**
         * LeaveBattleAction troopEids.
         * @member {Array.<number>} troopEids
         * @memberof world.LeaveBattleAction
         * @instance
         */
        LeaveBattleAction.prototype.troopEids = $util.emptyArray;

        /**
         * Creates a new LeaveBattleAction instance using the specified properties.
         * @function create
         * @memberof world.LeaveBattleAction
         * @static
         * @param {world.ILeaveBattleAction=} [properties] Properties to set
         * @returns {world.LeaveBattleAction} LeaveBattleAction instance
         */
        LeaveBattleAction.create = function create(properties) {
            return new LeaveBattleAction(properties);
        };

        /**
         * Encodes the specified LeaveBattleAction message. Does not implicitly {@link world.LeaveBattleAction.verify|verify} messages.
         * @function encode
         * @memberof world.LeaveBattleAction
         * @static
         * @param {world.ILeaveBattleAction} message LeaveBattleAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaveBattleAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.troopEids != null && message.troopEids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.troopEids.length; ++i)
                    writer.uint32(message.troopEids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified LeaveBattleAction message, length delimited. Does not implicitly {@link world.LeaveBattleAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.LeaveBattleAction
         * @static
         * @param {world.ILeaveBattleAction} message LeaveBattleAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaveBattleAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LeaveBattleAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.LeaveBattleAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.LeaveBattleAction} LeaveBattleAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveBattleAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.LeaveBattleAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.troopEids && message.troopEids.length))
                            message.troopEids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.troopEids.push(reader.uint32());
                        } else
                            message.troopEids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LeaveBattleAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.LeaveBattleAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.LeaveBattleAction} LeaveBattleAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveBattleAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LeaveBattleAction message.
         * @function verify
         * @memberof world.LeaveBattleAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LeaveBattleAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.troopEids != null && message.hasOwnProperty("troopEids")) {
                if (!Array.isArray(message.troopEids))
                    return "troopEids: array expected";
                for (var i = 0; i < message.troopEids.length; ++i)
                    if (!$util.isInteger(message.troopEids[i]))
                        return "troopEids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a LeaveBattleAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.LeaveBattleAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.LeaveBattleAction} LeaveBattleAction
         */
        LeaveBattleAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.LeaveBattleAction)
                return object;
            var message = new $root.world.LeaveBattleAction();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.troopEids) {
                if (!Array.isArray(object.troopEids))
                    throw TypeError(".world.LeaveBattleAction.troopEids: array expected");
                message.troopEids = [];
                for (var i = 0; i < object.troopEids.length; ++i)
                    message.troopEids[i] = object.troopEids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a LeaveBattleAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.LeaveBattleAction
         * @static
         * @param {world.LeaveBattleAction} message LeaveBattleAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LeaveBattleAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.troopEids = [];
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.troopEids && message.troopEids.length) {
                object.troopEids = [];
                for (var j = 0; j < message.troopEids.length; ++j)
                    object.troopEids[j] = message.troopEids[j];
            }
            return object;
        };

        /**
         * Converts this LeaveBattleAction to JSON.
         * @function toJSON
         * @memberof world.LeaveBattleAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LeaveBattleAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LeaveBattleAction
         * @function getTypeUrl
         * @memberof world.LeaveBattleAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LeaveBattleAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.LeaveBattleAction";
        };

        return LeaveBattleAction;
    })();

    world.StopBattleAction = (function() {

        /**
         * Properties of a StopBattleAction.
         * @memberof world
         * @interface IStopBattleAction
         * @property {number|null} [battleUid] StopBattleAction battleUid
         * @property {Array.<number>|null} [troopEids] StopBattleAction troopEids
         */

        /**
         * Constructs a new StopBattleAction.
         * @memberof world
         * @classdesc Represents a StopBattleAction.
         * @implements IStopBattleAction
         * @constructor
         * @param {world.IStopBattleAction=} [properties] Properties to set
         */
        function StopBattleAction(properties) {
            this.troopEids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopBattleAction battleUid.
         * @member {number} battleUid
         * @memberof world.StopBattleAction
         * @instance
         */
        StopBattleAction.prototype.battleUid = 0;

        /**
         * StopBattleAction troopEids.
         * @member {Array.<number>} troopEids
         * @memberof world.StopBattleAction
         * @instance
         */
        StopBattleAction.prototype.troopEids = $util.emptyArray;

        /**
         * Creates a new StopBattleAction instance using the specified properties.
         * @function create
         * @memberof world.StopBattleAction
         * @static
         * @param {world.IStopBattleAction=} [properties] Properties to set
         * @returns {world.StopBattleAction} StopBattleAction instance
         */
        StopBattleAction.create = function create(properties) {
            return new StopBattleAction(properties);
        };

        /**
         * Encodes the specified StopBattleAction message. Does not implicitly {@link world.StopBattleAction.verify|verify} messages.
         * @function encode
         * @memberof world.StopBattleAction
         * @static
         * @param {world.IStopBattleAction} message StopBattleAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopBattleAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleUid != null && Object.hasOwnProperty.call(message, "battleUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battleUid);
            if (message.troopEids != null && message.troopEids.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.troopEids.length; ++i)
                    writer.uint32(message.troopEids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified StopBattleAction message, length delimited. Does not implicitly {@link world.StopBattleAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.StopBattleAction
         * @static
         * @param {world.IStopBattleAction} message StopBattleAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopBattleAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopBattleAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.StopBattleAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.StopBattleAction} StopBattleAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopBattleAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.StopBattleAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.battleUid = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.troopEids && message.troopEids.length))
                            message.troopEids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.troopEids.push(reader.uint32());
                        } else
                            message.troopEids.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopBattleAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.StopBattleAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.StopBattleAction} StopBattleAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopBattleAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopBattleAction message.
         * @function verify
         * @memberof world.StopBattleAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopBattleAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                if (!$util.isInteger(message.battleUid))
                    return "battleUid: integer expected";
            if (message.troopEids != null && message.hasOwnProperty("troopEids")) {
                if (!Array.isArray(message.troopEids))
                    return "troopEids: array expected";
                for (var i = 0; i < message.troopEids.length; ++i)
                    if (!$util.isInteger(message.troopEids[i]))
                        return "troopEids: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a StopBattleAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.StopBattleAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.StopBattleAction} StopBattleAction
         */
        StopBattleAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.StopBattleAction)
                return object;
            var message = new $root.world.StopBattleAction();
            if (object.battleUid != null)
                message.battleUid = object.battleUid >>> 0;
            if (object.troopEids) {
                if (!Array.isArray(object.troopEids))
                    throw TypeError(".world.StopBattleAction.troopEids: array expected");
                message.troopEids = [];
                for (var i = 0; i < object.troopEids.length; ++i)
                    message.troopEids[i] = object.troopEids[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a StopBattleAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.StopBattleAction
         * @static
         * @param {world.StopBattleAction} message StopBattleAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopBattleAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.troopEids = [];
            if (options.defaults)
                object.battleUid = 0;
            if (message.battleUid != null && message.hasOwnProperty("battleUid"))
                object.battleUid = message.battleUid;
            if (message.troopEids && message.troopEids.length) {
                object.troopEids = [];
                for (var j = 0; j < message.troopEids.length; ++j)
                    object.troopEids[j] = message.troopEids[j];
            }
            return object;
        };

        /**
         * Converts this StopBattleAction to JSON.
         * @function toJSON
         * @memberof world.StopBattleAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopBattleAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StopBattleAction
         * @function getTypeUrl
         * @memberof world.StopBattleAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StopBattleAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.StopBattleAction";
        };

        return StopBattleAction;
    })();

    world.EntityAction = (function() {

        /**
         * Properties of an EntityAction.
         * @memberof world
         * @interface IEntityAction
         * @property {number|null} [action] EntityAction action
         * @property {world.IAddEntityAction|null} [addEntity] EntityAction addEntity
         * @property {world.IDelEntityAction|null} [delEntity] EntityAction delEntity
         * @property {world.IMoveAction|null} [move] EntityAction move
         * @property {world.IStartBattleAction|null} [startBattle] EntityAction startBattle
         * @property {world.ILeaveBattleAction|null} [leaveBattle] EntityAction leaveBattle
         * @property {world.IStopBattleAction|null} [stopBattle] EntityAction stopBattle
         */

        /**
         * Constructs a new EntityAction.
         * @memberof world
         * @classdesc Represents an EntityAction.
         * @implements IEntityAction
         * @constructor
         * @param {world.IEntityAction=} [properties] Properties to set
         */
        function EntityAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EntityAction action.
         * @member {number} action
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.action = 0;

        /**
         * EntityAction addEntity.
         * @member {world.IAddEntityAction|null|undefined} addEntity
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.addEntity = null;

        /**
         * EntityAction delEntity.
         * @member {world.IDelEntityAction|null|undefined} delEntity
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.delEntity = null;

        /**
         * EntityAction move.
         * @member {world.IMoveAction|null|undefined} move
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.move = null;

        /**
         * EntityAction startBattle.
         * @member {world.IStartBattleAction|null|undefined} startBattle
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.startBattle = null;

        /**
         * EntityAction leaveBattle.
         * @member {world.ILeaveBattleAction|null|undefined} leaveBattle
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.leaveBattle = null;

        /**
         * EntityAction stopBattle.
         * @member {world.IStopBattleAction|null|undefined} stopBattle
         * @memberof world.EntityAction
         * @instance
         */
        EntityAction.prototype.stopBattle = null;

        /**
         * Creates a new EntityAction instance using the specified properties.
         * @function create
         * @memberof world.EntityAction
         * @static
         * @param {world.IEntityAction=} [properties] Properties to set
         * @returns {world.EntityAction} EntityAction instance
         */
        EntityAction.create = function create(properties) {
            return new EntityAction(properties);
        };

        /**
         * Encodes the specified EntityAction message. Does not implicitly {@link world.EntityAction.verify|verify} messages.
         * @function encode
         * @memberof world.EntityAction
         * @static
         * @param {world.IEntityAction} message EntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.action);
            if (message.addEntity != null && Object.hasOwnProperty.call(message, "addEntity"))
                $root.world.AddEntityAction.encode(message.addEntity, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.delEntity != null && Object.hasOwnProperty.call(message, "delEntity"))
                $root.world.DelEntityAction.encode(message.delEntity, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.move != null && Object.hasOwnProperty.call(message, "move"))
                $root.world.MoveAction.encode(message.move, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.startBattle != null && Object.hasOwnProperty.call(message, "startBattle"))
                $root.world.StartBattleAction.encode(message.startBattle, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.leaveBattle != null && Object.hasOwnProperty.call(message, "leaveBattle"))
                $root.world.LeaveBattleAction.encode(message.leaveBattle, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.stopBattle != null && Object.hasOwnProperty.call(message, "stopBattle"))
                $root.world.StopBattleAction.encode(message.stopBattle, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EntityAction message, length delimited. Does not implicitly {@link world.EntityAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.EntityAction
         * @static
         * @param {world.IEntityAction} message EntityAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EntityAction message from the specified reader or buffer.
         * @function decode
         * @memberof world.EntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.EntityAction} EntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.EntityAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.action = reader.uint32();
                        break;
                    }
                case 10: {
                        message.addEntity = $root.world.AddEntityAction.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.delEntity = $root.world.DelEntityAction.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.move = $root.world.MoveAction.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.startBattle = $root.world.StartBattleAction.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.leaveBattle = $root.world.LeaveBattleAction.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.stopBattle = $root.world.StopBattleAction.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EntityAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.EntityAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.EntityAction} EntityAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EntityAction message.
         * @function verify
         * @memberof world.EntityAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EntityAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isInteger(message.action))
                    return "action: integer expected";
            if (message.addEntity != null && message.hasOwnProperty("addEntity")) {
                var error = $root.world.AddEntityAction.verify(message.addEntity);
                if (error)
                    return "addEntity." + error;
            }
            if (message.delEntity != null && message.hasOwnProperty("delEntity")) {
                var error = $root.world.DelEntityAction.verify(message.delEntity);
                if (error)
                    return "delEntity." + error;
            }
            if (message.move != null && message.hasOwnProperty("move")) {
                var error = $root.world.MoveAction.verify(message.move);
                if (error)
                    return "move." + error;
            }
            if (message.startBattle != null && message.hasOwnProperty("startBattle")) {
                var error = $root.world.StartBattleAction.verify(message.startBattle);
                if (error)
                    return "startBattle." + error;
            }
            if (message.leaveBattle != null && message.hasOwnProperty("leaveBattle")) {
                var error = $root.world.LeaveBattleAction.verify(message.leaveBattle);
                if (error)
                    return "leaveBattle." + error;
            }
            if (message.stopBattle != null && message.hasOwnProperty("stopBattle")) {
                var error = $root.world.StopBattleAction.verify(message.stopBattle);
                if (error)
                    return "stopBattle." + error;
            }
            return null;
        };

        /**
         * Creates an EntityAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.EntityAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.EntityAction} EntityAction
         */
        EntityAction.fromObject = function fromObject(object) {
            if (object instanceof $root.world.EntityAction)
                return object;
            var message = new $root.world.EntityAction();
            if (object.action != null)
                message.action = object.action >>> 0;
            if (object.addEntity != null) {
                if (typeof object.addEntity !== "object")
                    throw TypeError(".world.EntityAction.addEntity: object expected");
                message.addEntity = $root.world.AddEntityAction.fromObject(object.addEntity);
            }
            if (object.delEntity != null) {
                if (typeof object.delEntity !== "object")
                    throw TypeError(".world.EntityAction.delEntity: object expected");
                message.delEntity = $root.world.DelEntityAction.fromObject(object.delEntity);
            }
            if (object.move != null) {
                if (typeof object.move !== "object")
                    throw TypeError(".world.EntityAction.move: object expected");
                message.move = $root.world.MoveAction.fromObject(object.move);
            }
            if (object.startBattle != null) {
                if (typeof object.startBattle !== "object")
                    throw TypeError(".world.EntityAction.startBattle: object expected");
                message.startBattle = $root.world.StartBattleAction.fromObject(object.startBattle);
            }
            if (object.leaveBattle != null) {
                if (typeof object.leaveBattle !== "object")
                    throw TypeError(".world.EntityAction.leaveBattle: object expected");
                message.leaveBattle = $root.world.LeaveBattleAction.fromObject(object.leaveBattle);
            }
            if (object.stopBattle != null) {
                if (typeof object.stopBattle !== "object")
                    throw TypeError(".world.EntityAction.stopBattle: object expected");
                message.stopBattle = $root.world.StopBattleAction.fromObject(object.stopBattle);
            }
            return message;
        };

        /**
         * Creates a plain object from an EntityAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.EntityAction
         * @static
         * @param {world.EntityAction} message EntityAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EntityAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.action = 0;
                object.addEntity = null;
                object.delEntity = null;
                object.move = null;
                object.startBattle = null;
                object.leaveBattle = null;
                object.stopBattle = null;
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            if (message.addEntity != null && message.hasOwnProperty("addEntity"))
                object.addEntity = $root.world.AddEntityAction.toObject(message.addEntity, options);
            if (message.delEntity != null && message.hasOwnProperty("delEntity"))
                object.delEntity = $root.world.DelEntityAction.toObject(message.delEntity, options);
            if (message.move != null && message.hasOwnProperty("move"))
                object.move = $root.world.MoveAction.toObject(message.move, options);
            if (message.startBattle != null && message.hasOwnProperty("startBattle"))
                object.startBattle = $root.world.StartBattleAction.toObject(message.startBattle, options);
            if (message.leaveBattle != null && message.hasOwnProperty("leaveBattle"))
                object.leaveBattle = $root.world.LeaveBattleAction.toObject(message.leaveBattle, options);
            if (message.stopBattle != null && message.hasOwnProperty("stopBattle"))
                object.stopBattle = $root.world.StopBattleAction.toObject(message.stopBattle, options);
            return object;
        };

        /**
         * Converts this EntityAction to JSON.
         * @function toJSON
         * @memberof world.EntityAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EntityAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EntityAction
         * @function getTypeUrl
         * @memberof world.EntityAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.EntityAction";
        };

        return EntityAction;
    })();

    world.notify_entities = (function() {

        /**
         * Properties of a notify_entities.
         * @memberof world
         * @interface Inotify_entities
         * @property {Array.<world.IEntity>|null} [enterList] notify_entities enterList
         * @property {Array.<number>|null} [leaveList] notify_entities leaveList
         */

        /**
         * Constructs a new notify_entities.
         * @memberof world
         * @classdesc Represents a notify_entities.
         * @implements Inotify_entities
         * @constructor
         * @param {world.Inotify_entities=} [properties] Properties to set
         */
        function notify_entities(properties) {
            this.enterList = [];
            this.leaveList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_entities enterList.
         * @member {Array.<world.IEntity>} enterList
         * @memberof world.notify_entities
         * @instance
         */
        notify_entities.prototype.enterList = $util.emptyArray;

        /**
         * notify_entities leaveList.
         * @member {Array.<number>} leaveList
         * @memberof world.notify_entities
         * @instance
         */
        notify_entities.prototype.leaveList = $util.emptyArray;

        /**
         * Creates a new notify_entities instance using the specified properties.
         * @function create
         * @memberof world.notify_entities
         * @static
         * @param {world.Inotify_entities=} [properties] Properties to set
         * @returns {world.notify_entities} notify_entities instance
         */
        notify_entities.create = function create(properties) {
            return new notify_entities(properties);
        };

        /**
         * Encodes the specified notify_entities message. Does not implicitly {@link world.notify_entities.verify|verify} messages.
         * @function encode
         * @memberof world.notify_entities
         * @static
         * @param {world.Inotify_entities} message notify_entities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_entities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterList != null && message.enterList.length)
                for (var i = 0; i < message.enterList.length; ++i)
                    $root.world.Entity.encode(message.enterList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.leaveList != null && message.leaveList.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.leaveList.length; ++i)
                    writer.uint32(message.leaveList[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified notify_entities message, length delimited. Does not implicitly {@link world.notify_entities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_entities
         * @static
         * @param {world.Inotify_entities} message notify_entities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_entities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_entities message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_entities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_entities} notify_entities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_entities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_entities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        if (!(message.enterList && message.enterList.length))
                            message.enterList = [];
                        message.enterList.push($root.world.Entity.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.leaveList && message.leaveList.length))
                            message.leaveList = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.leaveList.push(reader.uint32());
                        } else
                            message.leaveList.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_entities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_entities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_entities} notify_entities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_entities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_entities message.
         * @function verify
         * @memberof world.notify_entities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_entities.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterList != null && message.hasOwnProperty("enterList")) {
                if (!Array.isArray(message.enterList))
                    return "enterList: array expected";
                for (var i = 0; i < message.enterList.length; ++i) {
                    var error = $root.world.Entity.verify(message.enterList[i]);
                    if (error)
                        return "enterList." + error;
                }
            }
            if (message.leaveList != null && message.hasOwnProperty("leaveList")) {
                if (!Array.isArray(message.leaveList))
                    return "leaveList: array expected";
                for (var i = 0; i < message.leaveList.length; ++i)
                    if (!$util.isInteger(message.leaveList[i]))
                        return "leaveList: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a notify_entities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_entities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_entities} notify_entities
         */
        notify_entities.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_entities)
                return object;
            var message = new $root.world.notify_entities();
            if (object.enterList) {
                if (!Array.isArray(object.enterList))
                    throw TypeError(".world.notify_entities.enterList: array expected");
                message.enterList = [];
                for (var i = 0; i < object.enterList.length; ++i) {
                    if (typeof object.enterList[i] !== "object")
                        throw TypeError(".world.notify_entities.enterList: object expected");
                    message.enterList[i] = $root.world.Entity.fromObject(object.enterList[i]);
                }
            }
            if (object.leaveList) {
                if (!Array.isArray(object.leaveList))
                    throw TypeError(".world.notify_entities.leaveList: array expected");
                message.leaveList = [];
                for (var i = 0; i < object.leaveList.length; ++i)
                    message.leaveList[i] = object.leaveList[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_entities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_entities
         * @static
         * @param {world.notify_entities} message notify_entities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_entities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.enterList = [];
                object.leaveList = [];
            }
            if (message.enterList && message.enterList.length) {
                object.enterList = [];
                for (var j = 0; j < message.enterList.length; ++j)
                    object.enterList[j] = $root.world.Entity.toObject(message.enterList[j], options);
            }
            if (message.leaveList && message.leaveList.length) {
                object.leaveList = [];
                for (var j = 0; j < message.leaveList.length; ++j)
                    object.leaveList[j] = message.leaveList[j];
            }
            return object;
        };

        /**
         * Converts this notify_entities to JSON.
         * @function toJSON
         * @memberof world.notify_entities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_entities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_entities
         * @function getTypeUrl
         * @memberof world.notify_entities
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_entities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_entities";
        };

        return notify_entities;
    })();

    world.notify_actions = (function() {

        /**
         * Properties of a notify_actions.
         * @memberof world
         * @interface Inotify_actions
         * @property {Array.<world.IEntityAction>|null} [actions] notify_actions actions
         */

        /**
         * Constructs a new notify_actions.
         * @memberof world
         * @classdesc Represents a notify_actions.
         * @implements Inotify_actions
         * @constructor
         * @param {world.Inotify_actions=} [properties] Properties to set
         */
        function notify_actions(properties) {
            this.actions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_actions actions.
         * @member {Array.<world.IEntityAction>} actions
         * @memberof world.notify_actions
         * @instance
         */
        notify_actions.prototype.actions = $util.emptyArray;

        /**
         * Creates a new notify_actions instance using the specified properties.
         * @function create
         * @memberof world.notify_actions
         * @static
         * @param {world.Inotify_actions=} [properties] Properties to set
         * @returns {world.notify_actions} notify_actions instance
         */
        notify_actions.create = function create(properties) {
            return new notify_actions(properties);
        };

        /**
         * Encodes the specified notify_actions message. Does not implicitly {@link world.notify_actions.verify|verify} messages.
         * @function encode
         * @memberof world.notify_actions
         * @static
         * @param {world.Inotify_actions} message notify_actions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_actions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (var i = 0; i < message.actions.length; ++i)
                    $root.world.EntityAction.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified notify_actions message, length delimited. Does not implicitly {@link world.notify_actions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_actions
         * @static
         * @param {world.Inotify_actions} message notify_actions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_actions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_actions message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_actions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_actions} notify_actions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_actions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_actions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.world.EntityAction.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_actions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_actions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_actions} notify_actions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_actions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_actions message.
         * @function verify
         * @memberof world.notify_actions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_actions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (var i = 0; i < message.actions.length; ++i) {
                    var error = $root.world.EntityAction.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a notify_actions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_actions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_actions} notify_actions
         */
        notify_actions.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_actions)
                return object;
            var message = new $root.world.notify_actions();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".world.notify_actions.actions: array expected");
                message.actions = [];
                for (var i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".world.notify_actions.actions: object expected");
                    message.actions[i] = $root.world.EntityAction.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a notify_actions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_actions
         * @static
         * @param {world.notify_actions} message notify_actions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_actions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (var j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.world.EntityAction.toObject(message.actions[j], options);
            }
            return object;
        };

        /**
         * Converts this notify_actions to JSON.
         * @function toJSON
         * @memberof world.notify_actions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_actions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_actions
         * @function getTypeUrl
         * @memberof world.notify_actions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_actions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_actions";
        };

        return notify_actions;
    })();

    world.notify_battle_result = (function() {

        /**
         * Properties of a notify_battle_result.
         * @memberof world
         * @interface Inotify_battle_result
         * @property {number|null} [srcEid] notify_battle_result srcEid
         * @property {number|null} [dstEid] notify_battle_result dstEid
         * @property {number|null} [result] notify_battle_result result
         */

        /**
         * Constructs a new notify_battle_result.
         * @memberof world
         * @classdesc Represents a notify_battle_result.
         * @implements Inotify_battle_result
         * @constructor
         * @param {world.Inotify_battle_result=} [properties] Properties to set
         */
        function notify_battle_result(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_battle_result srcEid.
         * @member {number} srcEid
         * @memberof world.notify_battle_result
         * @instance
         */
        notify_battle_result.prototype.srcEid = 0;

        /**
         * notify_battle_result dstEid.
         * @member {number} dstEid
         * @memberof world.notify_battle_result
         * @instance
         */
        notify_battle_result.prototype.dstEid = 0;

        /**
         * notify_battle_result result.
         * @member {number} result
         * @memberof world.notify_battle_result
         * @instance
         */
        notify_battle_result.prototype.result = 0;

        /**
         * Creates a new notify_battle_result instance using the specified properties.
         * @function create
         * @memberof world.notify_battle_result
         * @static
         * @param {world.Inotify_battle_result=} [properties] Properties to set
         * @returns {world.notify_battle_result} notify_battle_result instance
         */
        notify_battle_result.create = function create(properties) {
            return new notify_battle_result(properties);
        };

        /**
         * Encodes the specified notify_battle_result message. Does not implicitly {@link world.notify_battle_result.verify|verify} messages.
         * @function encode
         * @memberof world.notify_battle_result
         * @static
         * @param {world.Inotify_battle_result} message notify_battle_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_battle_result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.srcEid != null && Object.hasOwnProperty.call(message, "srcEid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.srcEid);
            if (message.dstEid != null && Object.hasOwnProperty.call(message, "dstEid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.dstEid);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.result);
            return writer;
        };

        /**
         * Encodes the specified notify_battle_result message, length delimited. Does not implicitly {@link world.notify_battle_result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_battle_result
         * @static
         * @param {world.Inotify_battle_result} message notify_battle_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_battle_result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_battle_result message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_battle_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_battle_result} notify_battle_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_battle_result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_battle_result();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.srcEid = reader.uint32();
                        break;
                    }
                case 2: {
                        message.dstEid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.result = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_battle_result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_battle_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_battle_result} notify_battle_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_battle_result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_battle_result message.
         * @function verify
         * @memberof world.notify_battle_result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_battle_result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.srcEid != null && message.hasOwnProperty("srcEid"))
                if (!$util.isInteger(message.srcEid))
                    return "srcEid: integer expected";
            if (message.dstEid != null && message.hasOwnProperty("dstEid"))
                if (!$util.isInteger(message.dstEid))
                    return "dstEid: integer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            return null;
        };

        /**
         * Creates a notify_battle_result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_battle_result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_battle_result} notify_battle_result
         */
        notify_battle_result.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_battle_result)
                return object;
            var message = new $root.world.notify_battle_result();
            if (object.srcEid != null)
                message.srcEid = object.srcEid >>> 0;
            if (object.dstEid != null)
                message.dstEid = object.dstEid >>> 0;
            if (object.result != null)
                message.result = object.result >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a notify_battle_result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_battle_result
         * @static
         * @param {world.notify_battle_result} message notify_battle_result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_battle_result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.srcEid = 0;
                object.dstEid = 0;
                object.result = 0;
            }
            if (message.srcEid != null && message.hasOwnProperty("srcEid"))
                object.srcEid = message.srcEid;
            if (message.dstEid != null && message.hasOwnProperty("dstEid"))
                object.dstEid = message.dstEid;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };

        /**
         * Converts this notify_battle_result to JSON.
         * @function toJSON
         * @memberof world.notify_battle_result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_battle_result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_battle_result
         * @function getTypeUrl
         * @memberof world.notify_battle_result
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_battle_result.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_battle_result";
        };

        return notify_battle_result;
    })();

    world.notify_occupy_result = (function() {

        /**
         * Properties of a notify_occupy_result.
         * @memberof world
         * @interface Inotify_occupy_result
         * @property {number|null} [type] notify_occupy_result type
         * @property {number|null} [aid] notify_occupy_result aid
         * @property {number|null} [bid] notify_occupy_result bid
         * @property {number|null} [eid] notify_occupy_result eid
         */

        /**
         * Constructs a new notify_occupy_result.
         * @memberof world
         * @classdesc Represents a notify_occupy_result.
         * @implements Inotify_occupy_result
         * @constructor
         * @param {world.Inotify_occupy_result=} [properties] Properties to set
         */
        function notify_occupy_result(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * notify_occupy_result type.
         * @member {number} type
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.type = 0;

        /**
         * notify_occupy_result aid.
         * @member {number} aid
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.aid = 0;

        /**
         * notify_occupy_result bid.
         * @member {number} bid
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.bid = 0;

        /**
         * notify_occupy_result eid.
         * @member {number} eid
         * @memberof world.notify_occupy_result
         * @instance
         */
        notify_occupy_result.prototype.eid = 0;

        /**
         * Creates a new notify_occupy_result instance using the specified properties.
         * @function create
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.Inotify_occupy_result=} [properties] Properties to set
         * @returns {world.notify_occupy_result} notify_occupy_result instance
         */
        notify_occupy_result.create = function create(properties) {
            return new notify_occupy_result(properties);
        };

        /**
         * Encodes the specified notify_occupy_result message. Does not implicitly {@link world.notify_occupy_result.verify|verify} messages.
         * @function encode
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.Inotify_occupy_result} message notify_occupy_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_occupy_result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.aid != null && Object.hasOwnProperty.call(message, "aid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.aid);
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.bid);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.eid);
            return writer;
        };

        /**
         * Encodes the specified notify_occupy_result message, length delimited. Does not implicitly {@link world.notify_occupy_result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.Inotify_occupy_result} message notify_occupy_result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        notify_occupy_result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a notify_occupy_result message from the specified reader or buffer.
         * @function decode
         * @memberof world.notify_occupy_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {world.notify_occupy_result} notify_occupy_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_occupy_result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.world.notify_occupy_result();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.uint32();
                        break;
                    }
                case 2: {
                        message.aid = reader.uint32();
                        break;
                    }
                case 3: {
                        message.bid = reader.uint32();
                        break;
                    }
                case 4: {
                        message.eid = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a notify_occupy_result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof world.notify_occupy_result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {world.notify_occupy_result} notify_occupy_result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        notify_occupy_result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a notify_occupy_result message.
         * @function verify
         * @memberof world.notify_occupy_result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        notify_occupy_result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.aid != null && message.hasOwnProperty("aid"))
                if (!$util.isInteger(message.aid))
                    return "aid: integer expected";
            if (message.bid != null && message.hasOwnProperty("bid"))
                if (!$util.isInteger(message.bid))
                    return "bid: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            return null;
        };

        /**
         * Creates a notify_occupy_result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof world.notify_occupy_result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {world.notify_occupy_result} notify_occupy_result
         */
        notify_occupy_result.fromObject = function fromObject(object) {
            if (object instanceof $root.world.notify_occupy_result)
                return object;
            var message = new $root.world.notify_occupy_result();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.aid != null)
                message.aid = object.aid >>> 0;
            if (object.bid != null)
                message.bid = object.bid >>> 0;
            if (object.eid != null)
                message.eid = object.eid >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a notify_occupy_result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof world.notify_occupy_result
         * @static
         * @param {world.notify_occupy_result} message notify_occupy_result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        notify_occupy_result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.aid = 0;
                object.bid = 0;
                object.eid = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.aid != null && message.hasOwnProperty("aid"))
                object.aid = message.aid;
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = message.bid;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            return object;
        };

        /**
         * Converts this notify_occupy_result to JSON.
         * @function toJSON
         * @memberof world.notify_occupy_result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        notify_occupy_result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for notify_occupy_result
         * @function getTypeUrl
         * @memberof world.notify_occupy_result
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        notify_occupy_result.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/world.notify_occupy_result";
        };

        return notify_occupy_result;
    })();

    return world;
})();

module.exports = $root;
